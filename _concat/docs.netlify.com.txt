INDEX:
- accounts-and-billing_team-management_roles-and-permissions.txt
- ai-assisted-publishing.txt
- api_get-started.txt
- ask-netlify.txt
- blobs_overview.txt
- build-plugins.txt
- build-plugins_create-plugins.txt
- build-plugins_share-plugins.txt
- cli_debug-with-vscode.txt
- cli_get-started.txt
- cli_local-development.txt
- cli_manage-functions.txt
- configure-builds_available-software-at-build-time.txt
- configure-builds_build-hooks.txt
- configure-builds_environment-variables.txt
- configure-builds_file-based-configuration.txt
- configure-builds_ignore-builds.txt
- configure-builds_javascript-spas.txt
- configure-builds_manage-dependencies.txt
- configure-builds_monorepos.txt
- configure-builds_on-demand-builders.txt
- configure-builds_overview.txt
- configure-builds_stop-or-activate-builds.txt
- configure-builds_troubleshooting-tips.txt
- connect_access-data.txt
- connect_api-authentication.txt
- connect_data-revisions.txt
- connect_get-started.txt
- connect_manage-data-layers_manage-cross-references.txt
- connect_manage-data-layers_manage-data-sources.txt
- connect_monitor-activity.txt
- connect_overview.txt
- connect_sync-events.txt
- connect_troubleshooting-tips.txt
- connect_usage-and-billing.txt
- create_get-started.txt
- create_overview.txt
- create_visual-editing.txt
- domains_configure-domains_add-a-domain-alias.txt
- domains_configure-domains_bring-a-domain-to-netlify.txt
- domains_configure-domains_configure-an-automatic-subdomain-for-deploys.txt
- domains_configure-domains_configure-external-dns.txt
- domains_configure-domains_delegate-a-standalone-subdomain.txt
- domains_configure-domains_dns-records.txt
- domains_configure-domains_enable-ipv6.txt
- domains_configure-domains_netlify-name-servers.txt
- domains_configure-domains_register-and-buy-a-domain.txt
- domains_domains-fundamentals_domains-glossary.txt
- domains_domains-fundamentals_understand-domains.txt
- domains_get-started-with-domains.txt
- domains_manage-domains_add-domain-redirect.txt
- domains_manage-domains_assign-a-domain-to-your-site-app.txt
- domains_manage-domains_automatic-deploy-subdomains.txt
- domains_manage-domains_manage-domains-for-a-site-app.txt
- domains_manage-domains_manage-domains-for-branch-deploys.txt
- domains_manage-domains_manage-domains-for-deploy-previews.txt
- domains_manage-domains_manage-multiple-domains.txt
- domains_manage-domains_overview.txt
- domains_manage-domains_transfer-a-domain.txt
- domains_secure-domains-with-https_https-ssl.txt
- domains_set-up-netlify-dns.txt
- domains_troubleshooting-tips.txt
- domains_why-netlify-dns.txt
- edge-functions_api.txt
- edge-functions_create-integration.txt
- edge-functions_declarations.txt
- edge-functions_get-started.txt
- edge-functions_limits.txt
- edge-functions_optional-configuration.txt
- edge-functions_overview.txt
- edge-functions_usage-and-billing.txt
- environment-variables_get-started.txt
- environment-variables_overview.txt
- environment-variables_secrets-controller.txt
- forms_notifications.txt
- forms_setup.txt
- forms_spam-filters.txt
- forms_submissions.txt
- forms_troubleshooting-tips.txt
- forms_usage-and-billing.txt
- frameworks-api.txt
- frameworks.txt
- frameworks_angular.txt
- frameworks_astro.txt
- frameworks_eleventy.txt
- frameworks_environment-variables.txt
- frameworks_express.txt
- frameworks_gatsby.txt
- frameworks_hugo.txt
- frameworks_hydrogen.txt
- frameworks_next-js_overview.txt
- frameworks_next-js_runtime-v4_adapter-upgrade.txt
- frameworks_next-js_runtime-v4_advanced-api-routes.txt
- frameworks_next-js_runtime-v4_middleware.txt
- frameworks_next-js_runtime-v4_overview.txt
- frameworks_next-js_runtime-v4_redirects-and-rewrites.txt
- frameworks_next-js_runtime-v4_troubleshooting.txt
- frameworks_nuxt.txt
- frameworks_react-router.txt
- frameworks_react.txt
- frameworks_remix.txt
- frameworks_sveltekit.txt
- frameworks_tanstack-start.txt
- frameworks_vite.txt
- frameworks_vue-cli.txt
- functions_api.txt
- functions_background-functions.txt
- functions_deploy.txt
- functions_environment-variables.txt
- functions_functions-and-identity.txt
- functions_get-started.txt
- functions_lambda-compatibility.txt
- functions_logs.txt
- functions_optional-configuration.txt
- functions_overview.txt
- functions_scheduled-functions.txt
- functions_trigger-on-events.txt
- functions_usage-and-billing.txt
- get-started.txt
- git_repo-permissions-linking.txt
- image-cdn_overview.txt
- images_connect-how-connect-works-diagram-1.png.txt
- images_connect-syncing-data.png.txt
- index.txt
- integrations_contentful-integration.txt
- integrations_extend-netlify.txt
- integrations_overview.txt
- monitor-sites_function-metrics.txt
- monitor-sites_lighthouse.txt
- monitor-sites_log-drains.txt
- monitor-sites_monitor-builds.txt
- monitor-sites_notifications.txt
- monitor-sites_project-analytics.txt
- monitor-sites_real-user-metrics.txt
- monitor-sites_status-badges.txt
- platform_cache-api.txt
- platform_caching.txt
- platform_launch-checklist.txt
- platform_netlify-labs_experimental-features.txt
- platform_primitives.txt
- platform_release-phases.txt
- platform_request-chain.txt
- platform_security-checklist.txt
- platform_what-is-netlify.txt
- platform_who-is-netlify-for.txt
- routing_headers.txt
- routing_overview.txt
- routing_redirects.txt
- routing_redirects_redirect-options.txt
- routing_redirects_rewrites-proxies.txt
- scraping_log.txt
- security_content-security-policy.txt
- security_overview.txt
- security_private-connectivity.txt
- security_secure-access-to-sites.txt
- security_secure-access-to-sites_rate-limiting.txt
- security_secure-access-to-sites_site-protection.txt
- security_secure-access-to-sites_traffic-rules.txt
- security_secure-access-to-sites_web-application-firewall.txt
- security_secure-netlify-access.txt
- security_secure-netlify-access_enforce-2fa.txt
- security_security-scorecard.txt
- site-deploys_collaborate-on-deploys.txt
- site-deploys_create-deploys.txt
- site-deploys_deploy-previews.txt
- site-deploys_disable-projects.txt
- site-deploys_fix-a-failed-deploy.txt
- site-deploys_heads-up-display.txt
- site-deploys_manage-deploys.txt
- site-deploys_netlify-reviewer-quickstart.txt
- site-deploys_notifications.txt
- site-deploys_overview.txt
- site-deploys_split-testing.txt
- site-deploys_troubleshoot-the-netlify-drawer.txt
- slack-app.txt
- terraform-provider.txt
- visual-editor_analytics.txt
- visual-editor_automatic-content-reload.txt
- visual-editor_concepts_content-driven-development.txt
- visual-editor_concepts_how-visual-editor-works.txt
- visual-editor_concepts_overview.txt
- visual-editor_concepts_reusable-content.txt
- visual-editor_concepts_structured-content.txt
- visual-editor_concepts_two-way-content-sync.txt
- visual-editor_content-presets.txt
- visual-editor_content-sources_overview.txt
- visual-editor_custom-actions.txt
- visual-editor_document-hooks.txt
- visual-editor_editorial-permissions.txt
- visual-editor_frameworks_overview.txt
- visual-editor_get-started_get-started-overview.txt
- visual-editor_global-styles.txt
- visual-editor_local-development.txt
- visual-editor_localization.txt
- visual-editor_overview.txt
- visual-editor_personalization.txt
- visual-editor_preview-controls.txt
- visual-editor_sitemap-navigator.txt
- visual-editor_tree-view.txt
- visual-editor_troubleshoot.txt
- visual-editor_version-control.txt
- visual-editor_visual-editing.txt
- visual-editor_visual-editing_content-editor.txt
- visual-editor_visual-editing_custom-fields.txt
- visual-editor_visual-editing_field-controls.txt
- visual-editor_visual-editing_field-groups.txt
- visual-editor_visual-editing_inline-editor.txt
- visual-editor_visual-editing_page-editor.txt
- visual-editor_visual-editing_sidebar-buttons.txt
- visual-editor_visual-editing_status-labels.txt
- welcome_add-new-project.txt
- welcome_command-palette.txt
- welcome_get-help_ask-netlify.txt
- welcome_get-help_resources-and-tips.txt

-------- accounts-and-billing_team-management_roles-and-permissions.txt --------
Start of file
URL: https://docs.netlify.com/accounts-and-billing/team-management/roles-and-permissions/
Scraped_At: 2025-06-02T19:56:16.089012

Contact
Forums
Contact support
Owners can assign roles to individuals invited to a team and manage their access and permissions across the Netlify platform.
#
Overview
A role defines a standard set of permissions that a person has by default once they are assigned that role.
Since Netlify roles are optimized for cross-functional collaboration across the Netlify platform, a role can determine a person’s access to different parts of the platform. An Owner can also customize site access for certain roles.
A Team Owner can manage team roles and invite or remove new members from the
Members
page in
Team Settings
unless you’ve set up
SCIM
to manage access control through an identity provider. Learn more about your options to
manage a team
.
To optimize content publishing workflows, a Team Owner, Developer, or Publisher can customize even more granular
editorial permissions
for Visual Editor.
#
Access
Owners can customize site access and Visual Editor access for certain roles. Other roles have predetermined access that Owners can’t modify, such as Billing Admins who have limited access to the Netlify platform beyond reviewing and managing billing.
Team Owners can access all settings, sites, and resources owned by the team. Only Organization Owners can access organization settings for
Enterprise plans
that have set up an organization.
#
Site access
An Owner can choose which sites people in these roles can access:
Developers
Publishers
Content Editors
Reviewers
Git Contributors have no access to the Netlify platform beyond being able to trigger a deploy and access site preview links that appear in pull/merge requests, Slack, or other places.
Git Contributors can access site preview links for Deploy Previews and branch deploys as long as the links do not require Netlify Team Login, Netlify SSO, or other forms of authentication that a Git Contributor does not have.
#
Visual Editor access
By default, all Developers, Publishers, and Content Editors in a team can access that team’s Visual Editor dashboard. Reviewers can access preview links from Visual Editor.
Within Visual Editor workspace, Owners, Developers, and Publishers can customize more granular access to Visual Editor projects, which are sites that have Visual Editor enabled and configured. Learn more about
editorial permissions
for Visual Editor.
Before a site can be edited with Visual Editor, a Team Owner or Developer must enable Visual Editor for that site and complete any necessary configuration so the site works with Visual Editor.
#
Roles and permissions
Role options vary by
plan
.
This overview summarizes the permissions for each role. For a description of each role, check out the
roles overview
.
#
Standard roles and permissions
Owner
Developer
Billing Admin
Git Contributor
Reviewer
Create sites
✓
✓
Trigger builds  (Trigger from Git/deploy from Git)
✓
✓
✓
Access and edit site configuration
✓
✓
Collaborate using the  Netlify Drawer to share feedback on preview sites
✓
✓
✓
✓
Change levels for project add-ons (formerly called site add-ons)
✓
✓
Modify billing information
✓
✓
Change team plan
✓
✓
Add or remove extra concurrent builds
✓
Add or remove members
✓
Add and approve Reviewers
✓
✓
Modify member roles
✓
Edit team settings
✓
Deploy to sites from private repos
✓
✓
✓
Install and uninstall extensions
✓
Add or edit data layers in Netlify Connect
✓
✓
Delete data layers in Netlify Connect
✓
Add or edit cross-references in Netlify Connect
✓
✓
Delete cross-references in Netlify Connect
✓
Add, edit, or delete API tokens in Netlify Connect
✓
✓
Add or edit API scopes in Netlify Connect
✓
✓
Delete API scopes in Netlify Connect
✓
Delete or transfer projects
✓
Delete the team
✓
Access preview site links for sharing feedback
✓
Publish and manage extensions on Netlify as an author
✓
#
Visual Editor roles and permissions
These roles can access Visual Editor:
Publisher
Content Editor
Developer
Team Owner
Reviewer
There are more customizable permissions available in Visual Editor.
Team Owners, Developers, Publishers, and other users with the
Manage Collaborators
permission can customize editorial permissions, create and manage member groups that can be assigned to projects, and choose who can access a project in Visual Editor workspace. Note that a project is a site that you can edit with Visual Editor.
Learn more about these options in
Editorial permissions
.
#
Roles
When you add a person to your team, you must assign them a role. For some roles, you must also choose which sites they can access.
Netlify team roles include:
Owners
Developers
Publishers
Content Editors
Git Contributors
Reviewers
Billing Admins
#
Owner
Owners can access the entire team account and are able to add or remove members, adjust settings and roles, create and delete projects, and more. If user access control is managed by
SCIM
through an identity provider, then an identity provider admin will be able to invite and remove members.
#
Team Owner
Every team must have at least one Owner at all times and can have multiple Owners. Owners cannot remove or demote themselves unless there is at least one additional Owner on the team.
A Team Owner is a paid role, which means they contribute to your
total member count
and are included on your bill.
#
Organization Owner
If you have a
Enterprise plan
, you have the option of setting up an Organization. Organizations can have multiple teams and are managed by one or more Organization Owner.
Organization Owners
have the Team Owner role in all teams by default.
#
Developer
Collaborators are now Developers
As a part of expanding Netlify roles, the role formerly called Collaborator is now called the Developer role. The role retains the same main permissions with some
expanded access and permissions in Visual Editor
. Learn more about this change in the
blog post
.
Developers can manage site deploys and other site configuration needs.
Team Owners can
change site access
to allow Developers to work on all sites within the team, or only on specific sites. Developers with access to a site can do things like trigger builds, edit site configuration, and more.
Developers can configure a site for use in Visual Editor. They can also edit, publish, and manage project collaborators in Visual Editor. Learn more about what
Developers can do in Visual Editor
.
Developers can also
approve or block Reviewers
so Reviewers can use the
Netlify Drawer
to review branch deploys or Deploy Previews.
Although Developers can
remove themselves from a team
, they can’t remove other members.
Developers are paid roles. They contribute to your
total member count
and are included on your bill.
#
Publisher
A Publisher can do everything a Content Editor can do in Visual Editor but they can also publish content, schedule when to publish content, and manage Visual Editor project collaborators. Learn more about
Publishers
.
#
Content Editor
A Content Editor can edit content in Visual Editor but they cannot publish content live to your site. Content editing includes drafting and saving text, managing images, managing SEO settings, and customizing layouts. Content Editors can save a version of their work for review or follow-up with a Publisher. Learn more about
Content Editors
.
#
Git Contributor
When a non-team member triggers a build, a Team Owner can choose to add them to the team as a Git Contributor. Git Contributors can trigger builds, deploys, or Deploy Previews through Netlify from a private Git repository. They do not have access to the Netlify app or your team’s Netlify workspace.
If you’re a Team Owner, you can add new Git Contributors to your team
manually for each deploy request
, or automatically by
enabling auto-approval
in
Team Settings
.
If you are on a
Core Pro or Enterprise plan
, you will be charged for Git Contributors who have triggered a deploy during your team’s billing period. These active Git Contributors also contribute to your
total member count
. The Members page shows a list of your team’s active and inactive Git Contributors.
If a Git Contributor hasn’t collaborated on any of your team’s sites during a billing period, they will be marked as inactive and you will not be charged for them. If needed, you can
remove inactive Git Contributors
from your team.
Reference the
Billing FAQ
page for more details.
#
Reviewer
Once a Team Owner or Developer
approves
a Reviewer, that person can access preview links across sites in the team so they can
share site feedback on Deploy Previews
or on
branch deploys
.
A Team Owner can add an unlimited number of Reviewers
to your team for free
. Reviewers do not contribute to your total member count, and are not included on your bill.
Reviewers can also access read-only preview links from Visual Editor.
To learn how to give site feedback as a Reviewer, check out our
Reviewers quickstart
.
#
Billing Admin
This feature is available on
Enterprise
plans.
Billing Admins can change the team plan and modify billing information, but do not have access to other team or site features.
Last updated: May 13, 2025
←
Manage team members
Team-owned sites
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- ai-assisted-publishing.txt --------
Start of file
URL: https://docs.netlify.com/ai-assisted-publishing/
Scraped_At: 2025-06-02T19:56:16.921877

Private Beta
AI-Assisted Publishing is currently in private beta. Learn more about the feature and how to get access.
Learn more
###End of file##

-------- api_get-started.txt --------
Start of file
URL: https://docs.netlify.com/api/get-started/
Scraped_At: 2025-06-02T19:56:20.704746

Contact
Forums
Contact support
Use the Netlify REST API to manage atomic deploys of your sites and apps, manage form submissions, inject JavaScript snippets, manage DNS, and so much more.
This document covers the basics for interacting with the Netlify API, plus instructions for
deploying sites
and notes on some
commonly used endpoints
.
You can browse the
OpenAPI reference for the Netlify API
to explore available endpoints. Visit our Forums for more tips and conversation about
understanding and using Netlify’s API
.
Additionally, we have two API clients for your convenience:
Go Client
JS Client
If you’d like to interact with the Netlify API using a no-code tool, you can use n8n.io’s
Netlify node
. The node currently supports the following operations:
Create a new deployment
Get a deployment
Get all deployments
Cancel a deployment
Get a site
Get all sites
Delete a site
#
Make a request
All URLs start with
https://api.netlify.com/api/v1/
.
SSL only
. The path is prefixed with the API version. If we change the API in backward-incompatible ways, we’ll bump the version marker and maintain stable support for the old URLs.
To make a request for all sites you have access to, for example, append the
sites
index path to the base URL to form something like
https://api.netlify.com/api/v1/sites
. Here’s an example in curl:
curl
-H
"User-Agent: MyApp (YOUR_NAME@EXAMPLE.COM)"
\
-H
"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN"
\
https://api.netlify.com/api/v1/sites
#
Authentication
Netlify uses OAuth2 for authentication. All requests must use HTTPS.
To generate a personal access token (PAT):
Go to
Applications
>
Personal access tokens
.
Select
New access token
.
Enter a descriptive name to help you remember what the token will be used for.
Select
Allow access to my SAML-based Netlify team
to authorize access to your SAML-based team data through the API.
Select an
Expiration
date for your token to help keep your information secure.
Select
Generate token
.
Copy the token to your clipboard and store it in a safe location. Once you navigate away from this page, you won’t be able to access the value again.
Select
Done
.
Use your PAT for manual authentication in shell scripts or commands that use the Netlify API.
To authenticate API requests, include the token in the authorization header:
Authorization: Bearer <YOUR_PERSONAL_ACCESS_TOKEN>
To authenticate in shell scripts, refer to the
code sample above
for an example of how to use this token in a curl request.
SAML SSO
If your team requires you to log in with
single sign-on (SSO)
, your personal access tokens will be denied access to the team by default. You can choose to grant access to the team when you generate a new token. You must be logged in to the team with SSO to grant access to it.
If you’re making a public integration with Netlify for others to enjoy, you must use OAuth2. This allows users to authorize your application to use Netlify on their behalf without having to copy/paste API tokens or touch sensitive login info. You’ll need an application client key and a client secret to integrate with the Netlify API. You can register a new application in your Netlify user settings for
OAuth applications
. Visit our blog post on
integrating with Netlify
for more information including common grant types and an example project.
The OAuth2 end-user authorization endpoint is
https://app.netlify.com/authorize
.
#
Rate limiting
To protect Netlify from getting flooded by automated deploys or misbehaving applications, the Netlify API is rate limited.
You can make up to 500 requests per minute for most requests.
Certain operations have their own stricter limits. For example, you can deploy through the Netlify API up to 3 times per minute and up to 100 times per day.
You can check the returned HTTP headers of any API request to verify your current rate limit status:
X-RateLimit-Limit
:
500
X-RateLimit-Remaining
:
56
X-RateLimit-Reset
:
1372700873
If you need higher limits, please
contact us
.
#
Pagination
All API requests that return over 100 items are paginated by default, with a limit of 100 items per page. You can specify further pages with the
?page
parameter. You can also set a custom page size that’s less than 100 with the
?per_page
parameter.
Note that page numbering starts with 1 and that omitting the
?page
parameter will return the first page.
#
Link header
The pagination info is included in the
Link
header.
Link
:
<https://api.netlify.com/api/v1/sites?page=3&per_page=20>; rel="next",
    <https://api.netlify.com/api/v1/sites?page=5&per_page=20>; rel="last"
Linebreak is included for readability.
The possible
rel
values are:
next
Shows the URL of the immediate next page of results.
last
Shows the URL of the last page of results.
prev
Shows the URL of the immediate previous page of results.
#
Deploy with the API
The most common API action is doing deploys, either of a new site or an existing site. If
builds are stopped
for an existing site, you can still deploy with the API to update the site.
Netlify supports two ways of doing deploys:
Sending a digest
of all files in your deploy, and then uploading any files Netlify doesn’t already have on its storage servers.
Sending a ZIP file
of the entire site and letting Netlify unzip and deploy.
We generally recommend the first way, since it’s more efficient.
Whether you deploy a brand new site or create a deploy within an existing site, the process is similar.
First
create a new site
, if needed:
POST /api/v1/sites
Now you have a site ID and you can create a new deploy, either with a
file digest
or a
ZIP file
.
#
File digest method
We recommend using a digest including a file path and SHA1 for each item. This method also allows you to upload serverless functions, however serverless functions should use SHA256 instead.
POST /api/v1/sites/{site_id}/deploys
{
"files"
:
{
"/index.html"
:
"907d14fb3af2b0d4f18c2d46abe8aedce17367bd"
,
"/main.css"
:
"f18c2d7367bd9046abe8aedce17d14fb3af2b0d4"
}
,
"functions"
:
{
"hello-world"
:
"708b029d8aa9c8fa513d1a25b97ffb6efb12b423"
}
}
When using a file digest, the API will return an object which includes the following properties:
{
"id"
:
"1234"
,
"required"
:
[
"907d14fb3af2b0d4f18c2d46abe8aedce17367bd"
]
,
"required_functions"
:
[
"708b029d8aa9c8fa513d1a25b97ffb6efb12b423"
]
}
The
required
property will give you a list of files by SHA1 that you need to upload. Similarly,
required_functions
will get you an array of required functions by SHA256 to upload, if you included a functions digest when creating the deploy.
Tip
If you have two files with the same SHA1, you don’t have to upload both of them.
Now upload the files, using the deploy ID returned as
id
in the file digest response:
PUT /api/v1/deploys/{deploy_id}/files/index.html
Warning
Be sure to escape the
file_path
parameter, and ensure file paths don’t include
#
or
?
characters.
Use
Content-Type: application/octet-stream
and use the file contents as the HTTP request body.
If the required file is a function, upload it to the functions endpoint, again using the deploy ID returned as
id
in the file digest response:
PUT /api/v1/deploys/{deploy_id}/functions/hello-world?runtime=js
Possible
runtime
parameters are:
js
: zipped Node.js programs or bundled JavaScript files
go
: Go binaries
When uploading functions, use the name of the function, not the file path or any file extensions. Clients must zip the function prior to uploading to the API.
Once all files have been uploaded, Netlify will post process the deploy and invalidate the CDN.
#
Async requests for large deploys
API requests that last longer than 30 seconds will be terminated automatically. When creating large deploys, pass the
async
property in your file digest:
{
"async"
:
true
,
"files"
:
{
"/index.html"
:
"907d14fb3af2b0d4f18c2d46abe8aedce17367bd"
}
,
"functions"
:
{
"hello-world"
:
"708b029d8aa9c8fa513d1a25b97ffb6efb12b423"
}
}
The request will then return the deploy ID (as
id
) which can be polled to determine when the deploy is ready for file uploads.
GET /api/v1/sites/{site_id}/deploys/{deploy_id}
You can check the
state
parameter in the response. It will be set to
preparing
as the upload manifest is generated, and either
prepared
,
uploading
,
uploaded
, or
ready
depending on the contents of the deploy. At this point, the deploy is either
ready
, or the API will give you a list of
required
files and
required_functions
.
Additionally, when uploading large files, sometimes the request will time out. It is safe to retry these uploads a few times to verify whether additional attempts are successful.
#
ZIP file method
You can deploy using a ZIP file but note there’s a limit of 25,000 files per zip extraction for a site. For the same site, you always need to upload a single zip with all the files.
To deploy using a ZIP file, create a new deploy with
Content-Type: application/zip
and the ZIP file as the HTTP request body:
POST /api/v1/sites/{site_id}/deploys
A deploy from a ZIP file will enter post-processing mode straight after being created.
While we generally recommend using file digests, you can use the ZIP file method straight from the command line with cURL:
curl
-H
"Content-Type: application/zip"
\
-H
"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN"
\
--data-binary
"@website.zip"
\
https://api.netlify.com/api/v1/sites/mysite.netlify.app/deploys
#
Create and deploy at once
When creating a new site, you can include a file digest or a ZIP file straight away, to save an HTTP request.
The following will create a new site and deploy it from a ZIP file:
curl
-H
"Content-Type: application/zip"
\
-H
"Authorization: Bearer YOUR_OAUTH2_ACCESS_TOKEN"
\
--data-binary
"@website.zip"
\
https://api.netlify.com/api/v1/sites
#
Poll for deploy state
You can poll the deploy to check the state:
GET /api/v1/deploys/{deploy_id}
{
"id"
:
"1234"
,
"state"
:
"ready"
}
Once the state changes to
ready
, the deploy is live.
#
Draft deploys
When creating a new deploy, you can set
"draft": true
to mark the deploy as a draft deploy.
A draft deploy works like a normal deploy, but it won’t change the current published deploy of the site when it’s done processing.
#
Commonly used endpoints
This section describes usage for some popular endpoints.
We also have an
OpenAPI reference for the Netlify API
that you can explore.
Visit our Forums for more tips and conversation about
understanding and using Netlify’s API
.
#
Sites
The
/sites
endpoint allows you to access sites deployed on Netlify.
Trying to manage your site’s environment variables?
To update or retrieve your site’s environment variables, leverage the
environment variables
endpoints. The
/sites
endpoint does not support environment variables.
#
Get sites
GET /api/v1/sites
returns all sites you have access to.
[
{
"id"
:
"3970e0fe-8564-4903-9a55-c5f8de49fb8b"
,
"premium"
:
false
,
"claimed"
:
true
,
"name"
:
"synergy"
,
"custom_domain"
:
"www.example.com"
,
"url"
:
"http://www.example.com"
,
"admin_url"
:
"https://api.netlify.com/sites/synergy"
,
"screenshot_url"
:
null
,
"created_at"
:
"2013-09-17T05:13:08Z"
,
"updated_at"
:
"2013-09-17T05:13:19Z"
,
"user_id"
:
"51f60d2d5803545326000005"
}
]
#
Get site
GET /api/v1/sites/{site_id}
returns the specified site.
About site IDs
You can find a value for
{site_id}
by visiting the Netlify UI at
Project configuration
>
General
>
Project details
>
Project information
. Project IDs (formerly called site IDs) are also available in the response when you
create a site
or
get a list of sites
.
Whenever the API requires a
{site_id}
, you can either use the
id
of a site obtained through the API, or the domain of the site (for example,
mysite.netlify.app
or
www.example.com
). These two are interchangeable whenever they’re used in API paths.
GET /api/v1/sites/3970e0fe-8564-4903-9a55-c5f8de49fb8b
returns the site with a matching
id
.
GET /api/v1/sites/www.example.com
returns the site matching the domain
www.example.com
.
{
"id"
:
"3970e0fe-8564-4903-9a55-c5f8de49fb8b"
,
"premium"
:
false
,
"claimed"
:
true
,
"name"
:
"synergy"
,
"custom_domain"
:
"www.example.com"
,
"notification_email"
:
"me@example.com"
,
"url"
:
"http://www.example.com"
,
"admin_url"
:
"https://api.netlify.com/sites/synergy"
,
"screenshot_url"
:
null
,
"created_at"
:
"2013-09-17T05:13:08Z"
,
"updated_at"
:
"2013-09-17T05:13:19Z"
,
"user_id"
:
"51f60d2d5803545326000005"
}
#
Create site
POST /api/v1/sites
creates a new site. By default the site will be created in your personal team.
When creating a site, you can set the following properties:
name
: the name of the site (
mysite
.netlify.app)
custom_domain
: the custom domain of the site (www.example.com)
password
: password protect the site
force_ssl
: will force SSL on the site if SSL is enabled
processing_settings
: sets the Pretty URLs post processing setting:
{
"html"
:
{
"pretty_urls"
:
true
}
}
repo
: configures continuous deployment. It’s a bit complicated to create a
repo
object so please visit our Forums for a verified Support Guide on
linking a repository using the API
.
#
Create site in team
POST /api/v1/{account_slug}/sites/
creates a new site in a specific team. It takes the same parameters as when creating a site.
#
Update site
PATCH /api/v1/sites/{site_id}
updates some attributes on a site.
PUT /api/v1/sites/{site_id}
updates some attributes on a site.
This lets you update a site. It takes all the same parameters as when creating a site.
If you do a PUT request to a site with
Content-Type: application/zip
and a zipped website in the HTTP request body, it works exactly like creating a new deploy for the site based on a ZIP file.
#
Provision SSL for a site
POST /api/v1/sites/{site_id}/ssl
activates SSL for a site.
The site must have a custom domain with DNS records configured to point to Netlify’s infrastructure.
Any domain aliases with valid DNS records will also be included in the SSL certificate for the site.
This endpoint manually triggers SSL provisioning for a site’s custom domains. Once SSL provisioning is successful, the domain will be served over HTTPS.
#
Delete site
DELETE /api/v1/sites/{site_id}
permanently deletes a site.
This will return
200 OK
.
#
Site metadata
Each site has a metadata object. The properties of the metadata object can be used within the
snippets
for a site by using the
Liquid
template syntax.
#
Get metadata
GET /api/v1/sites/{site_id}/metadata
gets the metadata for a site.
{
"my_meta_key"
:
"my_meta_value"
}
#
Update metadata
PUT /api/v1/sites/{site_id}/metadata
replaces the metadata object with a new metadata object.
#
Environment variables
The
environment variables API endpoints
allow you to access and set both site and shared environment variables. Environment variable changes require a build and deploy to take effect.
#
Get environment variables
GET /api/v1/accounts/{account_id}/env
returns all environment variables for a team or site. The list will only include shared environment variables if the request is made by a Team Owner.
GET /api/v1/accounts/{account_id}/env/{key}
returns an individual environment variable for a team or site.
About account IDs
You can find a value for
{account_id}
by querying
GET /api/v1/accounts/{account_slug}
. The slug is available in the Netlify UI at
Team settings
>
General
>
Team details
>
Team information
. An account in the Netlify REST API is equivalent to a team in the UI.
Whenever the API requires an
{account_id}
, you can substitute
{account_slug}
. These two are interchangeable whenever they’re used in API paths.
#
Create and update environment variables
POST /api/v1/accounts/{account_id}/env
creates site or shared environment variables with the specified scopes and contextual values. An environment variable’s contextual values are the different values set for use in each
deploy context
.
PUT /api/v1/accounts/{account_id}/env/{key}
updates an existing environment variable by replacing all of its values with the values provided with this request.
PATCH /api/v1/accounts/{account_id}/env/{key}
updates or creates a new value for an existing environment variable.
#
Delete environment variables
DELETE /api/v1/accounts/{account_id}/env/{key}
deletes an environment variable and all of its values.
DELETE /api/v1/accounts/{account_id}/env/{key}/value/{id}
deletes a specific environment variable value.
#
Files
All files deployed by Netlify can be read through the API. Where the public URL of a file will serve the processed version for HTML pages, the files accessed through the API are the original uploaded files.
Netlify is based on a concept of atomic deploys. This means you never work on individual files. If you want to change a file, you do a new deploy with a new version of the site. To delete a file, you create a new deploy without the file. The file digest based deployment method means that these operations are fast and low-cost. Atomic deploys guarantees that your site is never in an inconsistent state where some files are being uploaded and where users might get HTML files that are not in sync with the CSS, image files, etc.
#
Get files
GET /api/v1/sites/{site_id}/files
returns a list of all the files in the current deploy.
[
{
"id"
:
"/index.html"
,
"path"
:
"/index.html"
,
"sha"
:
"20828dcdf2cd07e5980fe52759101591bf5014ab"
,
"mime_type"
:
"text/html"
,
"size"
:
27232
}
]
#
Get file
GET /api/v1/sites/{site_id}/files/{file_path}
returns the file.
{
"id"
:
"/index.html"
,
"path"
:
"/index.html"
,
"sha"
:
"20828dcdf2cd07e5980fe52759101591bf5014ab"
,
"mime_type"
:
"text/html"
,
"size"
:
27232
}
You can get the raw contents of the file by using the custom media type
application/vnd.bitballoon.v1.raw
as the
Content-Type
of your HTTP request.
#
Deploys
You can access all deploys for a specific site.
#
Get deploys
GET /api/v1/sites/{site_id}/deploys
returns a list of all deploys for a site.
[
{
"id"
:
"52465f435803544542000001"
,
"premium"
:
false
,
"claimed"
:
true
,
"name"
:
"synergy"
,
"custom_domain"
:
"www.example.com"
,
"notification_email"
:
"me@example.com"
,
"url"
:
"http://www.example.com"
,
"deploy_url"
:
"http://52465f435803544542000001.some-site.netlify.app"
,
"admin_url"
:
"https://api.netlify.com/sites/synergy"
,
"screenshot_url"
:
null
,
"created_at"
:
"2013-09-17T05:13:08Z"
,
"updated_at"
:
"2013-09-17T05:13:19Z"
,
"user_id"
:
"51f60d2d5803545326000005"
,
"state"
:
"old"
}
]
#
Get deploy
GET /api/v1/sites/{site_id}/deploys/{deploy_id}
returns a specific deploy.
{
"id"
:
"52465f435803544542000001"
,
"premium"
:
false
,
"claimed"
:
true
,
"name"
:
"synergy"
,
"custom_domain"
:
"www.example.com"
,
"notification_email"
:
"me@example.com"
,
"url"
:
"http://www.example.com"
,
"deploy_url"
:
"http://52465f435803544542000001.some-site.netlify.app"
,
"admin_url"
:
"https://api.netlify.com/sites/synergy"
,
"screenshot_url"
:
null
,
"created_at"
:
"2013-09-17T05:13:08Z"
,
"updated_at"
:
"2013-09-17T05:13:19Z"
,
"user_id"
:
"51f60d2d5803545326000005"
,
"state"
:
"old"
}
#
Restore deploy (rollback)
POST /api/v1/sites/{site_id}/deploys/{deploy_id}/restore
restores an old deploy and makes it the live version of the site.
{
"id"
:
"52465f435803544542000001"
,
"premium"
:
false
,
"claimed"
:
true
,
"name"
:
"synergy"
,
"custom_domain"
:
"www.example.com"
,
"notification_email"
:
"me@example.com"
,
"url"
:
"http://www.example.com"
,
"deploy_url"
:
"http://52465f435803544542000001.some-site.netlify.app"
,
"admin_url"
:
"https://api.netlify.com/sites/synergy"
,
"screenshot_url"
:
null
,
"created_at"
:
"2013-09-17T05:13:08Z"
,
"updated_at"
:
"2013-09-17T05:13:19Z"
,
"user_id"
:
"51f60d2d5803545326000005"
,
"state"
:
"current"
}
#
Snippets
Snippets are code snippets that are injected into every HTML page of the website, either right before the closing
head
tag or right before the closing
body
tag.
Each snippet can specify code for all pages and code that gets injected into “Thank you” pages shown after a successful form submission.
#
Get snippets
GET /api/v1/sites/{site_id}/snippets
gets a list of snippets specific to a site.
[
{
"id"
:
0
,
"title"
:
"Test"
,
"general"
:
"\u003Cscript\u003Ealert(\"Hello\")\u003C/script\u003E"
,
"general_position"
:
"head"
,
"goal"
:
""
,
"goal_position"
:
"footer"
}
]
The
general
property is the code that will be injected right before either the head or body end tag. The
general_position
can be
head
or
footer
and determines whether to inject the code in the head element or before the closing body tag.
The
goal
property is the code that will be injected into the “Thank you” page after a form submission.
goal_position
determines where to inject this code.
#
Get snippet
GET /api/v1/sites/{site_id}/snippets/{snippet_id}
gets a specific snippet.
{
"id"
:
0
,
"title"
:
"Test"
,
"general"
:
"\u003Cscript\u003Ealert(\"Hello\")\u003C/script\u003E"
,
"general_position"
:
"head"
,
"goal"
:
""
,
"goal_position"
:
"footer"
}
#
Add snippet
POST /api/v1/sites/{site_id}/snippets
adds a new snippet to a site.
#
Update snippet
PUT /api/v1/sites/{site_id}/snippets/{snippet_id}
replaces a snippet.
#
Delete snippet
DELETE /api/v1/sites/{site_id}/snippets/{snippet_id}
deletes a snippet.
#
Forms
You can access all
Netlify Forms
metadata and submissions for a site.
#
Get forms
GET /api/v1/sites/{site_id}/forms
returns a list of all forms for a site, including metadata about each form, but not including form submissions.
[
{
"id"
:
"ac0865cc46440b1e64666f520e8d88d670c8a2f6"
,
"site_id"
:
"0d3a9d2f-ef94-4380-93df-27ee400e2048"
,
"name"
:
"Landing Page"
,
"paths"
:
[
"/index"
]
,
"submission_count"
:
3
,
"fields"
:
[
{
"name"
:
"name"
,
"type"
:
"text"
}
,
{
"name"
:
"email"
,
"type"
:
"email"
}
,
{
"name"
:
"phone"
,
"type"
:
"text"
}
,
{
"name"
:
"company"
,
"type"
:
"text"
}
,
{
"name"
:
"website"
,
"type"
:
"url"
}
,
{
"name"
:
"number_of_employees"
,
"type"
:
"select"
}
]
,
"created_at"
:
"2013-09-18T20:26:19Z"
}
]
#
Get verified submissions
GET /api/v1/sites/{site_id}/submissions
returns a list of verified form submissions across all forms for a specific site.
GET /api/v1/forms/{form_id}/submissions
returns a list of verified form submissions for a specific form.
[
{
"id"
:
"5231110b5803540aeb000019"
,
"number"
:
13
,
"title"
:
null
,
"email"
:
"test@example.com"
,
"name"
:
"Mathias Biilmann"
,
"first_name"
:
"Mathias"
,
"last_name"
:
"Biilmann"
,
"company"
:
"Netlify"
,
"summary"
:
"Hello, World"
,
"body"
:
"Hello, World"
,
"data"
:
{
"email"
:
"test@example.com"
,
"name"
:
"Mathias Biilmann"
,
"ip"
:
"127.0.0.1"
}
,
"created_at"
:
"2013-09-12T00:55:39Z"
,
"site_url"
:
"http://synergy.netlify.app"
}
]
#
Get spam submissions
To get spam submissions, add a
state=spam
query parameter to the URL:
GET /api/v1/sites/{site_id}/submissions?state=spam
returns a list of spam form submissions across all forms for a specific site.
GET /api/v1/forms/{form_id}/submissions?state=spam
returns a list of spam form submissions for a specific form.
#
Change submission state
You can change the state of a submission from spam to verified or vice versa.
PUT /api/v1/submissions/{submission_id}/spam
marks the submission as spam.
PUT /api/v1/submissions/{submission_id}/ham
marks the submission as verified.
#
Delete submissions
DELETE /api/v1/submissions/{submission_id}
removes a form submission.
#
Delete form
DELETE /api/v1/sites/{site_id}/forms/{form_id}
removes a form and any existing submissions to it.
Future submissions to the form will result in a 404 error, and previous submissions will no longer be available.
#
Hooks
Netlify can trigger webhooks, send email notifications, or send Slack messages on certain events.
The
/hooks
endpoint lets you control the hooks for your site.
#
Get hook types
GET /api/v1/hooks/types
returns a list of types of hooks that you can configure on Netlify.
[
{
"name"
:
"url"
,
"fields"
:
[
{
"name"
:
"url"
,
"options"
:
{
"type"
:
"string"
,
"title"
:
"URL to notify"
}
}
]
,
"events"
:
[
"submission_created"
,
"deploy_created"
,
"deploy_failed"
]
}
]
Each type has a series of fields that you need to set to create a new hook, and a list of events that can trigger them.
#
Get hooks for a site
GET /api/v1/hooks?site_id={site_id}
returns a list of a hooks defined for a specific site.
[
{
"id"
:
"5636b7a00d61eec2d6001004"
,
"site_id"
:
"0d3a9d2f-ef94-4380-93df-27ee400e2048"
,
"type"
:
"email"
,
"event"
:
"submission_created"
,
"data"
:
{
"email"
:
"test@example.com"
}
,
"created_at"
:
"2015-10-20T21:51:51Z"
,
"updated_at"
:
"2015-10-20T21:51:51Z"
}
]
#
Create hook
POST /api/v1/hooks
creates a new hook.
An example request body for an email hook for a specific form in your site would be formatted like this:
{
"site_id"
:
"0d3a9d2f-ef94-4380-93df-27ee400e2048"
,
"form_id"
:
"5235a7a00d61eec2d6001302"
,
"type"
:
"email"
,
"event"
:
"submission_created"
,
"data"
:
{
"email"
:
"test@example.com"
}
}
form_id
is optional and links the hook to a specific form within your site. You can also use
form_name
with the value of the
name
attribute of the form of your site as an alternative to
form_id
.
#
Delete hook
DELETE /api/v1/hooks/{hook_id}
removes a hook permanently.
Note, for outgoing webhooks, returning a
410 Gone
status code from the URL endpoint will trigger a deletion of the hook.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- ask-netlify.txt --------
Start of file
URL: https://docs.netlify.com/ask-netlify/
Scraped_At: 2025-06-02T19:56:21.289149

Contact
Forums
Contact support
How can I help you today?
Log in to unlock
If you’re having trouble logging in, need a site or DNS transfer, or are encountering fraud,
contact the support team
instead.
Send
0 / 300
###End of file##

-------- blobs_overview.txt --------
Start of file
URL: https://docs.netlify.com/blobs/overview/
Scraped_At: 2025-06-02T19:56:23.007670

Contact
Forums
Contact support
With Netlify Blobs, you can store and retrieve
blobs
and unstructured data. You can also use this feature as a simple key/value store or basic database.
Netlify Blobs is a highly-available data store optimized for frequent reads and infrequent writes.
For maximum flexibility, it offers a
configurable consistency model
. If multiple write calls to the same key are issued, the last write wins.
We automatically handle provisioning, configuration, and access control for you. This integrated zero-configuration solution helps you focus on building business value in your project rather than toil on setting up and scaling a separate blob storage solution.
#
Overview
Each blob belongs to a single site. A site can have multiple namespaces for blobs. We call these
stores
. This allows you to, for example, have the key
my-key
exist as an object in a store for
file-uploads
and separately as an object in a store for
json-uploads
with different data. Every blob must be associated with a store, even if a site is not using multiple namespaces.
You can perform CRUD operations for Netlify Blobs from the following Netlify features:
Functions
Edge Functions
Build Plugins
- note that though a plugin can read from any stores on the site, a plugin can write to only
deploy-specific stores
Netlify CLI
- visit the
CLI command reference
for details
You can also:
write to deploy-specific stores using
file-based uploads
browse and download blobs in the
Netlify Blobs UI
#
Use cases
Netlify Blobs is a platform primitive that developers and frameworks can use as a building block for many different purposes. Here are a few
examples of powerful patterns
that you can use:
Data store for functions.
With
Background Functions
, you can trigger asynchronous serverless workflows for long-running operations like generating a site map, processing media assets, or sending emails in bulk. You can then use Netlify Blobs to persist the output of those computations.
Processing user uploads.
If your application takes user submissions, like reviews on a product page or image files for a gallery, Netlify Blobs can store that data. When paired with Functions or Edge Functions, you can create an endpoint to receive an upload, validate the contents, and persist the validated data.
For more advanced use cases — such as those that require complex queries, concurrency control, or a relational data model — explore our
integrations with the best-in-class database vendors
.
#
API reference
To use the Netlify Blobs API, first install the
@netlify/blobs
module using the
package manager of your choice
:
npm
install
@netlify/blobs
Then use the below methods in your functions, edge functions, or build plugins.
#
getStore
Opens a site-wide store for reading and writing blobs. Data added to that store will be persisted on new deploys, available on all
deploy contexts
and accessible from from
Functions
,
Edge Functions
and
Build Plugins
.
const
store
=
getStore
(
name
,
{
siteID
,
token
}
)
#
Parameters
name
:
the name of the store; this can be any string that adheres to the
store naming requirements
siteID
(optional)
:
the ID of the Netlify site associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins. You can also set the
siteID
to the ID of another site you own to access its blobs via the
getStore
method.
token
(optional)
:
a
Netlify Personal Access Token
that grants access to Blobs on the given site; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins
Find your Netlify site ID
To find your Netlify site ID, go to
Project configuration
>
General
>
Project information
, and copy the value for
Project ID
(Also called Site ID in the Netlify API.)
#
Return value
An instance of a store on which you can
get
,
set
or
delete
blobs.
#
getDeployStore
Opens a
deploy-specific store
for reading and writing blobs. Data added to that store will be scoped to a specific deploy, available on all
deploy contexts
and accessible from from
Functions
,
Edge Functions
and
Build Plugins
.
const
store
=
getDeployStore
(
name
,
{
deployID
,
region
,
siteID
,
token
}
)
#
Parameters
name
:
the name of the store; this can be any string that adheres to the
store naming requirements
deployID
(optional)
:
the ID of the Netlify deploy associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins
region
(optional)
:
the
region
associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins
siteID
(optional)
:
the ID of the Netlify site associated with the store; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins
token
(optional)
:
a
Netlify Personal Access Token
that grants access to Blobs on the given site; this is set automatically when you use Blobs from Functions, Edge Functions or Build Plugins
#
Return value
An instance of a store on which you can
get
,
set
or
delete
blobs.
#
set
Creates an object with the given key and value. If an entry with the given key already exists, its value is overwritten.
await
store
.
set
(
key
,
value
,
{
metadata
}
)
#
Parameters
key
:
a string representing the object key
value
:
the value as an
ArrayBuffer
,
Blob
, or string
metadata
(optional)
:
a JSON object with arbitrary metadata to attach to the object
#
Return value
A
Promise
that resolves with
undefined
.
#
Example
This example shows how you might use Netlify Blobs to persist user-generated uploads. For a more in-depth explanation, refer to
this guide
.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Accessing the request as `multipart/form-data`.
const
form
=
await
req
.
formData
(
)
;
const
file
=
form
.
get
(
"file"
)
as
File
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
file
,
{
metadata
:
{
country
:
context
.
geo
.
country
.
name
}
}
)
;
return
new
Response
(
"Submission saved"
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Accessing the request as `multipart/form-data`.
const
form
=
await
req
.
formData
(
)
;
const
file
=
form
.
get
(
"file"
)
as
File
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
file
,
{
metadata
:
{
country
:
context
.
geo
.
country
.
name
}
}
)
;
return
new
Response
(
"Submission saved"
)
;
}
;
import
{
readFile
}
from
"node:fs/promises"
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
const
onPostBuild
=
async
(
)
=>
{
// Reading a file from disk at build time.
const
file
=
await
readFile
(
"some-file.txt"
,
"utf8"
)
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
file
,
{
metadata
:
{
country
:
"Spain"
}
}
)
;
}
;
#
setJSON
Convenience method for creating a JSON-serialized object. If an entry with the given key already exists, its value is overwritten.
setJSON
(
key
,
value
,
{
metadata
}
)
#
Parameters
key
:
a string representing the object key
value
:
any value that is
serializable to JSON
metadata
(optional)
:
a JSON object with arbitrary metadata to attach to the object
#
Return value
A
Promise
that resolves with
undefined
.
#
Example
This example shows how you might use Netlify Blobs to persist user-generated data.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Expecting the request body to contain JSON.
const
data
=
await
req
.
json
(
)
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"json-uploads"
)
;
await
uploads
.
setJSON
(
key
,
data
,
{
metadata
:
{
country
:
context
.
geo
.
country
.
name
}
}
)
;
return
new
Response
(
"Submission saved"
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Expecting the request body to contain JSON.
const
data
=
await
req
.
json
(
)
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"json-uploads"
)
;
await
uploads
.
setJSON
(
key
,
data
,
{
metadata
:
{
country
:
context
.
geo
.
country
.
name
}
}
)
;
return
new
Response
(
"Submission saved"
)
;
}
;
import
{
readFile
}
from
"node:fs/promises"
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
const
onPostBuild
=
async
(
)
=>
{
// Reading a file from disk at build time.
const
file
=
await
readFile
(
"some-file.txt"
,
"utf8"
)
;
// Expecting the file to contain JSON.
const
data
=
JSON
.
parse
(
file
)
;
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getStore
(
"json-uploads"
)
;
await
uploads
.
setJSON
(
key
,
data
,
{
metadata
:
{
country
:
"Spain"
}
}
)
;
}
;
#
get
Retrieves an object with the given key.
await
store
.
get
(
key
,
{
consistency
,
type
}
)
#
Parameters
key
:
a string representing the object key
consistency
(optional)
:
a string representing the
consistency model
for the operation
type
(optional)
:
the format in which the object should be returned — the default format is a string but you can specify one of the following values instead:
arrayBuffer
:
returns the entry as an
ArrayBuffer
blob
:
returns the entry as a
Blob
json
:
parses the entry as JSON and returns the resulting object
stream
:
returns the entry as a
ReadableStream
text
:
default, returns the entry as a string of plain text
#
Return value
A
Promise
that resolves with the blob in the format specified by
type
:
ArrayBuffer
,
Blob
,
Object
,
ReadableStream
or a string.
If an object with the given key is not found, a
Promise
that resolves with
null
is returned.
#
Example
This example shows how you might read user-generated data that has been previously uploaded to Netlify Blobs.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
get
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
`
Could not find entry with key
${
key
}
`
,
{
status
:
404
}
)
;
}
return
new
Response
(
entry
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/submission/:key"
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
get
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
`
Could not find entry with key
${
key
}
`
,
{
status
:
404
}
)
;
}
return
new
Response
(
entry
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
get
(
"my-key"
)
;
if
(
entry
===
null
)
{
console
.
log
(
"Could not find entry"
)
;
}
else
{
console
.
log
(
entry
)
;
}
}
;
#
getWithMetadata
Retrieves an object along with its metadata.
await
store
.
getWithMetadata
(
key
,
{
consistency
,
etag
,
type
}
)
#
Parameters
key
:
a string representing the object key
consistency
(optional)
:
a string representing the
consistency model
for the operation
etag
(optional)
:
an opaque quoted string, possibly prefixed by a weakness indicator, representing the
ETag
value
of any version of this blob you may have cached — this allows you to do
conditional requests
type
(optional)
:
the format in which the object should be returned — the default format is a string but you can specify one of the following values instead:
arrayBuffer
:
returns the entry as an
ArrayBuffer
blob
:
returns the entry as a
Blob
json
:
parses the entry as JSON and returns the resulting object
stream
:
returns the entry as a
ReadableStream
text
:
default, returns the entry as a string of plain text
#
Return value
A
Promise
that resolves with an object containing the following properties:
data
:
the blob contents in the format specified by the
type
parameter, or
null
if the
etag
property is the same as the
etag
parameter (meaning the cached object is still fresh)
etag
:
an opaque quoted string, possibly prefixed by a weakness indicator, representing the
ETag
value
of the object
metadata
:
object with arbitrary metadata
If an object with the given key is not found, a
Promise
that resolves with
null
is returned.
#
Example
This example shows how you might read user-generated data and corresponding metadata that have been previously uploaded to Netlify Blobs.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
{
data
,
metadata
}
=
await
uploads
.
getWithMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
`
Could not find entry with key
${
key
}
`
,
{
status
:
404
}
)
;
}
return
new
Response
(
entry
,
{
headers
:
{
"X-Country"
:
metadata
.
country
}
}
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
{
data
,
metadata
}
=
await
uploads
.
getWithMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
`
Could not find entry with key
${
key
}
`
,
{
status
:
404
}
)
;
}
return
new
Response
(
entry
,
{
headers
:
{
"X-Country"
:
metadata
.
country
}
}
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
const
{
data
,
metadata
}
=
await
uploads
.
getWithMetadata
(
"my-key"
)
;
if
(
entry
===
null
)
{
console
.
log
(
"Could not find entry"
)
;
}
else
{
console
.
log
(
"Data:"
,
data
)
;
console
.
log
(
"Country:"
,
metadata
.
country
)
;
}
}
;
Conditional request examples
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Mock implementation of a system for locally persisting blobs and their etags
const
cachedETag
=
getFromMockCache
(
"my-key"
)
;
const
uploads
=
getStore
(
"file-uploads"
)
;
// Get entry from the blob store only if its ETag is different from the one you
// have locally, which means the entry has changed since you last retrieved it.
// Compare the whole value including surrounding quotes and any weakness prefix.
const
{
data
,
etag
}
=
await
uploads
.
getWithMetadata
(
"my-key"
,
{
etag
:
cachedETag
,
}
)
;
if
(
etag
===
cachedETag
)
{
// `data` is `null` because the local blob is fresh
return
new
Response
(
"Still fresh"
)
;
}
// `data` contains the new blob, store it locally alongside the new ETag
writeInMockCache
(
"my-key"
,
data
,
etag
)
;
return
new
Response
(
"Updated"
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Mock implementation of a system for locally persisting blobs and their etags
const
cachedETag
=
getFromMockCache
(
"my-key"
)
;
const
uploads
=
getStore
(
"file-uploads"
)
;
// Get entry from the blob store only if its ETag is different from the one you
// have locally, which means the entry has changed since you last retrieved it.
// Compare the whole value including surrounding quotes and any weakness prefix.
const
{
data
,
etag
}
=
await
uploads
.
getWithMetadata
(
"my-key"
,
{
etag
:
cachedETag
,
}
)
;
if
(
etag
===
cachedETag
)
{
// `data` is `null` because the local blob is fresh
return
new
Response
(
"Still fresh"
)
;
}
// `data` contains the new blob, store it locally alongside the new ETag
writeInMockCache
(
"my-key"
,
data
,
etag
)
;
return
new
Response
(
"Updated"
)
;
}
;
You can use object metadata to create client-side expiration logic. To delete blobs you consider expired, do the following:
set
your objects with metadata
that you can base the expiration logic on, such as a timestamp
getWithMetadata
to check if an object is expired
delete
the expired object
Expiration logic examples
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
uploads
=
getStore
(
"file-uploads"
)
;
const
key
=
"my-key"
;
// Set the entry with an `expiration` metadata property
await
uploads
.
set
(
key
,
await
req
.
text
(
)
,
{
metadata
:
{
expiration
:
new
Date
(
"2024-01-01"
)
.
getTime
(
)
}
}
)
;
// Read the entry and compare the `expiration` metadata
// property against the current timestamp
const
entry
=
await
uploads
.
getWithMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
"Blob does not exist"
)
;
}
const
{
expiration
}
=
entry
.
metadata
;
// If the expiration date is in the future, it means
// the blob is still fresh, so return it
if
(
expiration
&&
expiration
<
Date
.
now
(
)
)
{
return
new
Response
(
entry
.
data
)
;
}
// Delete the expired entry
await
uploads
.
delete
(
key
)
;
return
new
Response
(
"Blob has expired"
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
uploads
=
getStore
(
"file-uploads"
)
;
const
key
=
"my-key"
;
// Set the entry with an `expiration` metadata property
await
uploads
.
set
(
key
,
await
req
.
text
(
)
,
{
metadata
:
{
expiration
:
new
Date
(
"2024-01-01"
)
.
getTime
(
)
}
}
)
;
// Read the entry and compare the `expiration` metadata
// property against the current timestamp
const
entry
=
await
uploads
.
getWithMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
"Blob does not exist"
)
;
}
const
{
expiration
}
=
entry
.
metadata
;
// If the expiration date is in the future, it means
// the blob is still fresh, so return it
if
(
expiration
&&
expiration
<
Date
.
now
(
)
)
{
return
new
Response
(
entry
.
data
)
;
}
// Delete the expired entry
await
uploads
.
delete
(
key
)
;
return
new
Response
(
"Blob has expired"
)
;
}
;
#
getMetadata
Retrieves the metadata for an object, if the object exists.
This method is useful to check if a blob exists without actually retrieving it and having to download a potentially large blob over the network.
await
store
.
getMetadata
(
key
,
{
consistency
,
etag
,
type
}
)
#
Parameters
key
:
a string representing the object key
consistency
(optional)
:
a string representing the
consistency model
for the operation
etag
(optional)
:
an opaque quoted string, possibly prefixed by a weakness indicator, representing the
ETag
value
of any version of this blob you may have cached  — this allows you to do
conditional requests
type
(optional)
:
the format in which the object should be returned — the default format is a string but you can specify one of the following values instead:
arrayBuffer
:
returns the entry as an
ArrayBuffer
blob
:
returns the entry as a
Blob
json
:
parses the entry as JSON and returns the resulting object
stream
:
returns the entry as a
ReadableStream
text
:
default, returns the entry as a string of plain text
#
Return value
A
Promise
that resolves with an object containing the following properties:
metadata
:
object with arbitrary metadata
etag
:
an opaque quoted string, possibly prefixed by a weakness indicator, representing the
ETag
value
of the object
If an object with the given key is not found, a
Promise
that resolves with
null
is returned.
#
Example
This example shows how you might read metadata from user-generated submissions that have been previously uploaded to Netlify Blobs.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extracting key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
getMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
"Blob does not exist"
)
;
}
return
Response
.
json
(
{
etag
:
entry
.
etag
,
metadata
:
entry
.
metadata
}
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/metadata/:key"
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extracting key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
getMetadata
(
key
)
;
if
(
entry
===
null
)
{
return
new
Response
(
"Blob does not exist"
)
;
}
return
Response
.
json
(
{
etag
:
entry
.
etag
,
metadata
:
entry
.
metadata
}
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
const
entry
=
await
uploads
.
getMetadata
(
"my-key"
)
;
console
.
log
(
entry
.
etag
,
entry
.
metadata
)
;
}
;
#
list
Returns a list of blobs in a given store.
await
store
.
list
(
{
directories
,
paginate
,
prefix
}
)
#
Parameters
directories
(optional)
:
a boolean that indicates whether keys with the
/
character should be treated as directories, returning a list of sub-directories at a given level rather than all the keys inside them
paginate
(optional)
:
a boolean that specifies whether you want to
handle pagination manually
— by default, it is handled automatically
prefix
(optional)
:
a string for filtering down the entries; when specified, only the entries whose key starts with that prefix are returned
#
Return value
A
Promise
that resolves with an object containing the following properties:
blobs
:
an array of blobs that match the query parameters, shown as objects with
etag
and
key
properties, which represent an object’s
ETag
value
and key, respectively
directories
:
an array of strings representing any directories matching the query parameters
#
Example
This example shows how you might list all blobs in a given store, logging the key and etag of each entry.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
uploads
=
getStore
(
"file-uploads"
)
;
const
{
blobs
}
=
await
uploads
.
list
(
)
;
// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "W/\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]
console
.
log
(
blobs
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs
`
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
uploads
=
getStore
(
"file-uploads"
)
;
const
{
blobs
}
=
await
uploads
.
list
(
)
;
// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "W/\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]
console
.
log
(
blobs
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
const
{
blobs
}
=
await
uploads
.
list
(
)
;
// [ { etag: "\"etag1\"", key: "9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d" }, { etag: "W/\"etag2\"", key: "1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed" } ]
console
.
log
(
blobs
)
;
}
;
#
Hierarchy
Optionally, you can group blobs together under a common prefix and then browse them hierarchically when listing a store. This is similar to grouping files in a directory. To browse hierarchically, do the following:
Group keys hierarchically with the
/
character in your key names.
List entries hierarchically with the
directories
parameter.
Drill down into a specific directory with the
prefix
parameter.
Hierarchical browsing examples
Take the following set of keys as an example:
cats/shorthair.jpg
cats/longhair.jpg
dogs/beagle.jpg
dogs/corgi.jpg
bird.jpg
#
Pagination
By default,
list
will return all five keys.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
}
=
await
animals
.
list
(
)
;
// [
//   { etag: "\"etag1\"", key: "cats/shorthair.jpg" },
//   { etag: "\"etag2\"", key: "cats/longhair.jpg" },
//   { etag: "\"etag3\"", key: "dogs/beagle.jpg" },
//   { etag: "\"etag4\"", key: "dogs/corgi.jpg" },
//   { etag: "\"etag5\"", key: "bird.jpg" },
// ]
console
.
log
(
blobs
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs
`
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
}
=
await
animals
.
list
(
)
;
// [
//   { etag: "\"etag1\"", key: "cats/shorthair.jpg" },
//   { etag: "\"etag2\"", key: "cats/longhair.jpg" },
//   { etag: "\"etag3\"", key: "dogs/beagle.jpg" },
//   { etag: "\"etag4\"", key: "dogs/corgi.jpg" },
//   { etag: "\"etag5\"", key: "bird.jpg" },
// ]
console
.
log
(
blobs
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
animals
=
getDeployStore
(
"animals"
)
;
const
{
blobs
}
=
await
animals
.
list
(
)
;
// [
//   { etag: "\"etag1\"", key: "cats/shorthair.jpg" },
//   { etag: "\"etag2\"", key: "cats/longhair.jpg" },
//   { etag: "\"etag3\"", key: "dogs/beagle.jpg" },
//   { etag: "\"etag4\"", key: "dogs/corgi.jpg" },
//   { etag: "\"etag5\"", key: "bird.jpg" },
// ]
console
.
log
(
blobs
)
;
}
;
To list entries hierarchically, set the
directories
parameter to
true
.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
}
)
;
// [ { etag: "\"etag5\"", key: "bird.jpg" } ]
console
.
log
(
blobs
)
;
// [ "cats", "dogs" ]
console
.
log
(
directories
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs and
${
directories
.
length
}
directories
`
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
}
)
;
// [ { etag: "\"etag5\"", key: "bird.jpg" } ]
console
.
log
(
blobs
)
;
// [ "cats", "dogs" ]
console
.
log
(
directories
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs and
${
directories
.
length
}
directories
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
animals
=
getDeployStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
}
)
;
// [ { etag: "\"etag5\"", key: "bird.jpg" } ]
console
.
log
(
blobs
)
;
// [ "cats", "dogs" ]
console
.
log
(
directories
)
;
}
;
To drill down into a directory and get a list of its items, set the
prefix
parameter to the directory name.
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
,
prefix
:
"cats/"
,
}
)
;
// [ { etag: "\"etag1\"", key: "cats/shorthair.jpg" }, { etag: "\"etag2\"", key: "cats/longhair.jpg" } ]
console
.
log
(
blobs
)
;
// [ ]
console
.
log
(
directories
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs and
${
directories
.
length
}
directories
`
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
animals
=
getStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
,
prefix
:
"cats/"
,
}
)
;
// [ { etag: "\"etag1\"", key: "cats/shorthair.jpg" }, { etag: "\"etag2\"", key: "cats/longhair.jpg" } ]
console
.
log
(
blobs
)
;
// [ ]
console
.
log
(
directories
)
;
return
new
Response
(
`
Found
${
blobs
.
length
}
blobs and
${
directories
.
length
}
directories
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
animals
=
getDeployStore
(
"animals"
)
;
const
{
blobs
,
directories
}
=
await
animals
.
list
(
{
directories
:
true
,
prefix
:
"cats/"
,
}
)
;
// [ { etag: "\"etag1\"", key: "cats/shorthair.jpg" }, { etag: "\"etag2\"", key: "cats/longhair.jpg" } ]
console
.
log
(
blobs
)
;
// [ ]
console
.
log
(
directories
)
;
}
;
Note that the prefix includes a trailing slash. This ensures that only entries under the
cats
directory are returned. Without a trailing slash, other keys like
catsuit
would also be returned.
For performance reasons, the server groups results into pages of up to 1,000 entries. By default, the
list
method automatically retrieves all pages, meaning you’ll always get the full list of results.
To handle pagination manually, set the
paginate
parameter to
true
. This makes
list
return an
AsyncIterator
, which lets you take full control over the pagination process. This means you can fetch only the data you need when you need it.
Manual blob pagination examples
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
store
=
getStore
(
"animals"
)
;
let
blobCount
=
0
;
for
await
(
const
entry
of
store
.
list
(
{
paginate
:
true
}
)
)
{
blobCount
+=
entry
.
blobs
.
length
;
console
.
log
(
entry
.
blobs
)
;
}
return
new
Response
(
`
Found
${
blobCount
}
blobs
`
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
store
=
getStore
(
"animals"
)
;
let
blobCount
=
0
;
for
await
(
const
entry
of
store
.
list
(
{
paginate
:
true
}
)
)
{
blobCount
+=
entry
.
blobs
.
length
;
console
.
log
(
entry
.
blobs
)
;
}
return
new
Response
(
`
Found
${
blobCount
}
blobs
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
store
=
getDeployStore
(
"animals"
)
;
let
blobCount
=
0
;
for
await
(
const
entry
of
store
.
list
(
{
paginate
:
true
}
)
)
{
blobCount
+=
entry
.
blobs
.
length
;
console
.
log
(
entry
.
blobs
)
;
}
console
.
log
(
`
Found
${
blobCount
}
blobs
`
)
;
}
;
#
listStores
Returns a list of stores for a site. Does not include
deploy-specific stores
.
await
listStores
(
{
paginate
}
)
#
Parameters
paginate
(optional)
:
a boolean that specifies whether you want to
handle pagination manually
— by default, it is handled automatically
#
Return value
A
Promise
that resolves with an object containing the following properties:
stores
:
an array of strings representing any stores matching the query parameters
#
Example
This example shows how you might list all stores for a given site.
Loading error: Refresh the page to access this code sample
import
{
listStores
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
{
stores
}
=
await
listStores
(
)
;
// [ "file-uploads", "json-uploads" ]
console
.
log
(
stores
)
;
return
new
Response
(
`
Found
${
stores
.
length
}
stores
`
)
;
}
;
import
{
listStores
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
{
stores
}
=
await
listStores
(
)
;
// [ "file-uploads", "json-uploads" ]
console
.
log
(
stores
)
;
return
new
Response
(
`
Found
${
stores
.
length
}
stores
`
)
;
}
;
import
{
listStores
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
{
stores
}
=
await
listStores
(
)
;
// [ "file-uploads", "json-uploads" ]
console
.
log
(
stores
)
;
}
;
#
Pagination
For performance reasons, the server groups results into pages of up to 1,000 stores. By default, the
listStores
method automatically retrieves all pages, meaning you’ll always get the full list of results.
To handle pagination manually, set the
paginate
parameter to
true
. This makes
listStores
return an
AsyncIterator
, which lets you take full control over the pagination process. This means you can fetch only the data you need when you need it.
Manual store pagination examples
Loading error: Refresh the page to access this code sample
import
{
listStores
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
let
storeCount
=
0
;
for
await
(
const
entry
of
listStores
(
{
paginate
:
true
}
)
)
{
storeCount
+=
entry
.
stores
.
length
;
console
.
log
(
entry
.
stores
)
;
}
return
new
Response
(
`
Found
${
storeCount
}
stores
`
)
;
}
;
import
{
listStores
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
let
storeCount
=
0
;
for
await
(
const
entry
of
listStores
(
{
paginate
:
true
}
)
)
{
storeCount
+=
entry
.
stores
.
length
;
console
.
log
(
entry
.
stores
)
;
}
return
new
Response
(
`
Found
${
storeCount
}
stores
`
)
;
}
;
import
{
listStores
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
{
stores
}
=
await
listStores
(
{
paginate
:
true
,
}
)
;
let
storeCount
=
0
;
for
await
(
const
entry
of
stores
)
{
storeCount
+=
entry
.
stores
.
length
;
console
.
log
(
entry
.
stores
)
;
}
console
.
log
(
`
Found
${
storeCount
}
stores
`
)
;
}
;
#
delete
Deletes an object with the given key, if one exists.
await
store
.
delete
(
key
)
#
Parameters
key
:
a string representing the object key
#
Return value
A
Promise
that resolves with
undefined
.
#
Example
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
await
uploads
.
delete
(
key
)
;
return
new
Response
(
"Blob has been deleted"
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/delete/:key"
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Extract key from URL.
const
{
key
}
=
context
.
params
;
const
uploads
=
getStore
(
"file-uploads"
)
;
await
uploads
.
delete
(
key
)
;
return
new
Response
(
"Blob has been deleted"
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
await
uploads
.
delete
(
"my-key"
)
;
console
.
log
(
"Blob has been deleted"
)
;
}
;
#
File-based uploads
With file-based uploads, you can write blobs to
deploy-specific stores
after the build completes and before the deploy starts. This can be useful for authors of frameworks and other tools integrating with Netlify as it does not require a build plugin.
To make file-based uploads, place blob files in
.netlify/blobs/deploy
in your site’s
base directory
. Netlify uploads these files to blob storage maintaining their directory structure. Here is an example file tree:
.netlify/
├─ blobs/
|  ├─ deploy/
│  |  ├─ dogs/
│  │  |  └─ good-boy.jpg
│  |  ├─ cat.jpg
│  |  └─ mouse.jpg
This uploads the following blobs:
dogs/good-boy.jpg
cat.jpg
mouse.jpg
To attach metadata to a blob, include a JSON file that prefixes the corresponding blob filename with
$
and has a
.json
extension. For example:
.netlify/
├─ blobs/
|  ├─ deploy/
│  |  ├─ dogs/
│  │  |  ├─ good-boy.jpg
│  │  |  └─ $good-boy.jpg.json
│  |  ├─ cat.jpg
│  |  ├─ mouse.jpg
│  |  └─ $mouse.jpg.json
This uploads the following blobs:
dogs/good-boy.jpg
with the metadata from
dogs/$good-boy.jpg.json
cat.jpg
without metadata
mouse.jpg
with the metadata from
$mouse.jpg.json
Metadata files must contain valid JSON or the deploy will fail. Here’s an example of valid JSON metadata:
{
"name"
:
"Jerry"
}
#
Consistency
By default, the Netlify Blobs API uses an
eventual consistency
model, where data is stored in a single region and cached at the edge for fast access across the globe. When a blob is added, it becomes globally available immediately. Updates and deletions are guaranteed to be propagated to all edge locations within 60 seconds.
You can configure this behavior and opt-in to strong consistency with the
Netlify Blobs API
, either for an entire store or for individual read operations.
Netlify CLI
always uses strong consistency.
Choosing the right consistency model depends on your use case and each option comes with tradeoffs:
if it’s important for your application that updates and deletions become immediately available to all readers, you should consider using
strong
consistency, which comes with the cost of slower reads
if that is not a hard requirement and you’re optimizing for fast reads, you should consider using
eventual
consistency
Loading error: Refresh the page to access this code sample
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
store
=
getStore
(
{
name
:
"animals"
,
consistency
:
"strong"
}
)
;
await
store
.
set
(
"dog"
,
"🐶"
)
;
// This is a strongly-consistent read.
const
dog
=
await
store
.
get
(
"dog"
)
;
return
new
Response
(
dog
)
;
}
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
store
=
getStore
(
"animals"
)
;
await
store
.
set
(
"dog"
,
"🐶"
)
;
// This is an eventually-consistent read.
const
dog1
=
await
store
.
get
(
"dog"
)
;
// This is a strongly-consistent read.
const
dog2
=
await
store
.
get
(
"dog"
,
{
consistency
:
"strong"
}
)
;
return
new
Response
(
dog1
+
dog2
)
;
}
;
#
Netlify Blobs UI
In addition to using the Netlify Blobs API to
list
and
get
blobs, you can use the Netlify UI to browse and download blobs.
To explore and retrieve your site’s blobs:
In the Netlify UI, go to the
Blobs
page for your project.
If your site has more than one store, select the store of interest.
Then, drill into directories to explore the blobs in the store or
Download
an individual blob to examine it.
#
Sensitive data
You can store sensitive data with Netlify Blobs. To keep your data secure, we encrypt your blobs at rest and in transit.
Your blobs can only be accessed through your own site. You are responsible for making sure the code you use to access your blobs doesn’t allow data to leak. We recommend that you consider the following best practices:
Do not allow incoming requests for arbitrary keys if you have sensitive data. Treat user input as unsafe and scope your keys with something that callers cannot tamper with.
Review the code of any
build plugin you install from the npm public registry
to make sure it doesn’t have malicious blob interactions.
Visit our
security checklist
for general security measures we recommend you consider for your site.
#
Deploy-specific stores
The namespaces you make with
getStore
are shared across all deploys of your site. This is required when using Netlify CLI and desirable for most use cases with functions and edge functions because it means that a new production deploy can read previously written data without you having to replicate blobs for each new production deploy. This also means you can test your Deploy Previews with production data. This does, however, mean that you should be careful to avoid scenarios such as a branch deploy deleting blobs that your published deploy depends on.
As mentioned above, build plugins and file-based uploads must write to deploy-specific stores. This requirement makes it so that a deploy that fails cannot overwrite production data.
To make a deploy-specific namespace with the Netlify Blobs API, use the
getDeployStore
method.
Loading error: Refresh the page to access this code sample
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
await
req
.
text
(
)
)
;
return
new
Response
(
`
Entry added with key
${
key
}
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
await
req
.
text
(
)
)
;
return
new
Response
(
`
Entry added with key
${
key
}
`
)
;
}
;
import
{
readFile
}
from
"node:fs/promises"
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
const
onPostBuild
=
async
(
)
=>
{
// Reading a file from disk at build time.
const
file
=
await
readFile
(
"some-file.txt"
,
"utf8"
)
;
const
uploads
=
getDeployStore
(
"file-uploads"
)
;
await
uploads
.
set
(
key
,
file
)
;
console
.
log
(
`
Entry added with key
${
key
}
`
)
;
}
;
In general, blobs in deploy-specific stores are managed by Netlify like other atomic deploy assets. This means they’re kept in sync with their relative deploys if you do a
rollback
and that they’re cleaned up with
automatic deploy deletion
.
However,
downloading a deploy
does not download deploy-specific blobs, and
locking a published deploy
does not prevent you from writing to associated deploy-specific stores.
#
Regions
By default, deploy-specific stores are located in the same region that your functions have been configured to run in. For a list of available regions, check out  these
region docs
.
You can also manually specify which region to connect to, regardless of your function’s region, by passing the region as an option when using the
getDeployStore
method.
Loading error: Refresh the page to access this code sample
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getDeployStore
(
{
name
:
"file-uploads"
,
region
:
"ap-southeast-2"
}
)
;
await
uploads
.
set
(
key
,
await
req
.
text
(
)
)
;
return
new
Response
(
`
Entry added with key
${
key
}
`
)
;
}
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/edge-functions"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// Generating a unique key for the entry.
const
key
=
uuid
(
)
;
const
uploads
=
getDeployStore
(
{
name
:
"file-uploads"
,
region
:
"ap-southeast-2"
}
)
;
await
uploads
.
set
(
key
,
await
req
.
text
(
)
)
;
return
new
Response
(
`
Entry added with key
${
key
}
`
)
;
}
;
import
{
readFile
}
from
"node:fs/promises"
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
{
v4
as
uuid
}
from
"uuid"
;
export
const
onPostBuild
=
async
(
)
=>
{
// Reading a file from disk at build time.
const
file
=
await
readFile
(
"some-file.txt"
,
"utf8"
)
;
const
uploads
=
getDeployStore
(
{
name
:
"file-uploads"
,
region
:
"ap-southeast-2"
}
)
;
await
uploads
.
set
(
key
,
file
)
;
console
.
log
(
`
Entry added with key
${
key
}
`
)
;
}
;
#
Requirements and limitations
Keep the following requirements in mind while working with Netlify Blobs:
Netlify Blobs uses the
web platform
fetch()
to make HTTP calls, so Fetch API support is required. This is included with Node.js 18. If for some reason you can’t use Node.js 18, you can provide your own Fetch API support by supplying a
fetch
property to the
getStore
or
getDeployStore
method.
File-based uploads require
continuous deployment
or
CLI deploys
.
Custom fetch examples
Loading error: Refresh the page to access this code sample
import
{
fetch
}
from
"whatwg-fetch"
;
import
{
getStore
}
from
"@netlify/blobs"
;
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
uploads
=
getStore
(
{
fetch
,
name
:
"file-uploads"
}
)
;
const
entry
=
await
uploads
.
get
(
"my-key"
)
;
return
new
Response
(
entry
)
;
}
;
import
{
fetch
}
from
"whatwg-fetch"
;
import
{
getDeployStore
}
from
"@netlify/blobs"
;
export
const
onPostBuild
=
async
(
)
=>
{
const
uploads
=
getDeployStore
(
{
name
:
"file-uploads"
,
fetch
}
)
;
const
entry
=
await
uploads
.
get
(
"my-key"
)
;
console
.
log
(
entry
)
;
}
;
Keep the following rules in mind when creating namespaces and blobs:
Store names cannot include the
/
character.
Store names cannot include the
:
character.
Store names cannot exceed 64 bytes.
Empty keys are not supported.
Object keys can include any Unicode characters.
Object keys cannot start with the
/
character.
Object keys cannot exceed 600 bytes.
An individual object’s total size cannot exceed 5 GB.
An individual object’s metadata size cannot exceed 2 KB.
Most characters use 1 byte
Most Unicode characters with UTF-8 encoding take 1 byte. So, for convenience, you can think of the above size limits as roughly a 64-character limit for store names and a 600-character limit for object keys. But, be aware that some characters take more than one byte. For example,
à
takes 2 bytes.
Keep the following limitations in mind when working with Netlify Blobs:
Functions written in Go cannot access Netlify Blobs.
Local development with Netlify Dev uses a sandboxed local store that does not support
file-based uploads
. You cannot read production data during local development.
Deploy deletion
deletes deploy-specific stores only. For other stores, you can create
custom expiration logic
or
delete objects manually
as needed.
Netlify Blobs is not currently supported as part of our HIPAA-compliant hosting offering. For more information, visit our
Trust Center
and download our reference architecture for HIPAA-compliant composable sites on Netlify.
#
Troubleshooting tips
Last write wins.
If two overlapping calls try to write the same object, the last write wins. Netlify Blobs does not include a concurrency control mechanism. To manage the potential for race conditions, you can build an object-locking mechanism into your application.
Store access depends on
@netlify/blobs
module version.
If you wrote to site-wide stores with
@netlify/blobs
version 6.5.0 or earlier, and you then upgrade the module to a more recent version, you will no longer be able to access data in those stores. This is due to an internal change to namespacing logic. You can migrate affected stores by running the following command in the project directory using the latest version of the
Netlify CLI
.
netlify recipes blobs-migrate YOUR_STORE_NAME
This makes the migrated store accessible with
@netlify/blobs
module version 7.0.0 and later.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- build-plugins.txt --------
Start of file
URL: https://docs.netlify.com/build-plugins/
Scraped_At: 2025-06-02T19:56:24.192645

Contact
Forums
Contact support
Netlify Build Plugins extend the functionality of the Netlify Build process. You can
install plugins
made by others, or
write your own
. You can
save them locally
in your repository, or
share them with others
.
Build Plugins expand what your Netlify builds are capable of. For example, you can use plugins to:
speed up builds by optimizing and debugging your build cache
import and convert data from external sources
check for broken links in a site after building
analyze and optimize site asset handling for better runtime performance
generate content like sitemaps, RSS feeds, and search indexes
#
Install a plugin
To get a sampling of what plugins can do, navigate to
Project configuration
>
Build & deploy
>
Build plugins
for your site. You’ll find different types of plugins, including plugins from our partners and plugins from the community. Plugins can be
installed directly from the Netlify UI
. They can also be
installed using the Netlify configuration file
, which allows more configuration options. Netlify
automatically installs
plugins or runtimes recommended for certain frontend frameworks when you link a repository for a new project.
Use a compatible Node.js version
For optimum compatibility while developing or running plugins, we recommend using the
default version
of Node.js installed by Netlify. However, you can also
specify a different version
for your project’s setup, if needed.
#
UI installation
In the Netlify UI, navigate to
Project configuration
>
Build & deploy
>
Build plugins
for your project.
Search or browse for the plugin you want.
Select
Enable
.
Follow the installation guidance in the Netlify UI to install the plugin on a site. You may be prompted to add
build environment variables
required by the plugin.
To use your new plugin, visit the
Deploys
tab for your site and select
Trigger deploy
.
Consider the context
UI-installed plugins run in all
deploy contexts
. To limit the context for the plugin, consider using
file-based installation
instead.
#
Required environment variables
Though many plugins listed in the Netlify UI require no configuration for default operation, some may require you to set one or more
build environment variables
for your site during or after installation. Refer to the plugin’s documentation, linked from
Options
menu in the plugin’s listing.
#
File-based installation
File-based plugin installation allows advanced plugin configuration.
You can use file-based installation for either of the following:
installing
local plugins
that you write and store in your repository
accessing a wide selection of plugins published by the community on
npm
In both cases, you
configure settings
in
netlify.toml
. For a plugin published to npm, you also
add it as a dependency
. Then you can
test or run
the plugin as part of a build.
#
Configure settings
To run a plugin during your build, add it to a
Netlify configuration file
stored in your site’s
base directory
. A plugin configured globally with
[[plugins]]
runs in all
deploy contexts
, but you can also
configure a plugin by deploy context
.
Here’s a sample configuration with two plugins installed in all deploy contexts.
# Configuration for a plugin published to npm
[
[
plugins
]
]
package
=
"netlify-plugin-lighthouse"
[
plugins.inputs
]
output_path
=
"reports/lighthouse.html"
# Configuration for a local plugin
[
[
plugins
]
]
package
=
"/plugins/netlify-plugin-hello-world"
Each
[[plugins]]
entry accepts two keys:
package
(required)
:
for a plugin installed from npm, the npm package name of the plugin.
for a
local plugin
, the absolute path to a directory containing the plugin’s
index.js
and
manifest.yml
files. The
package
value for a local plugin must start with
.
or
/
.
inputs
:
custom settings that the plugin author may specify as required or available for configuring the plugin. To specify
inputs
per deploy context, refer to
configure by deploy context
.
For npm-published plugins, you can find these details in each plugin’s package documentation on the
npm Public Registry
.
Sometimes order matters
Different plugins run during different stages of your build. When multiple plugins are set to run in the same stage, they will run in the order they are listed in the Netlify configuration file. An npm-published plugin’s README should indicate if order is important to that plugin’s functionality.
#
Configure by deploy context
Using specific settings in your Netlify configuration file, you can limit a build plugin to run in a certain
deploy context
only, or you can configure a plugin’s
inputs
settings differently per context.
Here’s an example configuration that runs the Sitemap plugin in the context of production deploys only.
# Use double brackets since `plugins` is an array of tables.
[
[
context.production.plugins
]
]
package
=
"@netlify/plugin-sitemap"
And here’s an example configuration that runs the Cypress plugin differently based on deploy contexts.
# Use Cypress plugin for this site.
# This section, by itself, configures the plugin
# for all deploy contexts (production, branch deploys, Deploy Previews).
[
[
plugins
]
]
package
=
"netlify-plugin-cypress"
[
plugins.inputs
]
record
=
true
# Don’t record Cypress tests in Deploy Previews.
# Since this entry is more specific, it overrides the entry above.
# `context.deploy-preview.plugins` and `package` must be included.
[
[
context.deploy-preview.plugins
]
]
package
=
"netlify-plugin-cypress"
# Use single brackets since `inputs` is an object property
[
context.deploy-preview.plugins.inputs
]
record
=
false
This configuration records test results and artifacts on the Cypress Dashboard for production and branch deploys only, not Deploy Previews.
UI-installed plugins run on all contexts
To limit a plugin to certain deploy contexts, ensure that you’ve configured the plugin for your site using file-based installation only and not UI installation.
#
Next steps
If you’re installing a local plugin, you can
run and test it
after configuration. Otherwise, you’ll
add a dependency
to
package.json
.
#
Add dependency
For a plugin from npm, there’s an additional step beyond editing the Netlify configuration file. You must use
npm
,
yarn
, or another Node.js package manager to add the plugin to
devDependencies
in your site’s
package.json
.
Evaluate the plugin code
Plugins available on npm but not yet listed in the Netlify UI have not been reviewed or approved by Netlify staff. We strongly recommend you review the plugin code and author for security concerns before installing.
From your project’s base directory, use a command like this to add the dependency:
Loading error: Refresh the page to access this code sample
# Replace `BUILD_PLUGIN_NAME` with a real plugin name,
# like `netlify-plugin-lighthouse`
npm
install
-D
BUILD_PLUGIN_NAME
# Replace `BUILD_PLUGIN_NAME` with a real plugin name,
# like `netlify-plugin-lighthouse`
yarn
add
-D
BUILD_PLUGIN_NAME
#
Run and test
When you save your changes to your repository and push them to your Git provider, the build that’s triggered on Netlify will run with plugins installed for that deploy context. If you would like to test a plugin before running it in a production build, you can use a
branch deploy or Deploy Preview
, or you can
run the build locally with Netlify CLI
.
#
Automatic installation
When you link a repository for a new site, Netlify runs a
framework detection utility
to determine whether your site uses a particular frontend framework. Certain frameworks have recommended Build Plugins or runtimes. These help extend the functionality of the Netlify Build process to support key framework-specific features. Recommended plugins and runtimes may have site conditions requirements, such as a minimum Node.js version.
If your new site uses a framework with recommended plugins or runtimes, Netlify checks whether these are already
installed in a Netlify configuration file
. If not, Netlify automatically installs them. These automatically installed plugins run in all deploy contexts.
For an existing site that’s already linked to Netlify, you can choose to install framework-specific recommended plugins yourself.
#
Manage plugin versions
Netlify encourages plugin authors to regularly update functionality and release new versions using
semantic versioning
. Minor plugin version updates introduce only backward compatible new features, while major plugin version updates can introduce breaking changes. Refer to the plugin’s changelog, linked from the
Options
menu for the plugin listing in the Netlify UI, for version details.
The steps for managing plugin versions for your site depend on the plugin installation method.
For plugins
installed in the UI
or
installed automatically
, Netlify updates your site for minor plugin version releases automatically. To manage major plugin updates for a site, take the following steps:
Navigate to
Project configuration
>
Build & deploy
>
Build plugins
for your project
Search or browse to find the plugin you want to manage.
Select
Options
>
Change version
.
Select the desired major version.
Select
Change version
to save.
Subsequent builds will use the plugin version that you’ve chosen and confirmed.
For plugins
installed through file-based installation
, you can
manage versions
in your site’s
package.json
file under
devDependencies
.
#
Remove a plugin
The steps for removing a plugin depend on how it was installed or whether it is an Essential Gatsby or Next.js Runtime plugin.
For plugins
installed in the UI
or
installed automatically
:
For your selected project, go to
Project configuration
>
Build & deploy
>
Build plugins
.
Find the plugin you want to remove.
In the plugin’s card select
Disable
.
Subsequent builds will not use the uninstalled plugin and environment variables entered for this integration
will not be deleted
.
For plugins
installed through file-based installation
:
Open your site’s
netlify.toml
.
Delete or comment out the plugin’s configuration fields.
When you push your committed changes, the resulting build will run without the plugin. If you’re removing an npm-published plugin and want to avoid installing code you won’t use, you can
uninstall the plugin package using npm
.
Plugin not uninstalling correctly? Check for conflicting configurations
It’s possible to configure a plugin both in the Netlify UI and your site’s
netlify.toml
— though the configuration file takes precedence. If you follow the above steps to remove a plugin from
netlify.toml
and the plugin is still installed, make sure it’s not also configured in the Netlify UI, and vice versa. Removing the plugin from one does not automatically remove it from the other.
For the
Essential Gatsby
and
Next.js Runtime v4
plugins:
For your selected site, go to
Project configuration
>
Build & deploy
.
In
Build settings
, find your plugin in the
Runtime
field and select
Remove
.
#
Create a plugin
Once you’ve had a chance to try out plugins, you may want to make one of your own. To learn how, visit the
create plugins doc
.
A new way to build deep integrations and extensions
Visit the
Netlify SDK docs
to learn about new tools and options for extending and integrating with Netlify. With the SDK, you can make an extension that interacts with more parts of the Netlify platform than a build plugin can. This new toolset also provides a streamlined experience for both developers and users.
#
Get help
Netlify Build Plugins are created by our partners and developers at Netlify and in the community. If you need help with a plugin, contact the plugin author by submitting an issue on the plugin repository. For plugins in the Netlify UI, you can find a link to the plugin issues under the
Options
menu for the plugin listing. If a plugin author doesn’t respond to an issue within a week, you can
request deactivation
of the plugin from the Netlify UI.
For more general questions, or to discuss Build Plugins with other members of the community, visit the
Netlify Support Forums
.
#
More Build Plugins resources
Create Build Plugins
using
build events
Share Build Plugins
Use the Netlify Blobs API in a build plugin
Last updated: May 13, 2025
Create Build Plugins
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- build-plugins_create-plugins.txt --------
Start of file
URL: https://docs.netlify.com/build-plugins/create-plugins/
Scraped_At: 2025-06-02T19:56:25.192531

Contact
Forums
Contact support
In addition to
installing plugins
written by others, you can create your own. To learn how, check out the detailed reference information below and our
Build Plugin template
.
A new way to build deep integrations and extensions
Visit the
Netlify SDK docs
to learn about new tools and options for extending and integrating with Netlify. With the SDK, you can make an extension that interacts with more parts of the Netlify platform than a build plugin can. This new toolset also provides a streamlined experience for both developers and users.
While you can also create build plugins with TypeScript, this document currently demonstrates how to create build plugins with JavaScript.
#
ES modules
If you plan to use JavaScript, we recommend building new plugins with
ES modules
(ESM) but the examples below also include CommonJS (CJS) syntax for older plugins.
To use ESM, Node.js requires
"type": "module"
in your plugin’s
package.json
file.
#
Plug into events
Build Plugins run JavaScript or TypeScript code in response to different events happening during the build-deploy lifecycle.
For example, the
onPreBuild
event handler runs before your build command. The
onPostBuild
event handler runs
after your site build has completed. The following event handlers are currently available:
onPreBuild
:
runs before the build command is executed.
onBuild
:
runs directly after the build command is executed and before Functions bundling.
onPostBuild
:
runs after the build command completes; after
onBuild
tasks and Functions bundling are executed; and before the deploy stage. This is when file-based uploads for Netlify Blobs occur. Can be used to prevent a build from being deployed.
onError
:
runs when an error occurs in the build or deploy stage, failing the build. Can’t be used to prevent a build from being deployed.
onSuccess
:
runs when the deploy succeeds. Can’t be used to prevent a build from being deployed.
onEnd
:
runs after completion of the deploy stage, regardless of build error or success; is useful for resources cleanup. Can’t be used to prevent a build from being deployed.
There are also event handlers that are available when running
netlify dev
:
onPreDev
:
runs before
onDev
.
onDev
:
runs directly before the dev command.
#
Anatomy of a plugin
A plugin consists of two files:
A
manifest.yml
file in the package root with the plugin’s name at minimum:
# manifest.yml
name
:
netlify
-
plugin
-
hello
-
world
A JavaScript or TypeScript object that hooks onto a build event. For example, in JavaScript:
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
)
{
console
.
log
(
"Hello world from onPreBuild event!"
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
)
=>
{
console
.
log
(
"Hello world from onPreBuild event!"
)
;
}
,
}
The plugin defined above will output
Hello world from onPreBuild event!
right before the site’s build command is run.
The
index.js
file runs in a regular Node.js environment and can use any
Node.js core methods
and
modules
.
Environment variables, redirects, headers, and build configuration can be accessed and modified with
netlifyConfig
.
Store both files together in a single folder. You can store this folder with your site code to run as a
local plugin
, or you can
publish the plugin
to npm.
Use a compatible Node.js version
For optimum compatibility while developing or running plugins, we recommend using the
default version
of Node.js installed by Netlify. However, you can also
specify a different version
for your project’s setup, if needed.
#
Local plugins
You can run your own custom plugins from within your site repository without publishing to npm. To do this, save your plugin
index.js
and
manifest.yml
files into a folder in the repository. Then, using the
file-based installation
method, specify the absolute path to your plugin folder in the
package
field.
The following example installs a local plugin stored in
/plugins/netlify-plugin-hello-world
:
# netlify.toml
[
[
plugins
]
]
package
=
"/plugins/netlify-plugin-hello-world"
Take care with formatting
Each plugin you add to the
netlify.toml
file must have its own
[[plugins]]
line. For a local plugin, the
package
value must start with
.
or
/
.
With a local plugin declared, you can verify it’s loading correctly by using the
Netlify CLI
to
run the build locally
.
#
Plugin values
When a plugin runs, it can receive certain data:
constants
: values generated by the plugin event
inputs
: values configured by the plugin user
netlifyConfig
: the site’s Netlify configuration
packageJson
: the contents of the site’s
package.json
file
environment variables
: values available in the Netlify build environment
#
constants
Each event handler includes a
constants
key.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
constants
}
)
{
console
.
log
(
constants
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
{
constants
}
)
=>
{
console
.
log
(
constants
)
;
}
,
}
The
constants
key contains the following values:
CONFIG_PATH
:
path to the Netlify configuration file.
undefined
if none was used.
PUBLISH_DIR
:
directory that contains the deploy-ready HTML files and assets generated by the build. Its value is
always defined, but the target might not have been created yet.
FUNCTIONS_SRC
:
directory where function source code lives.
undefined
if no
netlify/functions
directory exists in the base directory and if not specified by the user.
FUNCTIONS_DIST
:
directory where built serverless functions are placed before deployment. Its value is always
defined, but the target might not have been created yet.
IS_LOCAL
:
boolean indicating whether the build was
run locally
or on Netlify.
NETLIFY_BUILD_VERSION
:
version of Netlify Build as a
major.minor.patch
string.
SITE_ID
:
Netlify site ID.
Along with these constants, plugins can also access any of the
environment variables
that are available in the build environment.
#
inputs
If your plugin requires additional values from the user, you can specify these requirements in an
inputs
array in the plugin’s
manifest.yml
file
:
# manifest.yml
name
:
netlify
-
plugin
-
lighthouse
inputs
:
-
name
:
output_path
description
:
Path to save the generated HTML Lighthouse report
-
name
:
fail_deploy_on_score_thresholds
description
:
Fail deploy if minimum threshold scores are not met
-
name
:
thresholds
description
:
Key value mapping of thresholds that will fail the build when not passed
When you or a user install the plugin, the input names are used as keys with user-supplied values in the site
netlify.toml
file:
# netlify.toml
[
[
plugins
]
]
package
=
"./plugins/netlify-plugin-lighthouse"
[
plugins.inputs
]
output_path
=
"reports/lighthouse.html"
fail_deploy_on_score_thresholds
=
"true"
[
plugins.inputs.thresholds
]
performance
=
0.9
accessibility
=
0.9
best-practices
=
0.9
seo
=
0.9
pwa
=
0.9
These
inputs
values are passed into the plugin when the event handlers are being executed.
To access them in your plugin code you can use the following pattern:
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
inputs
}
)
{
console
.
log
(
inputs
.
output_path
)
;
console
.
log
(
inputs
.
thresholds
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
{
inputs
}
)
=>
{
console
.
log
(
inputs
.
output_path
)
;
console
.
log
(
inputs
.
thresholds
)
;
}
,
}
Plugin inputs cannot be set through the Netlify UI
Currently, users cannot set inputs when
installing plugins from the Netlify UI
. If you would like your plugin to be listed under
Project configuration
>
Build & deploy
>
Build plugins
, we recommend setting
zero-config defaults
where possible, falling back to accepting values from
build environment variables
if needed.
#
Input validation
Plugin inputs can be validated using the
inputs
property in the plugin
manifest.yml
file:
# manifest.yml
name
:
netlify
-
plugin
-
lighthouse
inputs
:
-
name
:
output_path
required
:
false
description
:
Path to save the generated HTML Lighthouse report
default
:
"reports/lighthouse.html"
-
name
:
fail_deploy_on_score_thresholds
required
:
false
description
:
Fail deploy if minimum threshold scores are not met
-
name
:
thresholds
required
:
false
description
:
Key value mapping of thresholds that will fail the build when not passed
The
inputs
property is an array of objects with the following members:
name
{string}
:
name of the input. Required.
description
{string}
:
description of the input.
required
{boolean}
default
{any}
:
default value.
Always use
inputs
for validation
We recommended using the
inputs
property to validate your plugin inputs and assign default values. This works more consistently and efficiently than coding your own validation inside event handlers.
#
netlifyConfig
When an event handler executes, a site’s Netlify configuration is normalized by
@netlify/config
and passed as a
netlifyConfig
object. Normalization includes applying context-specific or branch-specific settings and combining settings from
netlify.toml
with build settings configured in the Netlify UI.
After normalization, plugins can access and modify most
netlifyConfig
properties during a site’s build. These include redirects, headers, and build configuration. If a site doesn’t use
netlify.toml
or build settings selections in the Netlify UI,
netlifyConfig
and its properties contain default build settings.
Here’s a list of modifiable properties:
redirects
:
array of
redirects
with their modifiable options
headers
:
array of
headers
with their modifiable options
functions
:
object with options for modifying
functions
functions.directory
:
string that includes the path to a site’s
functions directory
edge_functions
:
array of
edge functions
with their modifiable options
build.command
:
string that includes a site’s
build command
build.environment
:
object that contains a subset of a site’s
environment variables
build.edge_functions
:
string that includes the path to a site’s
edge functions directory
build.processing
:
object that includes options for
post processing
HTML
And here’s a plugin code sample that modifies several of the above properties.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
netlifyConfig
}
)
{
const
newCommand
=
`
node YOUR_SCRIPT.js
`
;
// Run a script after the build command
netlifyConfig
.
build
.
command
=
netlifyConfig
.
build
.
command
?
`
${
netlifyConfig
.
build
.
command
}
&&
${
newCommand
}
`
:
newCommand
;
// Modify build command's environment variables
netlifyConfig
.
build
.
environment
.
DATABASE_URI
=
getDatabaseUri
(
)
;
// Add redirects
netlifyConfig
.
redirects
.
push
(
{
from
:
"/ORIGIN_PATH"
,
to
:
"/DESTINATION_PATH"
,
}
)
;
// Add headers
netlifyConfig
.
headers
.
push
(
{
for
:
"/YOUR_PATH"
,
values
:
{
YOUR_HEADER_NAME
:
"YOUR_HEADER_VALUE"
}
,
}
)
;
// Add edge functions
netlifyConfig
.
edge_functions
?
netlifyConfig
.
edge_functions
.
push
(
{
path
:
'/YOUR_PATH'
,
function
:
'YOUR_EDGE_FUNCTION'
}
)
:
(
netlifyConfig
.
edge_functions
=
[
{
path
:
'/YOUR_PATH'
,
function
:
'YOUR_EDGE_FUNCTION'
}
]
)
}
// index.js
module
.
exports
=
{
onPreBuild
(
{
netlifyConfig
}
)
{
const
newCommand
=
`
node YOUR_SCRIPT.js
`
;
// Run a script after the build command
netlifyConfig
.
build
.
command
=
netlifyConfig
.
build
.
command
?
`
${
netlifyConfig
.
build
.
command
}
&&
${
newCommand
}
`
:
newCommand
;
// Modify build command's environment variables
netlifyConfig
.
build
.
environment
.
DATABASE_URI
=
getDatabaseUri
(
)
;
// Add redirects
netlifyConfig
.
redirects
.
push
(
{
from
:
"/ORIGIN_PATH"
,
to
:
"/DESTINATION_PATH"
,
}
)
;
// Add headers
netlifyConfig
.
headers
.
push
(
{
for
:
"/YOUR_PATH"
,
values
:
{
YOUR_HEADER_NAME
:
"YOUR_HEADER_VALUE"
}
,
}
)
;
// Add edge functions
netlifyConfig
.
edge_functions
?
netlifyConfig
.
edge_functions
.
push
(
{
path
:
'/YOUR_PATH'
,
function
:
'YOUR_EDGE_FUNCTION'
}
)
:
(
netlifyConfig
.
edge_functions
=
[
{
path
:
'/YOUR_PATH'
,
function
:
'YOUR_EDGE_FUNCTION'
}
]
)
}
,
}
;
#
packageJson
Each plugin event handler includes a
packageJson
argument. When an event handler executes, the contents of the
package.json
in a site’s
base directory
get passed to a plugin. The data fields are
normalized
to prevent plugin errors. If the site has no
package.json
, the argument is an empty object.
To access the
packageJson
object in your plugin code, use the following pattern:
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
packageJson
}
)
{
console
.
log
(
packageJson
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
{
packageJson
}
)
=>
{
console
.
log
(
packageJson
)
;
}
,
}
#
Environment variables
Plugins can access
build environment variables
two different ways:
process.env
: includes all Netlify build environment variables and any variables you declare using the Netlify UI or TOML. We recommend you use this when you only need to
get
values during the build process.
netlifyConfig.build.environment
: includes only the variables you declare using the Netlify UI or TOML. We recommend you use this when you need to
modify
values during the build process.
Visit our Forums for a verified Support Guide on
how to access environment variables during your site build
.
#
Plugin methods
We’ve provided a number of utilities and API methods to assist you in writing plugins.
#
Utilities
Several utilities are provided with the
utils
argument to event handlers:
build
:
used to report errors or cancel builds
status
:
used to display information in the deploy summary
cache
:
used to cache files between builds
run
:
used to run commands and processes
git
:
used to retrieve Git-related information such as the list of
modified/created/deleted files
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
async
function
(
{
utils
:
{
build
,
status
,
cache
,
run
,
git
}
}
)
{
await
run
.
command
(
"eslint src/ test/"
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
async
(
{
utils
:
{
build
,
status
,
cache
,
run
,
git
}
}
)
=>
{
await
run
.
command
(
"eslint src/ test/"
)
;
}
,
}
#
Error reporting
Exceptions thrown inside event handlers are reported in logs as bugs. Instead of using the
onError
event to handle exceptions, plugins should rely on
try
/
catch
/
finally
blocks and use
utils.build
:
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
utils
}
)
{
try
{
badMethod
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
)
;
}
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
{
utils
}
)
=>
{
try
{
badMethod
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
)
;
}
}
,
}
The following methods are available depending on the error’s type:
utils.build.failBuild("YOUR_MESSAGE")
:
method that fails the build - the build in your dashboard would show “Failed”. Use this to
indicate something went wrong.
utils.build.failPlugin("YOUR_MESSAGE")
:
method that fails the plugin but not the build.
utils.build.cancelBuild("YOUR_MESSAGE")
:
method that cancels the build - the dashboard would show “Cancelled” for that build. Use
this to indicate that the build is being cancelled as planned.
utils.build.failBuild()
,
utils.build.failPlugin()
and
utils.build.cancelBuild()
can specify an options object with
the following properties:
error
:
original
Error
instance. Its stack trace will be preserved and its error message will be appended to
the
"YOUR_MESSAGE"
argument.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
utils
}
)
{
try
{
badMethod
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
,
{
error
}
)
;
}
}
// index.js
module
.
exports
=
{
onPreBuild
:
(
{
utils
}
)
=>
{
try
{
badMethod
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
,
{
error
}
)
;
}
}
,
}
#
Logging
Anything logged to the console will be printed in the build logs.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
)
{
console
.
log
(
"This is printed in the build logs"
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
(
)
{
console
.
log
(
"This is printed in the build logs"
)
;
}
,
}
If you’d prefer to make the information more visible,
utils.status.show()
can be used to display them in the
deploy summary
instead.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
function
(
{
utils
}
)
{
utils
.
status
.
show
(
{
// Optional. Default to the plugin’s name followed by a generic title.
title
:
"Main title"
,
// Required.
summary
:
"Message below the title"
,
// Optional. Empty by default.
text
:
"Detailed information shown in a collapsible section"
,
}
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
(
{
utils
}
)
{
utils
.
status
.
show
(
{
// Optional. Default to the plugin’s name followed by a generic title.
title
:
"Main title"
,
// Required.
summary
:
"Message below the title"
,
// Optional. Empty by default.
text
:
"Detailed information shown in a collapsible section"
,
}
)
;
}
,
}
Only one status is shown per plugin. Calling
utils.status.show()
twice overrides the previous status.
This is meant for successful information. Errors should be reported
with
utils.build.*
instead
.
#
Asynchronous code
Asynchronous code can be achieved by using
async
methods:
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
async
function
(
{
utils
}
)
{
try
{
await
doSomethingAsync
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
,
{
error
}
)
;
}
}
// index.js
module
.
exports
=
{
onPreBuild
:
async
(
{
utils
}
)
=>
{
try
{
await
doSomethingAsync
(
)
;
}
catch
(
error
)
{
utils
.
build
.
failBuild
(
"YOUR_FAILURE_MESSAGE"
,
{
error
}
)
;
}
}
,
}
Any thrown
Error
or rejected
Promise
that is not handled by
utils.build
will be shown in the
build logs as a plugin bug.
Loading error: Refresh the page to access this code sample
// index.js
export
const
onPreBuild
=
async
function
(
{
utils
}
)
{
// Any error thrown inside this function will be shown
// in the build logs as a plugin bug.
await
doSomethingAsync
(
)
;
}
// index.js
module
.
exports
=
{
onPreBuild
:
async
(
{
utils
}
)
=>
{
// Any error thrown inside this function will be shown
// in the build logs as a plugin bug.
await
doSomethingAsync
(
)
;
}
,
}
Plugins end as soon as their methods end. Therefore you should
await
any asynchronous operation. The following
examples show invalid code and the way to fix it.
Loading error: Refresh the page to access this code sample
// index.js
// Example of how to use callbacks.
const
{
promisify
}
=
require
(
"util"
)
;
// VALID EXAMPLE: please use this.
// This callback will be awaited.
export
const
onPostBuild
=
async
function
(
{
utils
}
)
{
const
response
=
await
promisify
(
doSomethingAsync
)
(
)
;
console
.
log
(
response
)
;
}
// INVALID EXAMPLE: do not use this.
// This callback will not be awaited.
export
const
onPostBuild
=
function
(
{
utils
}
)
{
doSomethingAsync
(
(
error
,
response
)
=>
{
console
.
log
(
response
)
;
}
)
}
// index.js
// Example of how to use callbacks.
const
{
promisify
}
=
require
(
"util"
)
;
module
.
exports
=
{
// VALID EXAMPLE: please use this.
// This callback will be awaited.
onPostBuild
:
async
(
{
utils
}
)
=>
{
const
response
=
await
promisify
(
doSomethingAsync
)
(
)
;
console
.
log
(
response
)
;
}
,
// INVALID EXAMPLE: do not use this.
// This callback will not be awaited.
onPreBuild
:
(
{
utils
}
)
=>
{
doSomethingAsync
(
(
error
,
response
)
=>
{
console
.
log
(
response
)
;
}
)
}
,
}
Loading error: Refresh the page to access this code sample
// index.js
// Example of how to use events.
const
pEvent
=
require
(
"p-event"
)
;
// VALID EXAMPLE: please use this.
// This event will be awaited.
export
const
onPreBuild
=
async
function
(
{
utils
}
)
{
const
emitter
=
doSomethingAsync
(
)
;
emitter
.
start
(
)
;
const
response
=
await
pEvent
(
emitter
,
"response"
)
;
console
.
log
(
response
)
;
}
// INVALID EXAMPLE: do not use this.
// This event will not be awaited.
export
const
onPreBuild
=
function
(
{
utils
}
)
{
const
emitter
=
doSomethingAsync
(
)
;
emitter
.
on
(
"response"
,
response
=>
{
console
.
log
(
response
)
}
)
;
emitter
.
start
(
)
}
// index.js
// Example of how to use events.
const
pEvent
=
require
(
"p-event"
)
;
module
.
exports
=
{
// VALID EXAMPLE: please use this.
// This event will be awaited.
onPreBuild
:
async
(
{
utils
}
)
=>
{
const
emitter
=
doSomethingAsync
(
)
;
emitter
.
start
(
)
;
const
response
=
await
pEvent
(
emitter
,
"response"
)
;
console
.
log
(
response
)
;
}
,
// INVALID EXAMPLE: do not use this.
// This event will not be awaited.
onPreBuild
:
(
{
utils
}
)
=>
{
const
emitter
=
doSomethingAsync
(
)
;
emitter
.
on
(
"response"
,
response
=>
{
console
.
log
(
response
)
}
)
;
emitter
.
start
(
)
;
}
,
}
Loading error: Refresh the page to access this code sample
// index.js
// Example of how to use `Array.forEach()`.
// VALID EXAMPLE: please use this.
// This callback will be awaited.
export
const
onPostBuild
=
async
function
(
{
utils
}
)
{
await
Promise
.
all
(
array
.
map
(
async
(
)
=>
{
await
doSomethingAsync
(
)
}
)
,
)
;
}
// INVALID EXAMPLE: do not use this.
// This callback will not be awaited.
export
const
onPostBuild
=
function
(
{
utils
}
)
{
array
.
forEach
(
async
(
)
=>
{
await
doSomethingAsync
(
)
;
}
)
;
}
// index.js
// Example of how to use `Array.forEach()`.
module
.
exports
=
{
// VALID EXAMPLE: please use this.
// This callback will be awaited.
onPostBuild
:
async
(
{
utils
}
)
=>
{
await
Promise
.
all
(
array
.
map
(
async
(
)
=>
{
await
doSomethingAsync
(
)
;
}
)
,
)
;
}
,
// INVALID EXAMPLE: do not use this.
// This callback will not be awaited.
onPreBuild
:
(
{
utils
}
)
=>
{
array
.
forEach
(
async
(
)
=>
{
await
doSomethingAsync
(
)
;
}
)
;
}
,
}
#
Dynamic events
Some plugins trigger different events depending on the user’s
inputs
. This can be achieved by returning the plugin
object from a function instead.
Loading error: Refresh the page to access this code sample
// index.js
export
default
function
helloWorldPlugin
(
inputs
)
{
if
(
inputs
.
before
)
{
return
{
onPreBuild
:
(
)
=>
{
console
.
log
(
"Hello world from onPreBuild event!"
)
;
}
,
}
}
else
{
return
{
onPostBuild
:
(
)
=>
{
console
.
log
(
"Hello world from onPostBuild event!"
)
;
}
,
}
}
}
;
// index.js
module
.
exports
=
function
helloWorldPlugin
(
inputs
)
{
if
(
inputs
.
before
)
{
return
{
onPreBuild
:
(
)
=>
{
console
.
log
(
"Hello world from onPreBuild event!"
)
;
}
,
}
}
else
{
return
{
onPostBuild
:
(
)
=>
{
console
.
log
(
"Hello world from onPostBuild event!"
)
;
}
,
}
}
}
Last updated: May 13, 2025
←
Build Plugins
Share Build Plugins
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- build-plugins_share-plugins.txt --------
Start of file
URL: https://docs.netlify.com/build-plugins/share-plugins/
Scraped_At: 2025-06-02T19:56:26.047486

Contact
Forums
Contact support
If you’d like to share your plugin with others, you can
publish it to npm
. All Netlify Build Plugins in the
npm Public Registry
can be installed by any Netlify user through
file-based installation
.
#
Publish to npm
To publish a Build Plugin to npm, follow npm’s documentation for
contributing packages to the registry
.
Be sure to add the following properties to your plugin’s
package.json
file:
name
should start with
netlify-plugin-
(such as
netlify-plugin-example
or
@scope/netlify-plugin-example
). It should match the plugin
name
field. It is
recommended for the plugin repository to be named like this as well.
keywords
should contain the
netlify
and
netlify-plugin
keywords. The same applies to
GitHub topics
. This helps users find your plugin.
repository
and
bugs
should be defined. Those are displayed to users when an error
occurs inside your plugin.
Last updated: October 2, 2024
←
Create Build Plugins
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- cli_debug-with-vscode.txt --------
Start of file
URL: https://docs.netlify.com/cli/debug-with-vscode/
Scraped_At: 2025-06-02T19:56:26.933874

Contact
Forums
Contact support
You can use the VS Code debugger while you run your project with the Netlify CLI. This document outlines how to configure VS Code and how to launch the debugger.
#
Create a configuration file
Create a
launch.json
file under a
.vscode
directory in your project with the following content.
{
"version"
:
"0.2.0"
,
"configurations"
:
[
{
"name"
:
"netlify dev"
,
"type"
:
"node"
,
"request"
:
"launch"
,
"skipFiles"
:
[
"<node_internals>/**"
]
,
"outFiles"
:
[
"${workspaceFolder}/.netlify/functions-serve/**/*.js"
]
,
"program"
:
"${workspaceFolder}/node_modules/.bin/netlify"
,
"args"
:
[
"dev"
]
,
"console"
:
"integratedTerminal"
,
"env"
:
{
"BROWSER"
:
"none"
}
,
"serverReadyAction"
:
{
"pattern"
:
"Server now ready on (https?://[\\w:.-]+)"
,
"uriFormat"
:
"%s"
,
"action"
:
"debugWithChrome"
}
}
,
{
"name"
:
"netlify functions:serve"
,
"type"
:
"node"
,
"request"
:
"launch"
,
"skipFiles"
:
[
"<node_internals>/**"
]
,
"outFiles"
:
[
"${workspaceFolder}/.netlify/functions-serve/**/*.js"
]
,
"program"
:
"${workspaceFolder}/node_modules/.bin/netlify"
,
"args"
:
[
"functions:serve"
]
,
"console"
:
"integratedTerminal"
}
]
}
#
Launch the debugger
After you create the configuration file, launch the debugger:
Select
Run and Debug
from the VS Code sidebar. To reduce noise, we recommend that you deactivate
Caught Exceptions
.
In the top menu, select the command to run — either
netlify dev
or
netlify functions:serve
Run the debugger.
If you select
netlify dev
, the CLI will start a local development environment and open a browser with the site URL. If you select
netlify functions:serve
, the CLI will start a
standalone Netlify Functions server
.
#
Debug functions
Use the
--inspect
Node.js option to debug functions. Visit
managing functions
for more information.
Last updated: February 28, 2024
←
Manage functions with Netlify CLI
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- cli_get-started.txt --------
Start of file
URL: https://docs.netlify.com/cli/get-started/
Scraped_At: 2025-06-02T19:56:27.821193

Contact
Forums
Contact support
Netlify’s command line interface (CLI) lets you configure
continuous deployment
straight from the command line. You can use Netlify CLI to
run a local development server
that you can share with others,
run a local build and plugins
, and
deploy your site
.
The sections below describe how to perform common tasks with Netlify CLI. You can also access a
full command reference
online, or get help
within Netlify CLI
.
#
Installation
To install Netlify CLI, make sure you have
Node.js
version 18.14.0 or later.
Then, run this command from any directory in your terminal:
npm
install
-g
netlify-cli
This installs Netlify CLI globally, so you can run
netlify
commands from any directory. You can check the version and find out some basic information about the tool with the following command:
netlify
Global versus local
When using Netlify CLI in a continuous integration (CI) environment, use
local CLI installation
to maintain reproducible builds and avoid surprises due to breaking changes.
When developing locally, either local or global installation is appropriate.
#
Installation in a CI environment
When using Netlify CLI in a continuous integration (CI) environment such as GitHub Actions, CircleCI, or Travis CI, we recommend installing it locally as a development dependency instead of globally. This binds a specific CLI version to your project repository. To install Netlify CLI locally, run the following command from the root directory of your project:
npm
install
netlify-cli --save-dev
For CI environments, we also recommend using a
lock file
to guarantee reproducible builds and relying on an automated tool like
Renovate
or
Dependabot
to manage Netlify CLI version updates.
#
Authentication
Netlify CLI uses an access token to authenticate with Netlify. You can obtain this token using the command line or in the Netlify UI.
SAML SSO
If your team requires you to log in with
single sign-on (SSO)
, your tokens will be denied access to the team by default. You can choose to grant access to the team when you obtain a new token. You must be logged in to the team with SSO to grant access to it.
#
Obtain a token with the command line
To authenticate and obtain an access token using the command line, enter the following command from any directory:
netlify login
This will open a browser window, asking you to log in with Netlify and grant access to
Netlify CLI
.
Once authorized, Netlify CLI stores your access token in a
config.json
global configuration file. The Netlify CLI uses the token in this file automatically for all future commands.
#
config.json
location
You can find the Netlify CLI global configuration file,
config.json
, under your user in these OS-specific locations:
macOS:
Library/Preferences/netlify/config.json
Linux:
.config/netlify/config.json
Windows:
AppData\Roaming\netlify\Config\config.json
#
Obtain a token in the Netlify UI
You can generate a personal access token (PAT) manually in your Netlify user settings:
Go to
Applications
>
Personal access tokens
.
Select
New access token
.
Enter a descriptive name to help you remember what the token will be used for.
Select
Allow access to my SAML-based Netlify team
to authorize access to your SAML-based team data through the API.
Select an
Expiration
date for your token to help keep your information secure.
Select
Generate token
.
Copy the token to your clipboard and store it in a safe location. Once you navigate away from this page, you won’t be able to access the value again.
Select
Done
.
Save the token as a
NETLIFY_AUTH_TOKEN
environment variable in your terminal settings or in the UI of a Continuous Integration (CI) tool.
#
Cancel access tokens
To revoke your user access token for Netlify CLI, go to your Netlify user
Applications settings
. The procedure for revoking access depends on how access was granted.
For access granted using the
netlify login
command, scroll to the
Authorized applications
section, and find
Netlify CLI
. Select
Options
>
Revoke access
.
If you manually created a
personal access token
, you can find it in the
Personal access tokens
section. Select
Options
>
Delete personal token
.
#
Usage data collection
By default, Netlify collects data on usage of Netlify CLI commands. We do this to improve the reliability and performance of Netlify CLI, and to help drive new features and improvements.
If you’d like to opt out of sending usage data, you can do so by editing the
telemetryDisabled
property in the Netlify CLI
config.json
. You can also do this with the command line:
# opt out of sharing usage data
netlify --telemetry-disable
# allow your usage to help shape development
netlify --telemetry-enable
#
Continuous deployment
With
continuous deployment
, Netlify will automatically deploy new versions of your site when you push commits to your connected Git repository. This also facilitates features like
Deploy Previews
, branch deploys, and
split testing
. (Some of these features must be enabled in the Netlify UI.)
To connect your local project to an existing Netlify site, use
link
If your site already has continuous deployment set up and you just want to associate a project on your local machine to an existing site on Netlify, use
netlify link
instead of
netlify init
or
netlify init --manual
.
#
Automated setup
For repositories stored on GitHub.com, you can use Netlify CLI to connect your repository by running the following command from your local repository:
netlify init
In order to connect your repository for continuous deployment, Netlify CLI will need access to create a deploy key and a webhook on the repository. When you run the command above, you’ll be prompted to log in to your GitHub account, which will create an account-level access token.
The access token will be stored in the Netlify CLI
config.json
. Your login password will never be stored. You can revoke the access token at any time from your GitHub account settings; however, this will disable continuous deployment on all sites that were configured with that access token.
#
Manual setup
For repositories stored on GitLab, Bitbucket, or Azure DevOps, you can connect your repository manually with the
--manual
flag.
For repositories on GitHub, you can also connect your repository manually, if you prefer to give more limited, repository-only access for your repositories on GitHub.
From your local repository, run the following command:
netlify init
--manual
The Netlify CLI will prompt you to set your deploy settings and then provide you with a deploy/access key and a webhook URL. You’ll need to manually add the key and webhook URL to your Git provider.
#
Add your deploy or access key
Netlify uses a deploy or access key to fetch your repository using ssh for building and deploying. The deploy key does not require write access.
Copy the key printed in the command line, then add it to your Git provider.
GitHub, GitLab, or Bitbucket.
Add the deploy key to your repository’s settings. If you have more than one site connected to a repository, you will need a unique key for each repository.
Azure DevOps.
Add the Netlify SSH public key to your Azure DevOps user settings under
SSH Public Keys
.
#
Add your webhook URL
Your Git provider will send a message to this webhook when you push changes to your repository, triggering a new deploy on Netlify.
Copy the webhook address printed in the command line, then add the URL and webhook details to your Git provider. If available, the
Content type
should be set to
application/json
.
GitHub, GitLab, or Bitbucket.
Add the webhook address as the Payload URL for a new webhook in your repository’s settings. When selecting events to trigger the webhook,
Push
events will trigger production and branch deploys on watched branches, and
Pull/Merge request
events will trigger deploy previews.
Azure DevOps.
In your project’s settings under
Service hooks
, add webhooks for these Azure DevOps events using the Netlify webhook address as the Payload URL:
Code pushed
Pull request created
Pull request merge attempted
Pull request updated
Ensure that you set webhooks for your repository with the default
[Any]
branch setting. Once configured, these webhook events can trigger production and branch deploys on your watched branches.
#
Run a local development environment
Netlify Dev
brings the functionality of your Netlify production environment directly to your local machine.
For more information on how to configure and use Netlify Dev, refer to our
local development with Netlify Dev
doc.
#
Run builds locally
You can run builds in Netlify CLI to mimic the behavior of running a build on Netlify — including
Build Plugins
. To execute a build locally, run the following command from the root of your linked repository:
netlify build
The command will build your project using
environment variables
set in
netlify.toml
and those set using the Netlify UI, CLI, or API. Note that environment variables apply to all scopes when running
netlify build
locally.
Make sure your Node.js versions match
If you are using the Netlify CLI to run a build locally, make sure the Node.js version installed in your local environment matches the version
set for your build on Netlify
. If the versions don’t match, you may encounter errors.
If you’d like to get a summary of what a build will do without taking the time to do a full build, you can use the
--dry
flag:
netlify build
--dry
This command will output a list of all the stages of the build and the behaviors that are configured to run during each stage.
The default deploy context is
production
but you can also use the
--context
flag to run a build for a different
deploy context
.
netlify build
--context
deploy-preview
This command will run the build as if it is a Deploy Preview, applying any settings and environment variable values specific to that context.
#
Manual deploys
It’s also possible to deploy a site manually, without continuous deployment. This method uploads files directly from your local project directory to your site on Netlify. If
builds are stopped
, manual deploys are the only way you can update your site.
A common use case for this command is when you’re using a separate Continuous Integration (CI) tool, deploying prebuilt files to Netlify at the end of the CI tool tasks.
To get started with manual deploys, run the following command from your project directory:
netlify deploy
The first time you run the command, Netlify CLI will prompt you to select an existing site or create a new one, linking the site for all future deploys.
The following sections describe the requirements and options for manual deploys.
#
Deploy directories
The
deploy
command needs to know which folder to publish. If your project includes serverless functions, it needs to know the location of the
functions folder
as well. Netlify CLI will look for this information in three places, in the following order:
in
flags
specified in the command itself.
in a
netlify.toml file
stored at the root of your project directory.
in your site configuration in the Netlify UI, if continuous deployment is set up for the site.
Here is an example using command flags to set the publish folder and functions folder:
netlify deploy
--dir
=
_site
--functions
=
functions
In both cases, folder paths are relative to the current directory. Note that paths starting with
/
will begin at the computer’s root directory — not the base of your project directory.
#
Draft deploys
By default, the
deploy
command deploys to a unique
draft
URL for previewing and testing.
The default draft URL uses random alphanumeric characters for the subdomain. To customize the subdomain of your draft URL with a unique string, use the
--alias
flag with the
deploy
command.
netlify deploy
--alias
=
YOUR_ALIAS
Avoid using
--alias
with any of your branch names
Ensure the string you use after
--alias=
doesn’t match any existing branch names from your site’s repository. The
--alias
flag is designed to support draft deploy URLs only and doesn’t create a
branch deploy
or support our
branch subdomains
feature. Learn more about this flag in the
CLI reference docs
. To create a branch deploy, use
continuous deployment
.
#
Production deploys
To do a
production
deploy to your main site URL, use the
--prod
flag (or
-p
for short):
netlify deploy
--prod
#
Node.js function dependencies
Before manually deploying TypeScript or JavaScript functions with Netlify CLI, populate
node_modules
folders with your dependencies by running the following command in any folder containing
package.json
.
Loading error: Refresh the page to access this code sample
npm
install
yarn
When you deploy TypeScript or JavaScript functions using the
netlify deploy
command, Netlify CLI parses each function file to note its dependencies. For each function, the CLI then pulls the required dependencies from the associated
node_modules
folder and zips them with the function file for deployment.
#
Link and unlink sites
If your site isn’t already on Netlify, use
init
or
deploy
instead
If your site is not already on Netlify, you need to either set up
continuous deployment
or
manually deploy
the site before you can link your local project to it. If you use the Netlify CLI to deploy your site, the CLI will automatically link the project on your local machine to the site on Netlify.
If you want to connect your local project or repository to a site already on Netlify, you can skip the initial setup steps above and run the following command from the root of the local directory:
netlify
link
This will add a
siteId
field to a new file inside your project folder, at
.netlify/state.json
. To unlink your folder from the site, you can remove this field, or you can run the following command from inside the project folder:
netlify unlink
#
Link with an environment variable
Alternatively, you can link to a site by finding the site ID in the Netlify UI, then adding it to your local terminal environment:
Go to
Project configuration
>
General
>
Project details
>
Project information
, and copy the value for
Project ID
. (Also known as Site ID.)
Assign the ID to a
NETLIFY_SITE_ID
environment variable, in your terminal settings or in the UI of a Continuous Integration (CI) tool.
#
Manage environment variables
You can create and update site environment variables stored on Netlify with the CLI’s
env
command
. Any changes made using the CLI will be reflected in the Netlify UI. Environment variable changes require a build and deploy to take effect.
By default, the Netlify CLI deploy context is the
local development context
(
dev
). Unless a different deploy context is specified, CLI commands will get and use variables that have values set specifically for use with the
dev
deploy context and variables that have a single value for use across
all
deploy contexts.
Use the
--context
and
--scope
flags with your CLI commands to set contextual or scope values, or to filter results. You can use both flags in the same command, for example:
netlify env:set API_KEY someValue
--scope
functions
--context
production branch-deploy
netlify env:list
--scope
builds
--context
deploy-preview
#
Create or update environment variables
To create or update a site environment variable on Netlify, use
env:set
with the key followed by a space and then the value. You can only set one value at a time, but you can specify multiple deploy contexts and scopes in a space-separated list (no commas) using the
--context
and
--scope
flags.
netlify env:set API_KEY someValue
netlify env:set ANOTHER_API_KEY someValue
--scope
builds
--context
dev
If you omit the
--scope
or
--context
flags when running the
env:set
command, the variable is set to all scopes and with the same value for all deploy contexts.
To set one value for
production
and
deploy-preview
and another value for a branch named
staging
, run the command twice:
netlify env:set API_KEY someValue
--context
production deploy-preview
netlify env:set API_KEY someOtherValue
--context
branch:staging
You can also import environment variables from a
.env
file into Netlify using
env:import
followed by the filename. The imported variables are set to all scopes and with the same value for all deploy contexts.
netlify env:import .env
To copy environment variables from one site to another, use
env:clone
.
netlify env:clone
--to
destinationSiteId
--from
sourceSiteID
If you are using environment variable secrets with Netlify’s
Secrets Controller
, you can flag that an environment variable value is secret using the
--secret
flag when creating or modifying a value.
netlify env:set API_KEY someValue
--context
production
--secret
#
Get environment variables
To retrieve a list of site environment variables stored on Netlify, use
env:list
. The CLI gets all variables that have values set for local development with the Netlify CLI (deploy contexts
dev
or
all
) and outputs a list of keys with an option to display their values.
You can request other
contextual values
using the
--context
flag and filter the list using the
--scope
flag. You can also use the
--json
and
--plain
flags to retrieve the list in JSON or plain text format, which can be helpful if you want to copy the values into a
.env
file locally.
The list will only include shared environment variables if the command is run by a Team Owner.
This list will not include raw, unmasked values of any environment variables marked as secret unless the
--context
is
dev
. Review the
environment variable secrets
policy for more details on the access restrictions.
netlify env:list
netlify env:list
--context
branch:staging
netlify env:list
--scope
functions
netlify env:list
--plain
To retrieve an individual environment variable’s value, use
env:get
. The CLI gets the values set for local development with the Netlify CLI (deploy contexts
dev
or
all
). You can use the
--context
flag to retrieve a value from another context or the
--scope
flag to retrieve a value only if the variable is available to a specific scope.
netlify env:get API_KEY
netlify env:get API_KEY
--context
production
#
Delete environment variables
To delete environment variables from Netlify, use
env:unset
. This command deletes the specified variable and its values from all deploy contexts. Once unset, these variables will no longer be stored on Netlify or appear in the UI. You can use the
--context
flag to delete one value from a specific deploy context instead.
netlify env:unset API_KEY
netlify env:unset API_KEY
--context
dev
#
Work with monorepos
Commands execute from the workspace root
Starting with Netlify CLI version 16, all commands execute from the workspace root to mimic the build system behavior on Netlify. The workspace root is the directory that contains the highest-level
package.json
in your monorepo. Make sure any paths declared in
netlify.toml
are absolute paths relative to the
base directory
.
A monorepo is a repository that contains multiple sites or apps, each in its own subdirectory.
When you use the Netlify CLI, Netlify automatically scans the repository to detect if you are using a monorepo. If you are, the Netlify CLI will ask you to specify the site to run a command on and you can choose from the list of detected sites.
You also have the option to manually set the following flag:
--filter
: to specify which site in your monorepo to use for a command. You can use the package name or the path to the package. This way you can run commands directly from the repository root for all projects in your monorepo.
netlify dev
--filter
website
netlify dev
--filter
packages/website
Note that selecting a site with the Netlify CLI only applies to the command you are running and doesn’t influence the
build settings
in the Netlify UI. Learn more about how to set up a site from a
monorepo
.
#
Print debugging output
To print the full debugging output for a command to the terminal, set the
DEBUG
variable before running the command.
On Mac OS, Linux, and some common Windows terminals, add
DEBUG=*
to the beginning of the command:
DEBUG
=
* netlify deploy
If you are using the Windows command prompt (cmd.exe), use
set
to set the variable:
set DEBUG=* & netlify deploy
In Windows PowerShell, use
$env:
to set the variable:
$env
:DEBUG=
'*'
;
netlify deploy
#
Get help
To get usage tips and learn more about available commands from within Netlify CLI, run the following:
netlify
help
For more information about a specific command, run
help
with the name of the command.
netlify
help
deploy
This also works for sub-commands.
netlify
help
sites:create
If you have additional questions or ideas for new features, you can
start an issue
on Netlify CLI’s open source repository. You can also visit our
Support Forums
to start or join a conversation. We’d love to hear from you!
Local development with Netlify Dev: Get started with Netlify Dev
Local development with Netlify Dev: Share a live development server
Local development with Netlify Dev: Configuration
Last updated: May 13, 2025
Local development with Netlify CLI
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- cli_local-development.txt --------
Start of file
URL: https://docs.netlify.com/cli/local-development/
Scraped_At: 2025-06-02T19:56:28.445185

Contact
Forums
Contact support
The Netlify CLI brings the functionality of your Netlify production environment directly to your local machine through the
dev
command. This CLI functionality is also referred to as Netlify Dev.
When you use Netlify Dev, the CLI provides a proxy server that includes edge logic for custom headers and redirects, environment variables, and Netlify Functions. It
automatically detects
tools and frameworks like Gatsby, Hugo, Eleventy, Next.js, and more to configure a local development server that mimics the Netlify production environment.
The sections below describe how to get started with Netlify Dev, how project detection and ports work, and how to customize the configuration.
You can also access the
command reference for
dev
for more information.
#
Get started with Netlify Dev
Before you begin, make sure you complete the following if you haven’t already:
Install
the Netlify CLI.
Authenticate
with an access token.
Link your local project to a Netlify
siteID
. To do this, set up
continuous deployment
with
netlify init
or
link an existing Netlify site
with
netlify link
.
To start a local development server for the build tool you’re using, run the following command from the root of your linked repository:
netlify dev
By default, Netlify Dev runs your project using the configuration and
environment variables
set for local development with the Netlify CLI. For environment variables, that means those with values set for
dev
or
all
deploy contexts. You can use the
--context
flag to run your project with a different deploy context’s settings and variables.
netlify dev
--context
production
Note that environment variables apply to all scopes when running
netlify dev
.
To run a shell command within the Netlify Dev environment, use
exec
:
netlify dev:exec YOUR_SHELL_COMMAND
#
Project detection
Netlify Dev attempts to detect the site generator or build command that your project uses and run these on your behalf, while adding other development utilities. If you have a JavaScript project, it uses simple heuristics to search for the best
package.json
script to run for you, so you can use the full flexibility of npm scripts.
You also have the option to override framework detection, if needed.
Override framework detection
The number of
frameworks that Netlify Dev can detect
is growing but, if the framework you use is not yet supported, you can instruct Netlify Dev to run the project on your behalf. Configure your project’s build command, port, and publish directory with the
[dev]
block in your
netlify.toml
file.
# sample dev block in the toml
# note: each of these fields are optional and should only be used if you need an override
[
dev
]
command
=
"yarn start"
# Command to start your dev server
targetPort
=
3000
# The port for your application server, framework, or site generator
port
=
8888
# The port that the Netlify Dev will be accessible on
publish
=
"dist"
# If you use a _redirect file, provide the path to your static content folder
If the CLI detects your project incorrectly or detects multiple frameworks, you can specify a
framework
option to test only one detector against your project.
[
dev
]
framework
=
"create-react-app"
# or "#static" to force a static server
Possible values of
framework
:
#auto
(default) to check all
available frameworks
.
The ID for one of the available frameworks, as specified in
the
.json
file for that framework
in the Netlify Build repository.
#static
for a static file server
#custom
to use the
command
option to run an app server and
targetPort
option to connect to it
#
Project ports
When you use Netlify Dev, you may encounter a few different ports — especially if your project uses a static site generator that has its own dev server, like Gatsby. Keep the following in mind when working with Netlify Dev:
If your project uses a
framework that we can detect
, Netlify Dev will use the framework’s conventional ports, so you don’t have to supply them yourself. If multiple detectors match your project, we’ll ask you to choose.
If your site generator runs on a specific port, such as port 8000, you need to
specify the port
when you run
netlify dev
. Netlify Dev will connect to that port and route requests successfully to the site generator along with the rest of the local Netlify environment.
If you use an unrecognized site generator or framework, or have a server you want Netlify Dev to connect to, you need to
specify the port
when you run
netlify dev
.
To confirm which port to use for local development with Netlify Dev, search for this box in your console output:
┌──────────────────────────────────────────────────────────────┐
   │                                                              │
   │
[
Netlify Dev
]
Server now ready on http://localhost:8888    │
   │                                                              │
   └──────────────────────────────────────────────────────────────┘
#
Configuration
Netlify Dev works without configuration for the majority of users, but you can customize Netlify Dev settings in the
[dev]
section of the Netlify configuration file. The following sections outline some common configuration options.
For a full list of the available properties, refer to the
Netlify Dev section of our file-based configuration
doc.
#
Run an https server for local development
By default,
netlify dev
starts an HTTP server. If you require HTTPS, you can configure a certificate and key file for
use by
netlify dev
in your
netlify.toml
:
[
dev
]
[
dev.https
]
certFile
=
"cert.pem"
keyFile
=
"key.pem"
Self-signed certificates require extra configuration
If you’re using a self-signed certificate, you might need to configure your browser to accept it when running on
localhost
. To enable this setting for Chrome, visit
chrome://flags/#allow-insecure-localhost
in your browser.
#
Specify custom ports for Netlify Dev
Netlify Dev allows you to specify custom ports using the following parameters as flags or in a Netlify configuration file (
netlify.toml
):
targetPort
: the port for your application server, framework, or site generator
port
: the port for the Netlify Dev server that you will open in the browser
Netlify Dev tries to acquire these ports but if they are already in use by another application, it will throw an error and let you know.
[
dev
]
targetPort
=
3000
port
=
8888
#
More Netlify Dev resources
Command reference for
dev
Configuration properties for Netlify Dev in
netlify.toml
Use Netlify CLI with monorepos
Manage Functions with Netlify CLI
Last updated: April 10, 2025
←
Get started with Netlify CLI
Manage functions with Netlify CLI
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- cli_manage-functions.txt --------
Start of file
URL: https://docs.netlify.com/cli/manage-functions/
Scraped_At: 2025-06-02T19:56:30.124775

Contact
Forums
Contact support
The Netlify CLI offers the ability to create, serve, and test Netlify Functions locally. Once you create a serverless function, you have the option to invoke the function in a local development environment using Netlify Dev, or to invoke the functions with a local standalone server.
To learn about all of the options available, review the
command reference for functions
.
#
Create serverless functions with Netlify Dev
Netlify can create serverless functions for you locally as part of Netlify Functions with the
functions:create
command:
netlify functions:create
Follow the CLI prompts to select from a number of function templates that are available to get you started. You can also add your own utility functions to suit your project development needs.
# Create a new function from one of the available templates offered
# when prompted
$ netlify functions:create
# Create a new function with a given name using either of the
# following options
$ netlify functions:create hello-world
$ netlify functions:create
--name
hello-world
# Create a new function by cloning a template from a remote url
# organised with dependencies installed into a subdirectory
$ netlify functions:create hello-world
--url
https://my-remote-template-URL
Git ignore the
node_modules
folder
If your functions have
node_modules
in each function folder, make sure to add them to your
.gitignore
file. Don’t forget to add bash scripts to install the dependencies for production.
#
Deploy unbundled function folders
When a function has
node_modules
in its own folder, these packages need to be installed during deployment. The Netlify build system does not recursively install dependencies for your function folders but you can write
prebuild
or
postinstall
bash scripts to install them for production.
#
Invoke functions while running Netlify Dev
Use
netlify dev
to start a local development environment and Netlify Dev will run the functions as they would run in the Netlify production environment.
To get started, configure the
functions directory in your
netlify.toml
and then run
netlify dev
.
The functions will be accessible at
http://localhost:8888/.netlify/functions/function-name
in the browser. Accessing the function through the browser simulates a
GET
request but you can also use
netlify functions:invoke
to test other requests. For example, the CLI also models POST requests.
You can use
netlify functions: list
to get a list of all detected functions.
If you run functions in your local environment with Netlify Dev, you can then test sending payloads of data or authentication payloads:
netlify functions:invoke
# we will prompt you at each step
netlify functions:invoke myfunction
# invoke a specific function
netlify functions:invoke
--name
myfunction
# invoke a specific function
# sending payloads
netlify functions:invoke myfunction
--payload
'{"count": 1}'
netlify functions:invoke myfunction
--querystring
"count=1"
netlify functions:invoke myfunction
--payload
"./pathTo.json"
There are special cases for
event-triggered functions
that will also provide mock data for testing. This makes it possible to manually test event-triggered functions locally and improves the development experience.
#
Serve functions with a standalone server locally
While Netlify Dev will simulate the Netlify production environment, it can be useful to simulate Netlify Functions in a standalone server instead. If you serve functions with a standalone server, you can debug functions without the overhead of starting a framework server.
To start a functions server locally, run
netlify functions:serve
. Your function will be available at
http://localhost:9999/.netlify/functions/<function-name>
If you configure a functions directory, the server will serve functions from that directory. If not, the server will serve functions from
netlify/functions
. The default port for the functions server is
9999
.
To override these settings, use the
--functions
and
--port
flags:
netlify functions:serve
--functions
<
path-to-dir
>
--port
<
port
>
You can also configure the settings in a
netlify.toml
, under the
dev
block:
[
dev
]
functions
=
"netlify-functions"
functionsPort
=
7000
#
Debug functions locally
Netlify CLI uses
Lambda-local
to simulate serverless functions. Since the CLI invokes functions in the same process as the functions server, you can debug functions by inspecting the functions server process.
To debug, set the
--inspect
Node.js option when starting the functions server:
On Windows, run
cmd /V /C "set NODE_OPTIONS=--inspect && netlify functions:serve"
On Mac/Linux, run
NODE_OPTIONS=--inspect netlify functions:serve
Then, attach any Node.js debugger to the CLI process to debug your functions. To learn how to debug with Visual Studio Code while running the Netlify CLI, review
Debug with VS Code
.
Last updated: February 28, 2025
←
Local development with Netlify CLI
Debug with VS Code
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_available-software-at-build-time.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/available-software-at-build-time/
Scraped_At: 2025-06-02T19:56:30.887826

Contact
Forums
Contact support
These are the languages and tools available to your build during the build process.
Our current build is based on Ubuntu version 24.04 (also called Noble Numbat) and includes the languages and software versions listed below.
There are multiple ways to set the software and language version used for your builds. Learn more about
managing your build dependencies
.
#
Languages
Default version
Available versions
Set the version using
Node.js
22
Any version that
nvm
can install
In order of precedence:
.nvmrc
file,
.node-version
file,
NODE_VERSION
build environment variable, or the
Dependency management
section in the Netlify UI. For example, a node version set in
.nvmrc
will override the node version set in the Netlify UI.
Ruby
3.x
Any
official Ruby version
Build environment variable
RUBY_VERSION
or
.ruby-version
file
Python
3.x
Any
official Python version
Build environment variable
PYTHON_VERSION
,
Pipfile
file, or
runtime.txt
file
PHP
8.3
7.4
,
8.0
,
8.1
,
8.2
,
8.3
Build environment variable
PHP_VERSION
Go
1.x
Any
official Go version
Build environment variable
GO_VERSION
Java
8
Elixir
1.9.1
Emacs
26.3
Erlang
22.2
Swift
N/A
Any version that
swiftenv
can install
>= 5.0
Build environment variable
SWIFT_VERSION
, or
.swift-version
file
Rust
N/A
Any version that
rustup
can install
Cargo.toml
file
#
Tools
Available versions
Set the version using
Bun
1.x
Cask
latest
Composer
latest
Deno
1.x
Doxygen
1.9.8
GNU Make
4.3
Hugo
Any version
Build environment variable
HUGO_VERSION
Leiningen
stable
libvips
8.15.1
npm
Corresponds with the installed Node.js version.
Build environment variable
NPM_VERSION
pip
Corresponds with the installed Python version.
Pipenv
Corresponds with the installed Python version. Defaults to
latest
pnpm
Any version corepack can install. Defaults to
9.x
packageManager
field in your
package.json
file
Yarn
Any version corepack can install. Defaults to
1.x
packageManager
field in your
package.json
file
Zola
Any version
binrc
can install.
Build environment variable
ZOLA_VERSION
#
Request support for a language or tool
We love hearing from you and using your input to help us build a better web! Let us know about any missing tools and languages.
You can reach us by opening a new request on
our Forums
.
#
Report a bug
If you find an issue, let our support team know by opening a
support request
in our Forums.
For anything else,  you can use the Docs feedback form on the bottom of this docs page as well to provide us feedback and tell us how we can improve!
Last updated: May 13, 2025
←
Build troubleshooting tips
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_build-hooks.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/build-hooks/
Scraped_At: 2025-06-02T19:56:31.770030

Contact
Forums
Contact support
Build hooks are URLs you can use to trigger new builds and deploys. You can find them in
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build hooks
.
Select
Add build hook
to create a new build hook. The build hook name is for your reference, and will display in your list of build hooks, as well as in the default deploy message for each deploy triggered by the hook.
Select a branch to build by default. Only branches which have been deployed at least once will appear in this list.
Upon saving your build hook settings, Netlify will give you a unique URL for that build hook. To trigger this hook, you need to send a POST request to that URL.
In most cases, this POST request will be sent from a service you want to integrate with Netlify, but you can also send these requests yourself. For example, you can run a
curl
command from your terminal:
curl
-X
POST
-d
'{}'
https://api.netlify.com/build_hooks/5c23354f454e1350f8543e78
You can also test build hook requests with tools like
Postman
.
Note
Builds must be
active
for build hooks to trigger builds of your site.
#
Parameters
Build hooks accept the following optional URL query parameters to alter the behavior of the triggered build:
trigger_branch
: parameter that specifies which repository branch the build will use. If the branch does not exist in your repository at the time of the build, the build will fail, with an error message in the build log.
trigger_title
: parameter that specifies a title to replace the default deploy message in your site deploy list.
clear_cache
: when set to
true
, this parameter triggers a build with a cleared cache.
Here is an example build hook URL using these parameters:
https
:
//
api.netlify.com
/
build_hooks
/
5c23354f454e1350f8543e78
?
trigger_branch
=
testing
&
trigger_title
=
triggered+by+This+Awesome+Service
&
clear_cache
=
true
This would trigger a deploy from an existing branch called
testing
, with a custom message:
triggered by This Awesome Service
.
#
Payload
You can send a custom payload in your build hook POST request. The contents must be passed as a string, which will be URL-encoded and made available in the triggered build as an
environment variable
. You can access it in the build by using the variable
INCOMING_HOOK_BODY
.
#
Build hooks for Netlify Connect
This product is available on
Enterprise
plans.
When you
connect a site
to a data layer in
Netlify Connect
, Netlify automatically creates a build hook for that site. When data changes in that data layer, Netlify notifies the build hook and that automatically triggers a build and deploy of the site’s
production branch
.
Once you connect a site, the build hooks for the site include a
Netlify Connect - Data layer
build hook with the data layer ID as the value. This provides a convenient way on the site level to check whether a site is connected to a data layer. Expanding the build hook details reveals a link back to the data layer settings page.
Any deploys triggered by this build hook are labelled with
Deploy triggered by Netlify Connect
and include a link to the data layer that triggered the hook.
Build hooks created for Connect are not customizable or editable from the
Build Hooks
page. To delete a Connect-related build hook,
disconnect the site
from your data layer.
Last updated: May 13, 2025
←
On-demand Builders
Stop or activate builds
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_environment-variables.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/environment-variables/
Scraped_At: 2025-06-02T19:56:33.584328

Contact
Forums
Contact support
Netlify
environment variables
are accessible during your build. This allows you to change behaviors based on deploy parameters or to include information you don’t want to save in your repository, such as API keys.
This page describes how to create environment variables, the specific configuration and read-only variables that are available in the Netlify build environment, and how to use environment variables during the build process.
#
Declare variables
You can
declare and set environment variables
using the Netlify UI, CLI, API, or a Netlify configuration file. If you have the option to set specific
scopes
for your environment variables, the scope must include
Builds
to be available to the build system.
Visit the
environment variables overview
to learn more about environment variables at Netlify.
#
Netlify configuration variables
By setting custom values for certain reserved environment variables, you can change some aspects of your build, such as
language and dependency versions
. Links in the variable descriptions below provide more information about requirements, defaults, and accepted values.
NODE_VERSION
:
value that sets the
Node.js version
.
NODE_ENV
:
value that sets the
Node.js environment
.
NPM_VERSION
:
value that sets the
npm version
.
NPM_FLAGS
:
value passed as
flags on the
npm install
command
.
NPM_TOKEN
:
used for
fetching private npm modules
. If you use Yarn, use
YARN_NPM_AUTH_TOKEN
instead.
NETLIFY_USE_YARN
:
used to override the
default behavior for installing and running Yarn
.
YARN_VERSION
:
used to set the
Yarn version
.
YARN_FLAGS
:
passed as
flags on the
yarn
command
.
YARN_NPM_AUTH_TOKEN
:
used for
fetching private npm modules
with Yarn.
BUN_FLAGS
:
passed as
flags on the
bun install
command
.
RUBY_VERSION
:
used to set the
Ruby version
.
PHP_VERSION
:
value that sets the PHP version. Default and available values are determined by the site
build-image
.
PNPM_FLAGS
:
passed as
flags on the
pnpm install
command
.
PYTHON_VERSION
:
value that sets the
Python version
.
HUGO_VERSION
:
value that sets the
Hugo version
.
SWIFT_VERSION
:
value that sets the
Swift version
.
GO_VERSION
:
value that sets the Go version. Default and available values are determined by the site
build-image
.
NETLIFY_NEXT_PLUGIN_SKIP
:
when set to
true
for a Next.js site using Runtime v4, the build doesn’t use the
Next.js Runtime
. Use this variable with projects that generate static HTML using
next export
.
DISABLE_IPX
:
when set to
true
for a Next.js site using Runtime v4, the build will not generate a function for the
next/image
loader bundled into Next.js Runtime. This may break some sites unless another
image loader
is also specified.
NETLIFY_SKIP_GATSBY_FUNCTIONS
: when set to
true
for a Gatsby site, the
Essential Gatsby build plugin
will not
automatically generate Netlify Functions
. This will disable some Gatsby features and may break some sites.
NETLIFY_IMAGE_CDN
: value defaults to
false
. When set to
true
, the
Essential Gatsby build plugin
or
Gatsby adapter for Netlify
will use Netlify Image CDN instead of processing images at build time for Gatsby sites. Not supported for Gatsby version 5.12.x.
GATSBY_CLOUD_IMAGE_CDN
: deprecated variable that is supported but no longer recommended — use
NETLIFY_IMAGE_CDN
instead. Value defaults to
false
. When set to
true
, the
Essential Gatsby build plugin
will use Netlify Image CDN instead of processing images at build time.
GATSBY_EXCLUDE_DATASTORE_FROM_BUNDLE
:
value that defaults to
false
. When set to
true
, the
Essential Gatsby build plugin
loads the Gatsby datastore from the CDN instead of bundling it with a function.
AWS_LAMBDA_JS_RUNTIME
:
value that sets the
Node.js runtime version for Netlify Functions
. This environment variable must be set using the Netlify UI, CLI, or API, and not with a Netlify configuration file (
netlify.toml
).
CI
:
value that defaults to
true
, indicating that the build is running in a Continuous Integration (CI) environment. If this
causes issues for your build
, you can override the variable by adding
CI=''
to the beginning of your site
build command
.
The following variables should be set in the Netlify UI rather than in
netlify.toml
. This is because the Netlify configuration file is read after your repository has been cloned.
GIT_LFS_ENABLED
:
value that is undefined by default. If set, we’ll use
git lfs clone
to check out your repository — otherwise we use
git clone
.
GIT_LFS_FETCH_INCLUDE
:
if
GIT_LFS_ENABLED
is set, this specifies by file extension which Git LFS files will be downloaded when cloning your repository. Any other file extensions will have only text pointer files downloaded instead of the original media files.
NETLIFY_BUILD_DEBUG
:
set this to
true
to print additional debugging information in the build logs. The output does not contain sensitive information. To disable debugging, delete the variable. Alternatively, delete everything in the variable’s
Value
field.
#
Read-only variables
In addition to the variables you choose to declare, Netlify has a number of pre-defined variables built in.
The following variables are automatically set for your builds, and their values are not changeable.
#
Build metadata
NETLIFY
:
always
true
. Can be used to check if the build is running on Netlify.
BUILD_ID
:
unique ID for the build; for example:
5d4aeac2ccabf517d2f219b8
.
CONTEXT
:
name of the build’s
deploy context
. It can be
production
,
deploy-preview
,
branch-deploy
, or
dev
.
NETLIFY_PREVIEW_SERVER
:
always
true
if present. Only present if your site/app is running in a Preview Server virtual environment. Learn more about
Preview Servers
.
#
Git metadata
REPOSITORY_URL
:
URL for the
linked Git repository
.
BRANCH
:
reference to check out after fetching changes from the Git repository. Can be useful for
split testing
.
HEAD
:
name of the head branch received from a Git provider.
COMMIT_REF
:
reference ID (also known as “SHA” or “hash”) of the commit we’re building.
CACHED_COMMIT_REF
:
reference ID (also known as “SHA” or “hash”) of the last commit that we built before the current build. When a build runs without cache,
CACHED_COMMIT_REF
will be the same as the
COMMIT_REF
.
PULL_REQUEST
:
whether the build is from a pull/merge request (
true
) or not (
false
).
REVIEW_ID
:
ID of the request and the Deploy Preview it generated (for example,
1211
) if from a pull/merge request. These two numbers will always match. (For example,
deploy-preview-12
is for PR #12 in your repository.)
#
Deploy URLs and metadata
URL
:
URL representing the main address to your site. It can be either a Netlify subdomain or your own custom domain if you set one; for example,
https://petsof.netlify.app
or
https://www.petsofnetlify.com
.
DEPLOY_URL
:
URL representing the unique URL for an individual deploy. It starts with a unique ID that identifies the deploy; for example,
https://5b243e66dd6a547b4fee73ae--petsof.netlify.app
.
DEPLOY_PRIME_URL
:
URL representing the primary URL for an individual deploy, or a group of them, like branch deploys and Deploy Previews; for example,
https://feature-branch--petsof.netlify.app
or
https://deploy-preview-1--petsof.netlify.app
. If you set up an
automatic deploy subdomain
, this URL will update.
DEPLOY_ID
:
unique ID for the deploy; for example,
578ab634d6865d5cf960d620
. Matches the beginning of
DEPLOY_URL
.
SITE_NAME
:
name of the site, its Netlify subdomain; for example,
petsof
.
SITE_ID
:
unique ID for the site; for example,
1d01c0c0-4554-4747-93b8-34ce3448ab95
.
ACCOUNT_ID
:
unique ID for the Netlify team account which owns the site; for example:
63dd1fafda1bc5006q0f5cd
.
#
Build hook metadata and payload
If your build is triggered from a custom
build hook
, Netlify also has three build-hook-specific variables:
INCOMING_HOOK_TITLE
:
title of the build hook.
INCOMING_HOOK_URL
:
URL of the build hook.
INCOMING_HOOK_BODY
:
payload
of the request sent to the build hook URL.
#
Access variables
Build environment variables are available in the build system they’re set in and are available for use by build plugins and scripts run during the build step for a site. This section outlines how to access these variables during the build process.
Note that, as these are build variables specifically, you will need to take extra steps if you want your site to have
access to these values after the build is complete
.
Check your variable scope
If you have the option to set specific
scopes
for your environment variables, the scope must include
Builds
to be available to the Netlify build system.
#
Prepare your build environment
To use these environment variables, you need to ensure they’re set in the environment where the build will run - on Netlify through continuous deployment or in your local development environment.
#
Build on Netlify
If you have continuous deployment set up, Netlify will automatically start a build and deploy whenever you push code to your Git repo. While the build runs on Netlify, the build system already has access to all of the
variables set in the Netlify build environment
and can use them during the build process.
Note that when you build on Netlify, the build system doesn’t read
.env
files. To use variables declared in a
.env
file, we recommend you
import the variables
into Netlify before you build. This way the variables in your
.env
file remain secure and out of your shared repository.
#
Build locally
When you build in your local development environment, you need to ensure these environment variables are set in the local environment before you run the build command.
The best way to build locally is to use the
Netlify CLI
. Building locally with the CLI mimics the behavior of running a build on Netlify and will give you access to the environment variables you’ve already set there.
netlify build
You can also use
Netlify Dev
with
--context production
to run a local development environment that mimics the Netlify production environment. Netlify Dev will automatically pull down environment variables stored on Netlify and read any variables stored in a
.env
file on your machine.
If you don’t want to use the Netlify CLI or Netlify Dev, you need to set the variables in your local development environment yourself.
There are a few different ways to do this, including declaring variables directly in the command line or using a
.env
file and
dotenv
. Just remember not to commit any sensitive values to your repository.
Visit our Forums for a verified Support Guide on
how to access environment variables during your site build
for more tips.
#
Use variables during the build
Once the variables are set correctly in the environment you want to build in, you can access them in a few different ways depending on the context.
Use variables in the
netlify.toml
or Netlify UI
Use variables to install private npm modules
Use variables in Node.js script files
Use variables in build plugins
Use variables in a site after it’s built
#
Use variables in the
netlify.toml
or Netlify UI
Netlify commands use the Bash shell, so you can use Bash syntax to select the environment variable:
$VARIABLE_NAME
.
You can use this format in the Netlify UI and in the
netlify.toml
with the
build.command
and
ignore.command
.
For example, to print a
not-sensitive
variable (
GREETING = "hi there"
) to the deploy log at the end of the build step, set the build command in the Netlify UI to
npm run build && echo $GREETING
.
The next time you build and deploy the site, the build process will print the variable to the deploy log at the end of the build step.
Note that if you would like to use environment variable values in the
[[headers]]
and
[[redirects]]
sections of the
netlify.toml
, you need to
inject the values as part of your build command
.
#
Use variables to install private npm modules
To use an environment variable for private npm module installs, you can
set an
NPM_TOKEN
value
in your build environment. Whenever Netlify runs an install and build, npm will automatically check the environment for an
NPM_TOKEN
to use for authentication. This way, you can avoid declaring or accessing this sensitive variable value directly in your
package.json
. If you use Yarn to manage dependencies,
set
YARN_NPM_AUTH_TOKEN
instead of
NPM_TOKEN
.
#
Use variables in Node.js script files
To access environment variables in script files that Node.js runs during the build process, you need to use the format
process.env.VARIABLE_NAME
.
For example, create a file
sayHello
in TypeScript or JavaScript that will log your
non-sensitive
variable (
GREETING = "hi there"
) to the console when run:
Loading error: Refresh the page to access this code sample
const
greetPerson
:
string
=
process
.
env
.
GREETING
;
console
.
log
(
`
Say hello:
${
greetPerson
}
`
)
;
const
greetPerson
=
process
.
env
.
GREETING
;
console
.
log
(
`
Say hello:
${
greetPerson
}
`
)
;
Then, update the build command in the
package.json
or in the
netlify.toml
to include the instruction to run the script file:
Loading error: Refresh the page to access this code sample
# Replace ts-node with the appropriate command
# for your TypeScript compiler for node.js
[
build
]
command
=
"npm run build && ts-node ./sayHello.ts"
[
build
]
command
=
"npm run build && node ./sayHello.js"
The next time you build and deploy the site, the build process will print the variable to the deploy log at the end of the build step.
#
Use variables in build plugins
There are two ways to access environment variables in build plugins:
using
process.env.VARIABLE_NAME
or using
netlifyConfig
.
#
Use variables in a site after it’s built
If you want to use environment variable values in a site after it’s built, you need to take further action to provide access. Here are a few options:
Use a
function or edge function
to access values during runtime. This is the best option to avoid revealing sensitive values.
Use
snippet injection
to access values during post-processing.
Use a custom script or framework-specific variables to
copy values into the site
code during the build process.
If you inject values into the site using a build script or snippet injection, make sure to only include non-sensitive values.
More details are available in our verified Support Guide on
how to access environment variables
.
#
More environment variables resources
Overview of environment variables
at Netlify
Verified Support Guide on
how to use environment variables
Injecting environment variable values in your
netlify.toml
file
Environment variables for different deploy contexts
Hugo version environment variable
Node.js functions runtime settings
Environment variables overview: Sensitive variable policy
Last updated: April 23, 2025
←
Manage dependencies
File-based configuration
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_file-based-configuration.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/file-based-configuration/
Scraped_At: 2025-06-02T19:56:34.616455

Contact
Forums
Contact support
In addition to using the Netlify UI to configure
build settings
,
deploy settings
, and
environment variables
, you can also configure many of these settings in a
netlify.toml
file.
File-based configuration settings take precedence
Be aware that if you have conflicting configuration values, settings specified in
netlify.toml
override any corresponding settings in the Netlify UI.
The
netlify.toml
is a configuration file that specifies how Netlify builds and deploys your site — including redirects, branch and context-specific settings, and more. Its goal is to describe much of your site configuration alongside your code — with two goals:
When someone forks your repository, they can instantly create a Netlify site using the new repo. They don’t have to configure anything in the UI, and they’ll still get an identical site configuration.
You can track configuration changes using version control and configure some things that aren’t customizable in our UI.
There are other ways to accomplish some of the things you would use the
netlify.toml
for. For example, you can use
_headers
and
_redirects
files to accomplish what the filename suggests, but having these settings all live in the same file can greatly simplify maintaining them.
There are also certain settings that you can only configure using the Netlify UI, CLI, or API. The
netlify.toml
file is not a fully comprehensive configuration method.
Declare environment variables in the Netlify UI for more options
While you can use
netlify.toml
to declare environment variables, we recommend that you use the
Netlify UI
to avoid storing sensitive values in your repository, and for the option to set
scopes
, track changes in the
team audit log
, and access values with the Netlify
CLI
and
API
.
The following sections will go through where to store the
netlify.toml
, each thing you’ll be able to do in the file, and some examples that you could use in your code. For more information on TOML syntax, visit the
TOML website
.
#
File location
The
netlify.toml
is normally stored in the root of your site repository. You also have the option to include different configuration files in other directories for special cases such as
monorepos
.
If you store the Netlify configuration file in a directory other than the root, you will need to set either the
base directory
or the
package directory
to indicate where it is located. Learn more about
how Netlify searches for your configuration file
in our monorepos doc.
#
Configuration details
The following sections provide details for some commonly used configuration settings.
All paths configured in the
netlify.toml
should be absolute paths relative to the
base directory
, which is the root by default (
/
).
#
Build settings
The
[build]
command runs in the Bash shell, allowing you to add Bash-⁠compatible syntax to the command. Netlify also supports these properties (keys) for the
[build]
command:
base
: to specify the
base directory
publish
: to specify the
publish directory
command
: to specify the
build command
environment
: to declare
build environment variables
processing
: to configure
post-processing settings
If a key has a list of key/value pairs as its value, you can set that key in its own block like this:
[
build.environment
]
VARIABLE
=
"value"
#
Ignore builds
Netlify tries to determine if there are any changes in the site’s base directory by comparing the last known version of the files within that directory. If no change is detected, the build system skips the build, returning early from the build process.
To override the default check with a custom workflow, you can use the
ignore
attribute in
netlify.toml
. This allows you to specify a Bash or Node.js command to determine whether the site needs rebuilding or not.
Check out our
ignore builds
doc for more information on the default ignore behavior and details about constructing a custom
ignore
command.
#
Build Plugins
Netlify
Build Plugins
extend the functionality of the build process. In addition to installing plugins through the
Project configuration
>
Build & deploy
>
Build plugins
section in the Netlify UI, you can also add them to a site using
file-based installation
. Here’s an example
[[plugins]]
section in
netlify.toml
:
[
[
plugins
]
]
package
=
"netlify-plugin-check-output-for-puppy-references"
[
plugins.inputs
]
breeds
=
[
"pomeranian"
,
"chihuahua"
,
"bulldog"
]
For more detailed information about installing and removing plugins, configuration options, and building and sharing different types of plugins, check out our
Build Plugins
docs.
#
Extensions
Some
extensions
run during the build-deploy lifecycle for a site — for example, to analyze your build or to inject edge functions and serverless functions. If you install an extension that runs during the build process, you can configure the extension in
netlify.toml
for the sites that use it.
Follow the instructions to
install the extension
on your team.
Use
[[integrations]]
in your
netlify.toml
to configure the extension settings for each site that uses the extension.
Here is an example:
[
[
integrations
]
]
name
=
"abc-performance-extension"
[
integrations.config
]
output_path
=
"reports/performance-reports.html"
fail_deploy_on_score_thresholds
=
"true"
[
integrations.config.thresholds
]
performance
=
0.9
accessibility
=
0.9
best-practices
=
0.9
seo
=
0.9
pwa
=
0.9
The extension author defines the format of the configuration options you can provide in
netlify.toml
, so we recommend reviewing the extension’s documentation for detailed instructions.
#
Deploy contexts
Certain keys, such as
[build]
and
[[plugins]]
but not
[[redirects]]
or
[[headers]]
, allow you to set
[context]
properties based on the
kind of deploy
. These keys are
context-aware
.
During a build, the following ordering determines which context covers a particular deploy:
UI settings are overridden if a
netlify.toml
file is present and a setting for the same property/redirect/header exists in the UI and the TOML file.
any property of a context-aware key, such as
[build]
or
[[plugins]]
, will be applied to all contexts unless the same property key is present in a more specific context.
any property in
[context.production]
,
[context.deploy-preview]
,
[context.branch-deploy]
, or
[context.dev]
will override less specific contexts:
production — a deploy generated from the production branch set in the UI under
Project configuration
>
Build & deploy
>
Continuous deployment
>
Branches and deploy contexts
deploy-preview — a deploy generated from a pull request or merge request
branch-deploy — a deploy generated from a branch that is not your production branch
dev — local development environments run using
Netlify Dev
. Use
[context.dev]
to set environment variables and use the
[dev]
section to configure all other local development properties.
any property in
[context.branchname]
, for a given branchname, is the most specific, and thus overrides all the less specific contexts.
# Production context: all deploys from the Production branch
# set in your site’s Branches settings in the UI will inherit
# these settings.
[
context.production
]
publish
=
"output/"
command
=
"make publish"
# Deploy Preview context: all deploys generated from
# a pull/merge request will inherit these settings.
[
context.deploy-preview
]
publish
=
"dist/"
#
Post processing
You can manage the Pretty URLs post processing setting with the
processing
property.
#
Pretty URLs
This setting overrides the corresponding setting under
Project configuration
>
Build & deploy
>
Post processing
>
Pretty URLs
.
[
build.processing.html
]
pretty_urls
=
true
#
Redirects
You can manage your
redirects
directly in your
netlify.toml
. For each redirect you want to declare, add an entry with the
[[redirects]]
heading:
[
[
redirects
]
]
from
=
"/old-path"
to
=
"/new-path"
status
=
301
force
=
false
query
=
{
path
=
":path"
}
#  apply this rule for /old-path?path=example
conditions
=
{
Language
=
[
"en"
,
"es"
]
,
Country
=
[
"US"
]
}
[
[
redirects
]
]
from
=
"/news"
to
=
"/blog"
Here’s a
proxy redirect
:
[
[
redirects
]
]
from
=
"/api/*"
to
=
"https://us-central1-netlify-intercom.cloudfunctions.net/readHeaders/:splat"
status
=
200
force
=
true
conditions
=
{
Role
=
[
"admin"
,
"cms"
]
}
[
redirects.headers
]
X-From
=
"Netlify"
X-Api-Key
=
"some-api-key-string"
You can redirect your netlify subdomain to your custom domain. Note that the
force = true
is equivalent to the
!
(for
shadowing
) in the
_redirects
file:
[
[
redirects
]
]
from
=
"https://somenetlifysite.netlify.app"
to
=
"https://mycustomdomain.com"
status
=
301
force
=
true
For more details on options to use with your redirects, review the
redirect options
doc.
#
Headers
You can define custom
headers
in
netlify.toml
. Here is an example of some headers you could configure:
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
X-Frame-Options
=
"DENY"
#  Multi-value headers are expressed with multi-line strings
cache-control
=
'''
	max-age=0,
	no-cache,
	no-store,
	must-revalidate'''
# The Basic-Auth header may not be available on all plans.
Basic-Auth
=
"someuser:somepassword anotheruser:anotherpassword"
By default, headers set in the
netlify.toml
are global for all builds and cannot be scoped for specific branches or deploy contexts. However, there is a workaround you can use to
set unique headers for each deploy context
.
#
Functions
Although there are default settings for
Netlify Functions
to help you get started, you can use the
[functions]
section in
netlify.toml
for optional, custom configuration.
The following property applies for all functions:
directory
:
custom absolute path to your functions. The default location is
YOUR_BASE_DIRECTORY/netlify/functions
.
Meanwhile, the following properties apply only for functions written in TypeScript or JavaScript. You can set them for all functions in your project or filter them by name, including using
glob patterns
. If a function matches several configuration blocks containing one of these properties, the values are concatenated.
node_bundler
:
function bundling method used in
@netlify/zip-it-and-ship-it
. Valid values:
esbuild
:
method that leverages
esbuild
to bundle functions, resulting in shorter bundling times and smaller artifacts. TypeScript functions always use
esbuild
. Currently available as an opt-in beta for JavaScript functions.
zisi
:
default function bundling method for JavaScript functions.
external_node_modules
:
list of Node.js modules that are copied to the bundled artifact without adjusting their source or references during the bundling process; only applies when
node_bundler
is set to
esbuild
. This property helps handle dependencies that can’t be inlined, such as modules with native add-ons.
included_files
:
list of additional paths to include in the function bundle. Although our build system includes statically referenced files (like
require("./some-file.js")
) by default,
included_files
lets you specify additional files or directories and reference them dynamically in function code. You can use
*
to match any character or prefix an entry with
!
to exclude files. Paths are absolute paths relative to the
base directory
.
For more context, check out our blog post about
including files in Netlify Functions
with caveats for the
esbuild
bundler.
[
functions
]
# Sets a custom directory for Netlify Functions
directory
=
"myfunctions/"
# Specifies `esbuild` for functions bundling
node_bundler
=
"esbuild"
# Flags "package-1" as an external node module for all functions
external_node_modules
=
[
"package-1"
]
# Includes all Markdown files inside the "files/" directory.
included_files
=
[
"files/*.md"
]
[
functions."api_*"
]
# Flags "package-2" as an external node module for functions
# with a name beginning with "api_". Functions matching this
# pattern have both "package-1" and "package-2" as
# external modules, because modules from this object
# are concatenated with any from the top-level object.
external_node_modules
=
[
"package-2"
]
# Includes all Markdown files previously defined in the
# top-level object, except for "post-1.md".
included_files
=
[
"!files/post-1.md"
]
[
functions.api_payment
]
# Flags "package-3" and "package-4" as external node modules
# for a function named "api_payment".
# This function has 4 external node modules:
#  "package-1" from the top-level object
#  "package-2" from the "api_*" object
#  "package-3" and "package-4" from this object
external_node_modules
=
[
"package-3"
,
"package-4"
]
# Includes all Markdown files inside "files/", except for
# "post-1.md" (excluded in the "api_*" object)
# and "post-2.md" (excluded in this object).
# Also includes "package.json" and any files
# inside "images/" or any of its subdirectories.
included_files
=
[
"!files/post-2.md"
,
"package.json"
,
"images/**"
]
#
Netlify Dev
Netlify Dev
uses
detectors
to enable a local development environment for most tools and frameworks without any additional setup.
You can use the
[dev]
section in
netlify.toml
for optional configuration. Note that
[dev]
doesn’t run in the Bash shell, however, so you won’t be able to use Bash-⁠compatible syntax with the command.
All paths configured in the
[dev]
section should be absolute paths relative to the
base directory
, which is the root by default (
/
).
Netlify Dev also makes use of the
functions directory setting
to scaffold and serve your functions in a local development environment.
[dev]
includes optional properties such as these:
command
:
command that starts your development server or runs a command such as a compiler watch in the background. If no
targetPort
is specified, it runs the command in the background in addition to the static file server.
port
:
port that Netlify Dev is accessible from in the browser.
targetPort
:
port for your application server, framework, or site generator. If provided, the CLI will wait until the provided
targetPort
is reachable and then proxy requests to it. If you specify values for both
command
and
targetPort
,
framework
must be
#custom
.
functionsPort
: the port where Netlify Dev serves functions.
publish
:
path to your static content folder.
jwtRolePath
:
object path that points to role values for JWT-based redirects.
jwtSecret
:
secret used to verify tokens for JWT-based redirects.
autoLaunch
:
boolean value that determines whether Netlify Dev launches the local server address in your browser.
framework
:
setting to use if a project is detected incorrectly, flagged by multiple detectors, or requires a
command
and
targetPort
. Valid values:
#auto
:
default, tests all available detectors.
#static
:
property that specifies a static file server.
#custom
:
property that uses the
command
value to run an app server and the
targetPort
value to connect to it. Required if
command
and
targetPort
are both set.
https
:
property that specifies an SSL/TLS certificate and key file for the Netlify Dev local server. By default, Netlify Dev starts an HTTP server, but you can configure a certificate and key file if you require HTTPS. The
https
configuration is an object with the following properties:
certFile
:
path to the certificate file.
keyFile
:
path to the private key file.
Note that an
environment
property doesn’t exist for
[dev]
. If you would like to set environment variables for use locally with the Netlify CLI, use
context.dev
instead.
Here’s an example
[dev]
section for Netlify Dev configuration overrides:
[
dev
]
command
=
"yarn start"
port
=
8888
targetPort
=
3000
publish
=
"dist"
jwtRolePath
=
"app_metadata.authorization.roles"
jwtSecret
=
"MY_JWT_SECRET_VALUE"
autoLaunch
=
true
framework
=
"#custom"
[
dev.https
]
certFile
=
"cert.pem"
keyFile
=
"key.pem"
#
Templates
While a template repository can make use of other
netlify.toml
settings, you can use the
[template]
section of a
netlify.toml
to provide template-specific configuration for
Deploy to Netlify buttons
.
[
template
]
incoming-hooks
=
[
"Contentful"
]
[
template.environment
]
SECRET_TOKEN
=
"change me for your secret token"
CUSTOM_LOGO
=
"set the url to your custom logo here"
Visit our
template configuration
docs to learn more about setting up templates and the configuration options in the example above.
#
Inject environment variable values
Using environment variables directly as values in your
netlify.toml
isn’t supported. For example,
key = "$VARIABLENAME"
will not inject
$VARIABLENAME
’s value into
netlify.toml
. One exception to this rule is
signed proxy redirects
.
For all other cases, you have two options for working with environment variable values in a file-based or programmatic way.
Note that if you have the option to set specific
scopes
for your environment variables, the scope must include
Builds
for the following options to work.
#
Use a local build plugin
We recommend
creating a local build plugin
to use environment variable values in a programmatic way because it’s the most versatile approach. It enables you to
read environment values
and change many aspects of your build configuration (including redirects and headers) through
the
netlifyConfig
object
.
#
Use the
[build]
command to substitute environment variable values
Substituting values using the
[build]
command in
netlify.toml
only works for the
[[headers]]
and
[[redirects]]
sections, as they are read after the build is complete. Note that substitutions made in the configuration file using this approach will not be available to build plugins, as build plugins run before the build command.
The
[build]
command
is a Bash command and so it has access to variables set in the build environment. You can use the following steps to substitute values in the file with environment variable values during the build step,
but only if you are changing headers or redirects
.
Add a placeholder like
HEADER_PLACEHOLDER
somewhere in the
[[headers]]
or
[[redirects]]
sections of your TOML file.
Create an environment variable, for example
PROD_API_LOCATION
, with the desired value in the Netlify UI.
Prepend a replacement
sed
command to your build command in
netlify.toml
. The
sed
command must use double quotation marks, not single ones. Here’s an example for a site using
yarn build
to build:
[
build
]
command
=
"sed -i \"s|HEADER_PLACEHOLDER|${PROD_API_LOCATION}|g\" netlify.toml && yarn build"
#
Sample
netlify.toml
file
This example
netlify.toml
demonstrates how you can combine multiple settings in a single file. It’s not a comprehensive example of all available configuration options.
# Settings for the [build] key are global and are applied to
# all deploy contexts unless overridden by a context-specific setting.
[
build
]
# Directory where the build system installs dependencies
# and runs your build. Store your package.json, .nvmrc, etc here.
# If not set, defaults to the root directory.
base
=
"project/"
# Directory that contains the deploy-ready HTML files and
# assets generated by the build. This is an absolute path relative
# to the base directory, which is the root by default (/).
# This sample publishes the directory located at the absolute
# path "root/project/build-output"
publish
=
"build-output/"
# Default build command.
command
=
"echo 'default context'"
[
[
plugins
]
]
# Installs the Lighthouse Build Plugin for all deploy contexts
package
=
"@netlify/plugin-lighthouse"
# Production context: all deploys from the Production branch
# set in your site’s Branches settings in the UI will inherit
# these settings. You can define environment variables
# here but we recommend using the Netlify UI for sensitive
# values to keep them out of your source repository.
[
context.production
]
publish
=
"output/"
command
=
"make publish"
environment
=
{
NODE_VERSION
=
"14.15.3"
}
# Deploy Preview context: all deploys generated from
# a pull/merge request will inherit these settings.
[
context.deploy-preview
]
publish
=
"dist/"
# Here is an example of how to define context-specific
# environment variables. To avoid committing sensitive
# values to public source repositories, set variables
# with the Netlify UI, CLI, or API instead.
[
context.deploy-preview.environment
]
NOT_PRIVATE_ITEM
=
"not so secret"
# Branch Deploy context: all deploys that are not from
# a pull/merge request or from the Production branch
# will inherit these settings.
[
context.branch-deploy
]
command
=
"echo branch"
[
context.branch-deploy.environment
]
NODE_ENV
=
"development"
# Dev context: environment variables set here
# are available for local development environments
# run using Netlify Dev. These values can be
# overwritten on branches that have a more specific
# branch context configured.
[
context.dev.environment
]
NODE_ENV
=
"development"
# Specific branch context: all deploys from
# this specific branch will inherit these settings.
[
context.staging
]
# “staging” is a branch name
command
=
"echo 'staging'"
base
=
"staging"
# For contexts of branches with special characters,
# enclose the branch name with quotes.
[
context."feat/branch"
]
command
=
"echo 'special branch'"
base
=
"branch"
# Redirects and headers are GLOBAL for all builds – they do not
# get scoped to contexts no matter where you define them in the file.
# For context-specific rules, use _headers or _redirects files,
# which are PER-DEPLOY.
# A basic redirect rule
[
[
redirects
]
]
from
=
"/*"
to
=
"/blog/:splat"
# A redirect rule with many of the supported properties
[
[
redirects
]
]
from
=
"/old-path"
to
=
"/new-path"
# The default HTTP status code is 301, but you can
# define a different one.
status
=
302
# By default, redirects won’t be applied if there’s a file
# with the same path as the one defined in the `from` property.
# Setting `force` to `true` will make the redirect rule
# take precedence over any existing files.
force
=
true
# Redirect from /old-path?id=123 to /new-path.
# Each combination of query params needs to be
# defined in a separate [[redirects]] block.
# More information at https://docs.netlify.com/routing/redirects/redirect-options/#query-parameters
query
=
{
id
=
":id"
}
# Redirect based on conditions including browser language,
# geolocation, identity role, and/or cookie presence.
conditions
=
{
Language
=
[
"en"
]
,
Country
=
[
"US"
]
}
# Sign each request with a value defined in an environment variable
signed
=
"API_SIGNATURE_TOKEN"
# You can also define custom headers within your redirects blocks.
[
redirects.headers
]
X-From
=
"Netlify"
X-Api-Key
=
"some-api-key-string"
# Redirects for role-based access control don’t use the 'to' property.
[
[
redirects
]
]
from
=
"/gated-path"
status
=
200
conditions
=
{
Role
=
[
"admin"
]
}
force
=
true
# The following redirect is intended for use with most SPAs
# that handle routing internally.
[
[
redirects
]
]
from
=
"/*"
to
=
"/index.html"
status
=
200
[
[
headers
]
]
# Define which paths this specific [[headers]] block will cover.
for
=
"/*"
[
headers.values
]
X-Frame-Options
=
"DENY"
Content-Security-Policy
=
"frame-ancestors https://www.facebook.com"
# Multi-value headers are expressed with multi-line strings.
cache-control
=
'''
  max-age=0,
  no-cache,
  no-store,
  must-revalidate'''
# Basic-Auth allows you to password protect your whole site.
# This feature may not be available on all plans.
Basic-Auth
=
"someuser:somepassword anotheruser:anotherpassword"
[
functions
]
# Directory with serverless functions, including background
# functions, to deploy. This is an absolute path relative to the
# base directory, which is the root by default (/).
directory
=
"functions/"
# Use [dev] to set configuration overrides for local
# development environments run using Netlify Dev - except
# for environment variables. Environment variables for Netlify
# Dev should be set under [context.dev.environment] instead.
[
dev
]
command
=
"yarn start"
port
=
8888
publish
=
"dist"
Edge Functions
Asset optimization end of service
Last updated: May 13, 2025
←
Build environment variables
On-demand Builders
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_ignore-builds.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/ignore-builds/
Scraped_At: 2025-06-02T19:56:35.615124

Contact
Forums
Contact support
With continuous deployment, Netlify attempts to ignore builds when they’re not required, only building when your site requires it.
Depending on your
Branches
settings
, any time there is a change in a linked repository, Netlify tries to determine whether there are changes in the site’s
base directory
by comparing the last known version of the files in that directory. If no change is detected, the build system cancels and essentially skips the build, returning early from the build process.
To override the default behavior described above, you can use the
ignore
attribute in the
Netlify configuration file
. This setting allows you to specify a Node.js or Bash command that runs from the base directory and determines whether or not the site needs rebuilding.
#
Custom
ignore
command
The
ignore
command provides custom, programmatic control over builds. It can prevent bot-triggered builds, for example, or limit production deploys to certain days of the week. It can also account for times when you may still want to run a build when there’s a change outside of a base directory, for example, if there’s a change to
package.json
in the root directory.
Things to note when constructing an
ignore
command:
An exit code of
1
indicates the contents have changed and the build process continues as usual. An exit code of
0
indicates that there are no changes and the build should stop.
The command is run with Bash. You can also
use Node.js
.
If the command references a separate file, the file path must start with
./
.
The
ignore
command won’t cancel a build triggered by a
build hook
, regardless of exit code.
Netlify can run an
ignore
command even if a
base directory
isn’t set.
All paths in your
ignore
command should be absolute paths relative to the
base directory
, which is the root by default (
/
).
#
ignore
examples
Want to customize the default ignore behavior? Check out the examples of custom
ignore
commands below. For more
ignore
examples, head over to our verified Support Guide on
using the
ignore
command
.
#
Mimic default behavior
The Bash example below is an
ignore
command that roughly approximates the default ignore builds behavior. You can add to or adjust it to update the default check. The commands use read-only
environment variables for Git metadata
as well as the
CI
and
NETLIFY
build environment variables
.
[
build
]
ignore
=
"git diff --quiet $CACHED_COMMIT_REF $COMMIT_REF"
For this next example, consider a monorepo project set up like this, where
packages/blog-1
is the
package directory
and the base directory is the repository root (
/
), by default.
/
├─ package.json
└─ packages/
   ├─ blog-1/
   │  ├─ package.json
   │  └─ netlify.toml
   ├─ common/
   │  └─ package.json
   └─ blog-2/
      ├─ package.json
      └─ netlify.toml
The following
ignore
command example adapts the default behavior so that the build proceeds only if there are changes within the
blog-1
or
common
directories.
[
build
]
ignore
=
"git diff --quiet $CACHED_COMMIT_REF $COMMIT_REF packages/blog-1 packages/common"
#
Skip builds based on branch name
The
ignore
command has access to a Node.js environment. This means if you want to prevent builds based on logic that’s hard to handle in Bash, you can use Node.js.
This example skips builds for a specific branch by adding a Node.js script to the
ignore
command in
netlify.toml
.
[
build
]
ignore
=
"node ignore_build.js"
ignore_build.js
executes before any build logs run. If the branch name is
debug
, the exit code is set to
0
, which stops the build.
// ignore_build.js
process
.
exitCode
=
process
.
env
.
BRANCH
.
includes
(
"debug"
)
?
0
:
1
There are a few things you should keep in mind when using Node.js with an
ignore
command.
Node.js dependencies
from the site’s
package.json
are not available.
ignore
commands use Node.js 18. This Node.js version can’t be customized. This means if your site has a
custom Node.js version
, the custom version is not used in the
ignore
command.
#
More build configuration resources
Common framework configurations
Monorepos
JavaScript SPAs
Last updated: July 19, 2024
←
Monorepos
Manage dependencies
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_javascript-spas.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/javascript-spas/
Scraped_At: 2025-06-02T19:56:36.531419

Contact
Forums
Contact support
Netlify supports many frameworks and project architectures. On this page, you'll find generic common configuration information for JavaScript single-page applications (SPAs). For framework-specific configurations, refer to our
frameworks page
.
#
Build configuration for JavaScript SPAs
Most SPAs declare a build command in the
scripts
array of the project’s
package.json
file. To run this script in Netlify, set the
Build command
to
npm run YOUR_BUILD_SCRIPT
or
yarn YOUR_BUILD_SCRIPT
, depending on your chosen
JavaScript dependency manager
.
The
Publish directory
for single-page apps is often called
dist
but varies by framework and build tool. You can check the framework documentation, or try running the build script locally, then check what folder was created as a result.
Avoid 404s for SPAs
If your project is a single page app (SPA) that uses the history
pushState
method to get clean URLs, you must add a
rewrite rule
to serve the
index.html
file no matter what URL the browser requests.
#
Code splitting or hashed filenames
If your SPA (single-page application) uses code splitting or hashed filenames with our atomic deploys, filename changes may break asset references on your site and result in an
Uncaught SyntaxError: Unexpected token
error.
To ensure your assets work across deploys, consider disabling hashed filenames, using permalinks, or using a service worker. For more details and solutions, check out our
official Support Guide on handling code-splitting issues on Netlify
.
#
More build configuration resources
Common framework configurations
Monorepos
Ignore builds
Last updated: March 14, 2024
←
Build configuration
Monorepos
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_manage-dependencies.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/manage-dependencies/
Scraped_At: 2025-06-02T19:56:37.421691

Contact
Forums
Contact support
When you trigger a build on Netlify, our build system starts a Docker container to build your site. Before running your build command, the build system will search for instructions about required languages and software needed to run your command. These are called
dependencies
, and how you declare them depends on the languages and tools used in your build.
Follow the guidelines below to specify your required dependencies, and Netlify will install them before running your build. Any executables from these dependencies will be made available from the PATH for the remainder of the build.
#
Node.js and JavaScript
A build’s Node.js version is initially determined by the
default version
preinstalled on the site’s selected build image. We pin the site to that version so your builds won’t change even if the build image’s defaults change.
You can choose the Node.js version we use to build your site in the following ways:
Navigate to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Dependency management
in the Netlify UI and select from the major Node.js versions that Netlify currently supports. Once you change the version, you need to redeploy your site for it to take effect. Note that a
NODE_VERSION
environment variable,
.node-version
file, or
.nvmrc
file will override this UI setting.
Set a
NODE_VERSION
environment variable
with any released version of Node.js or any valid string that
nvm
understands. You can either set a specific version or set a major version, such as the number
22
for the latest version of Node.js 22.x.
Add a
.node-version
or
.nvmrc
file to the site’s
base directory
in your repository. The file can include any released version of Node.js or any valid string that
nvm
understands. You can either set a specific version or set a major version, such as the number
22
for the latest version of Node.js 22.x.
The version of Node.js you use is dynamically fetched using
nvm
and then
cached
to speed up subsequent builds.
If you are using the Netlify CLI to run a build locally, make sure the Node.js version installed in your local environment matches the version set for your build on Netlify. If the versions don’t match, you may encounter errors.
What about the Node.js version for functions?
Typically, the functions runtime Node.js version automatically matches the version used for the build. If you need to customize the Node.js version for your functions, use the
AWS_LAMBDA_JS_RUNTIME
environment variable. Visit our docs on
Node.js version for runtime
to learn more.
#
Node.js environment
By default, Netlify’s build system sets
NODE_ENV
to
development
. You can change this value by setting a
NODE_ENV
environment variable
.
Dependencies and production
If you set the
NODE_ENV
to
production
, any
devDependencies
in your
package.json
file will
not
be installed for the build.
#
JavaScript dependencies
If your build requires any JavaScript dependencies, you must list these in a
package.json
saved in the site’s
base directory
in your repository. You can visit the npm docs to learn
how to create a package.json file
.
Tip
If you’re having trouble linking to other repositories in your
package.json
, visit the
repository permissions and linking
doc for more information.
#
npm
npm
comes preinstalled with Node.js, so any build scripts using
npm run
will work automatically. By default, if your site’s repository does not include a
yarn.lock
,
pnpm-lock.yaml
or
bun.lockb
file, we will run
npm install
to install the dependencies listed in your
package.json
.
You can customize your npm use with the following
environment variables
:
NPM_VERSION
:
variable that defaults to the version preinstalled with your version of Node.js. Accepts any released version number.
NPM_FLAGS
:
used to indicate the flags to pass to the
npm install
command. For example, you could pass the
--global
flag to make installed packages available outside your working directory. Learn more about npm flags in the
npm docs
.
NPM_TOKEN
:
used for authentication when installing private npm modules. Visit our Forums for a verified Support Guide on configuration details when
using private npm modules on Netlify
.
#
pnpm
Netlify supports
pnpm
for Node.js 16.9.0 and later.
If your site’s base directory includes a
pnpm-lock.yaml
file, we will run
pnpm install
to install the dependencies listed in your
package.json
.
To specify a pnpm version, you can edit your
package.json
file:
"packageManager"
:
"pnpm@6.3.2"
This tells Corepack to use and download your preferred pnpm version instead of the
default version
that Netlify sets.
Note that based on
Corepack limitations
, you cannot use
semver
to specify a range of versions for this package manager.
In certain scenarios, you must pass additional flags to the
pnpm install
command. For example, some frameworks such as Nuxt 3 and Next.js require that you modify the
pnpm install
command. To avoid import issues with pnpm and these frameworks, use the
PNPM_FLAGS
environment variable and set it to
--shamefully-hoist
.
#
Yarn
Netlify can detect and install
Yarn
and then use it to install your project’s dependencies. If you commit a
yarn.lock
file to your site’s repository or if your
packageManager
property specifies Yarn, Netlify will install Yarn and then run the
yarn
command to install the dependencies specified in your
yarn.lock
file.
By default, Netlify will use the Yarn version preinstalled with your initial
build image
.
Note that based on
Corepack limitations
, you cannot use
semver
to specify a range of versions for this package manager.
To specify a different Yarn version:
You can edit your
package.json
file:
"packageManager"
:
"yarn@3.2.4"
Or, you can leverage Yarn’s way of vendoring a specific version by setting a
yarnPath
inside a
.yarnrc.yml
file
.
yarnPath
:
.yarn/releases/yarn
-
3.2.4.cjs
nodeLinker
:
node
-
modules
You can also customize your Yarn use with the following
environment variables
:
YARN_FLAGS
:
used to indicate the flags to pass to the
yarn
command. Includes
--ignore-optional
by default. You can override this by adding
--no-ignore-optional
to this variable.
YARN_NPM_AUTH_TOKEN
:
used for authentication when installing private npm modules.
NETLIFY_USE_YARN
:
deprecated variable that is supported but no longer recommended; undefined by default. If
true
, Netlify will install and run Yarn. If
false
, we will use npm or pnpm. If left unset, we will run Yarn if the site’s
package.json
specifies yarn as the package manager or if a
yarn.lock
file is present.
YARN_VERSION
:
deprecated variable that is supported but no longer recommended; defaults to the version preinstalled with your initial build image. Accepts any released version number. We recommend setting the version in
package.json
or through a
yarnPath
in
.yarnrmc.yml
instead.
Yarn Berry requires a setting in
.yarnrc.yml
To build your project on Netlify with
Yarn 2.0.0 or later
, you must add
nodeLinker: node-modules
to a
.yarnrc.yml
file
, which is generally stored in your repository root. Netlify depends on the
node_modules
folder tree that’s generated with this setting.
Plug'n'Play
is not currently supported on Netlify.
#
Bun
Netlify can detect when your project is using
Bun
and then use it to install your project’s dependencies. If you commit a
bun.lockb
file to your site’s repository, Netlify will run the
bun install
command to install the dependencies specified in your
bun.lockb
file.
All builds will use the version
pre-installed in our build image
.
You can also customize your Bun use with the following
environment variable
:
BUN_FLAGS
:
used to indicate the flags to pass to the
bun install
command.
#
Bower
If your repository includes a
bower.json
file in the
base directory
, we’ll automatically run
bower install --config.interactive=false
against it to install your Bower dependencies. This is
in addition to
running any other requisite dependency management commands as described in this doc.
#
Go
A build’s initial Go version is determined by the
default version
for the site’s build image. You can change the Go version we use to build your site in the following ways:
Set a
GO_VERSION
environment variable
with any released version of Go. You can also use a partial version, such as
1.20
, to indicate the latest version of
1.20
.
Add a
.go-version
file to the site’s
base directory
in your repository. The file can include any released version of Go.
.go-version
overrides
GO_VERSION
Note that if your site has both a
.go-version
file and a
GO_VERSION
environment variable, the
.go-version
file takes precedence.
We recommend matching your local development environment’s Go version to your selected build image’s Go version. You can use any version of Go that’s available on the
Go downloads page
.
The configured Go version is also used when compiling
Go serverless functions
during the build.
#
PHP
The
default PHP version
is determined by the site’s selected build image.
You can choose the PHP version we use to build your site by setting a
PHP_VERSION
environment variable
. We recommend matching your local development environment’s PHP version to a version that your selected build image supports. For a list of supported versions, refer to the
available software at build time
doc.
#
PHP dependencies
Add your PHP dependencies to a
composer.json
file
. Dependencies listed in
composer.json
are automatically installed with Composer, which is included in all build images.
#
Python
The
default Python version
is determined by the site’s selected build image.
You can choose the Python version we use to build your site in one of the following ways:
Set a
PYTHON_VERSION
environment variable
.
Add a
runtime.txt
file to the site’s
base directory
in your repository. The file must include the version number
only
:
x.y
, with no trailing newline.
Use
Pipenv
to specify a version and save it to a
Pipfile
in the site’s
base directory
in your repository.
runtime.txt
overrides
Pipfile
If the site’s base directory includes both a
runtime.txt
file and a
Pipfile
, Netlify will use the version specified in
runtime.txt
.
The
list of supported versions
depends on the site’s selected build image.
#
Python dependencies
If your build requires any Python dependencies, you must provide a list of these for installation using
pip
or
Pipenv
.
#
Install using pip
If you manage your Python dependencies using
pip
, you can generate a list of them by running the following command in the site’s
base directory
in your repository:
pip freeze
>
requirements.txt
This creates a
requirements.txt
file that Netlify will use to install your dependencies by running
pip install
. Refer to the pip docs for more details about the
requirements file format
.
#
Install using Pipenv
If you manage your Python dependencies using
Pipenv
, be sure to commit your
Pipfile
to the site’s
base directory
in your repository. Netlify will run
pipenv install
to install your dependencies. If you also commit your
Pipfile.lock
, this will ensure that
pipenv install
installs the same exact versions of your dependencies on Netlify as it does locally.
requirements.txt
overrides
Pipfile
If the site’s base directory includes both a
requirements.txt
file and a
Pipfile
, Netlify will run
pip install
to install the dependencies in
requirements.txt
, and ignore the dependencies in the
Pipfile
.
#
Ruby
A build’s Ruby version is initially determined by the
default version
preinstalled on the site’s selected build image. We pin the site to that version so your builds won’t change even if the build image’s defaults change.
You can choose the Ruby version we use to build your site in two different ways:
Set a
RUBY_VERSION
environment variable
.
Add a
.ruby-version
file to the site’s
base directory
in your repository. This will also tell any other developer using the repository which version of Ruby it depends on.
No newlines in
.ruby-version
The
.ruby-version
file must include the version number
only
:
x.y.z
, with no trailing newline.
Both methods above will accept any released version of Ruby, or any valid string that
RVM
understands. We recommend specifying a version of Ruby that matches your local development environment.
If the version you select is preinstalled in your site’s selected build image, it will be available immediately. If not, your selected version will be installed using
rvm
and then
cached
to speed up subsequent builds.
#
Ruby dependencies
If your build requires any Ruby dependencies, you must list these in a
Gemfile
saved in the site’s
base directory
in your repository. We use
Bundler
to install the dependencies in that file. You can visit the Bundler docs to learn
how to manage Ruby dependencies with Bundler
.
If you run the
bundle install
command locally, Bundler will create a
Gemfile.lock
to record the gem names and versions installed. If you commit this file to the site’s
base directory
in your repository, we will install the exact versions specified in your
Gemfile.lock
.
#
Rust
Although
rustup
and
cargo
are preinstalled, Netlify doesn’t install a default Rust toolchain.
You must specify the Rust toolchain used to build your site in one of the following ways:
Add a
rust-toolchain
file to the site’s
base directory
in your repository. This is the recommended option. When a
rust-toolchain
file is present, cargo installs the toolchain when it first executes, for example, on
cargo build
.
Include a
toolchain install
command as part of your site’s build command. Use the syntax
rustup toolchain install <toolchain>
, for example:
rustup toolchain install stable
.
The build image supports any toolchain that rustup can install. The selected Rust toolchain is
cached
to speed up subsequent builds.
Crates
are cached in
~/.cargo/registry
, and compilation assets are cached in
target
if your working directory has a
Cargo.toml
or
Cargo.lock
file.
#
Rust dependencies
Include any Rust dependencies in a
Cargo.toml
manifest file in the base directory in your repository. If you also commit a
Cargo.lock
, this will ensure that cargo installs the same exact versions of your Rust dependencies on Netlify’s build image as it does locally. Dependencies aren’t installed automatically. Instead cargo fetches them when
cargo doc
or
cargo build
executes as part of the build command.
#
Swift
A default Swift version does not come preinstalled on a site’s selected
build image
. Instead, at the time of the first build, Netlify installs your specified Swift version in the build container.
You can choose the Swift version we use to build your site in two different ways:
Set a
SWIFT_VERSION
environment variable
.
Add a
.swift-version
file to the site’s
base directory
in your repository. This will also tell any other developer using the repository which version of Swift it depends on.
Both methods above will accept any Swift version that
swiftenv
can install that is later than Swift 4.x. Versions 4.x and earlier aren’t supported due to incompatible shared libraries. We recommend specifying a version of Swift that matches your local development environment.
Default Swift version
If no
SWIFT_VERSION
environment variable is set and no
.swift-version
file is present but a
Package.swift
file exists in the site’s
base directory
in the repository, Netlify installs a default Swift version determined by the site’s selected
build image
.
Your selected version will be initially installed using
swiftenv
and then
cached
to speed up subsequent builds.
#
Swift dependencies
If your build requires any Swift dependencies, you must list these in a
Package.swift
manifest file saved in the site’s
base directory
in your repository. During the build, our build system runs the
swift build
command, using
Swift Package Manager
to install the dependencies and exact versions specified in
Package.swift
. For more information about managing dependencies with the manifest file, visit the
Swift Package Manager documentation
.
#
Build image defaults
Netlify’s
build images
have default preinstalled versions for many languages and tools. For a full list of defaults and more information on how to manage versions, refer to our
available software at build time
doc.
Not sure what build image your project uses? You can find out in the Netlify UI, by navigating to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build image selection
. You can also find all of the software versions your build uses in your site’s
deploy logs
.
#
Dependency cache
The first build you do can take some time while we install all of your dependencies. After the initial build, we’ll cache the dependencies so we don’t have to install them every time you push an update. This is intended to make subsequent builds faster.
If you change your dependency requirements, the next build will re-run the installation command which may update cached dependencies if needed. It isn’t guaranteed a change will take place if the previous dependencies still satisfy the installer, though! You can check which directories are cached by searching for
$NETLIFY_CACHE_DIR
in the
run-build-functions.sh
file for your site’s selected
build image
.
If a build fails, it’s worth retrying with a cleared build cache to check if this works better. You can do this by
deploying the latest branch commit
with the clear cache option.
Last updated: May 13, 2025
←
Ignore builds
Build environment variables
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_monorepos.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/monorepos/
Scraped_At: 2025-06-02T19:56:38.980385

Contact
Forums
Contact support
Netlify provides flexibility in how you organize and build a site or application. Although some sites are built directly from the root of a repository, we also support those with a more complex setup like monorepos — repositories that contain multiple sites or apps, each in its own subdirectory.
To help you successfully configure sites from a monorepo, Netlify offers both
automatic monorepo detection
and
manual configuration options
. You also have the ability to control the volume of
commit status notifications
and to configure a custom
ignore
command
. This document also outlines our
recommended monorepo setup
.
Using the CLI with a monorepo?
After you set up your site on Netlify, you can use the Netlify CLI’s
--filter
flag to specify which site in your monorepo to run commands on. This way, you can work directly from the root of your project. Learn more about
using the CLI with monorepos
.
#
Definitions
To deploy a site from a monorepo, you may need to set or use the following:
Base directory:
directory where Netlify checks for
dependency management
files such as
package.json
or
.nvmrc
, installs dependencies, and runs your build command. The build system will use this directory to perform caching during the build process. If not set, the base directory defaults to the root of the repository.
Site files:
source files in your repository that represent the code for your site and any related configurations. Also known as your site’s package.
Package directory:
typically used for monorepos, the directory that contains your site files, including the
netlify.toml
. Set this only if the location is different from the base directory. Learn more about how Netlify searches for your
configuration files in monorepos
.
Build command:
the command to run to build your site if you are using a static site generator or other build tool. For example,
npm run build
. The build command runs in the Bash shell, allowing you to add Bash-⁠compatible syntax to the command.
Visit the
frameworks
doc to learn about typical build commands for popular tools.
Publish directory:
directory that contains the deploy-ready HTML files and assets generated by the build. The directory is relative to the base directory, which is root by default (
/
). Visit the
frameworks
doc to learn about typical publish directories for popular tools.
Only files in the publish directory are deployed
Files and assets located outside of the publish directory won’t be included in site deploys.
Netlify configuration file:
optional configuration file (
netlify.toml
) that specifies how Netlify builds and deploys your site — including redirects, branch and context-specific settings, and more. Learn more about
file-based configuration
.
#
Automatic monorepo detection
When you
create a new site from an existing repository
, Netlify automatically scans the repository to detect if you are using a monorepo.
If Netlify detects multiple sites in your repository, the Netlify UI displays a list of the sites and directories for you to select under
Site to deploy
.
Once you select a site to deploy, Netlify automatically fills in the
Build command
and
Publish directory
based on that selection.
Netlify also uses this selection to set the
Package directory
, and leaves the
Base directory
unset. You can review both fields under
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
after you finish setting up your site. As the
Base directory
is not set, Netlify uses the root of the repository as the default to install dependencies and build your site.
If the site you wish to deploy isn’t automatically detected, select
Other (configure manually)
in the list and you can
manually configure the site
instead.
#
Manual configuration
If your site isn’t automatically detected, Netlify offers you the option to manually set the
base directory
,
package directory
,
build command
, and
publish directory
for your site. While there are multiple ways to set each of these values, the
recommended method
may differ depending on your project setup.
#
Set the base directory
Want to run builds for your monorepo in root?
To install dependencies and run builds in the root directory of your monorepo, you don’t need to set the base directory. Netlify uses the root of the repository as the default. If your Netlify configuration file is located with your project in a directory other than root, you can specify the location with a
package directory
.
If not explicitly set, the
base directory
defaults to the root of the repository. If you want to install dependencies and build your site in a subdirectory rather than root, you can specify this by setting a base directory.
For example, if your repository has a monorepo workspace set up in a
/frontend
directory and other unrelated code in a
/backend
directory, you likely want to set your base directory to
/frontend
instead of root (
/
).
You can set a base directory in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing site, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
stored at the root of your repository. Use the
base
property under
[build]
settings, and Netlify will use that value to set the base directory when you first set up the site.
if you’re creating a
Deploy to Netlify
button for other people to easily clone and deploy your site, use the
base
query parameter
to set the base directory for that button. You can create different buttons for each site in your monorepo by setting a different
base
value for each button.
A base directory specified in a root-level
netlify.toml
overrides the UI setting.
#
Set the package directory
If you use a
monorepo
and store your
site files
in a different directory from your base directory, you can specify the location using the
Package directory
field in the Netlify UI.
This is helpful if you want to install dependencies and run builds in the root but want to store your site’s source files, including the  corresponding
netlify.toml
, in separate project directories. If you don’t set this value, Netlify will
search for the
netlify.toml
in the base and root directories.
In addition, if you don’t
set an explicit publish directory
, Netlify uses the package directory to search for the directory that contains the output of your build (for example, a
dist
folder) and any related
_headers
and
_redirects
files within that directory.
To set the package directory for a site:
Navigate to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
Select
Configure
.
Enter the
Package directory
. For example,
/packages/website
.
Select
Save
.
#
Set the build command
You can manually set the
build command
in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing site, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
. Use the
command
property under
[build]
settings. Learn more about
file-based configuration
.
using
Netlify CLI
when setting up continuous deployment for a site.
To find the typical build command for your framework, refer to the
frameworks
doc.
#
Set the publish directory
You can manually set the
publish directory
in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing project, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
. Use the
publish
property under
[build]
settings. Learn more about
file-based configuration
.
using
Netlify CLI
when setting up continuous deployment for a site.
To find the typical publish directory for your framework, refer to the
frameworks
doc.
#
Use a Netlify configuration file
You can configure most build and deploy settings for your site using a
Netlify configuration file
instead of the Netlify UI. Note that the
package directory
can only be set in the Netlify UI.
Depending on your monorepo project setup, you may have one or more Netlify configuration files in your repository. The best practice is to have one Netlify configuration file for each site, where the settings in each file are unique to that site. Settings in a root configuration will apply to all sites in your monorepo.
Netlify needs to know which files to use for your site build. You can either explicitly
set the location
of the site’s configuration files or rely on Netlify to find it in
either your base or root directory
.
For a sample
netlify.toml
file, refer to the
file-based configuration
docs. For an example monorepo file structure that includes a different configuration file for each site, refer to the
recommended monorepo setup
section below.
Use absolute file paths in the
netlify.toml
To specify the location of plugins, functions, or other configuration details in
netlify.toml
for a site in your monorepo, use absolute paths that are relative to the base directory. If not set, the default value for the base directory is the root (
/
).
For example, if the site’s base directory is
/frontend
, the site’s package directory is
/frontend/packages
, and the plugin is within
/frontend/packages/my-app/plugins
, the configuration file should specify the plugin location as
/packages/my-app/plugins/netlify-plugin-check-output-for-puppy-references
.
#
How Netlify finds your configuration files
Netlify will search for configuration files in the following order:
Package directory
Base directory
Root directory
#
Commit status notifications
You can manage the amount of commit status and commit check notifications for projects where one repository builds multiple applications. These types of
deploy notifications
are available on commit lists and pull/merge requests for Netlify sites connected to GitHub or GitLab and are also referenced as Commit status webhooks.
For your Netlify team, go to
Team settings
>
Notifications
>
Commit status webhooks
and select
Edit commit status webhooks
.
Choose one of the following options:
Multiple webhooks per repo:
enables commit statuses and commit checks for multiple sites linked to a repository.
One webhook per repo:
limits commit checks and commit statuses in a pull/merge request or commit list to one linked site only, regardless of the number of sites linked to a repository.
#
Recommended monorepo setup
Whether you want to build a single site from a monorepo or multiple sites from a monorepo, the recommendations are the same:
Set the subdirectory that contains the site you want to deploy as your
package directory
. If you have custom configuration settings for the site in a
netlify.toml
, ensure the file is in the same directory.
Leave the base directory as the default, the repository root (
/
).
Define all dependencies at a more specific, subdirectory level, and leave dependency management up to the tool you’re using.
For example, if you have a monorepo with a site that uses React and a component library that also uses React, you should list
react
as a dependency in
package.json
files within each subdirectory. With a Yarn workspace, for example, Yarn can hoist dependencies dynamically, moving them to the root of the repository whenever it makes sense to do so.
#
Example monorepo setup
Here’s an example directory structure for a monorepo that contains a component library and two sites to be hosted on Netlify:
/
├─ apps/
│  ├─ app-1/
│  │  ├─ package.json
│  │  ├─ netlify.toml
│  │  ├─ ...app-1-source-files
│  ├─ app-2/
│  │  ├─ package.json
│  │  ├─ netlify.toml
│  │  ├─ ...app-2-source-files
│
├─ other-packages/
│  ├─ component-library/
│  │  ├─ package.json
│  │  ├─ ...component-library-source-files
│
├─ package.json
There is a subdirectory for each site that contains the source files for that site and a
netlify.toml
with site-specific configurations. All necessary site dependencies are declared in
package.json
files within each subdirectory, and the root-level
package.json
is used to define a Yarn or npm workspace.
In this example scenario, you would
create
two separate Netlify sites linked to the monorepo. If Netlify
automatically detects
that you are using a monorepo during the set-up step for each site, you can select the directory to deploy in the Netlify UI and Netlify will configure the build settings for you.
If you need to
configure the sites manually
, you can use the Netlify UI to set the
package directory
for each site to point to the site’s subdirectory within the monorepo. Leave the base directory unset for Netlify to use the repository root as the default value.
For example, the package directory for the
app-1
site should be
apps/app-1
and the base directory should be unset. Based on this configuration, Netlify will access the site’s source files and configuration files from
apps/app-1
and will run the dependency installation and build command in the repository’s root (
/
).
By default, any changes in the base directory (the repository root, by default) trigger a build of all connected sites. If you would like to only trigger site builds when a change occurs in the site’s subdirectory, you can add a custom
ignore builds command
to the site’s
netlify.toml
file.
No special configuration required if you declare dependencies at both the root and subdirectory level
Most package managers, such as Yarn and npm, are context-aware now. This means that they can run in the root directory and manage dependencies declared in subdirectories as needed. In addition, Netlify’s build system caches all
node_modules
directories within the repository, regardless of where the dependencies are declared.
#
More build configuration resources
Common framework configurations
JavaScript SPAs
Ignore builds
Netlify CLI - Work with monorepos
Netlify Blog: the Enhanced Monorepo Experience
Example
netlify.toml
file
Last updated: May 13, 2025
←
JavaScript SPAs
Ignore builds
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_on-demand-builders.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/on-demand-builders/
Scraped_At: 2025-06-02T19:56:39.949672

Contact
Forums
Contact support
On-demand Builders are serverless functions used to generate web content as needed that’s automatically cached on Netlify’s Edge CDN. They enable you to build pages for your site when a user visits them for the first time and then cache them at the edge for subsequent visits.
Consider serverless functions with the durable cache instead
For better performance and fewer function invocations, consider using
serverless functions with the
durable
directive
instead of On-demand Builders.
Key characteristics of On-demand Builders:
They are Lambda-compatible serverless functions written
in TypeScript
or
in JavaScript
.
They accept GET requests only.
They don’t provide access to HTTP headers or query parameters from incoming requests.
They are protected from repeated invocations by caching generated pages or assets.
They use the request’s URL path to determine whether to create a new cache object or reuse an existing one. This approach can’t be customized with
cache key variations
.
They use the
response type
to determine whether or not to cache the response.
They support an optional
time to live (TTL)
pattern for configuring caching. They don’t support
cache control headers
.
They buffer responses. They don’t support response streaming.
A new site deploy invalidates the cached responses associated with builders in the same
deploy context
, such as the same Deploy Preview number or the same branch deploy.
On-demand Builders were designed to support Incremental Static Regeneration (ISR) for
Next.js sites using Netlify’s Next.js Runtime v4
.
#
Cached responses
Successful responses, redirection responses, and Not Found responses are cached at the edge and served to subsequent requests. That is, any response with a status code of
2xx
(such as
200
or
201
),
301
,
302
,
307
,
308
, or
404
is cached.
If you use
Time to Live (TTL)
, responses with the above status codes invalidate the cache after the TTL expires.
Responses with any other status codes, such as
500
, are not cached.
#
Create On-demand Builders
To get started, follow our docs to create a Lambda-compatible function
in TypeScript
or
in JavaScript
. Use the synchronous function format, and return a response that can be served as a cached static asset. To convert the function to a builder, use the
builder()
method from the
@netlify/functions
package.
First, add the package to your site dependencies:
npm
install
-D
@netlify/functions
Then, pass your function as a parameter to the
builder()
method and export this method as the
handler
from your function file.
Loading error: Refresh the page to access this code sample
import
{
builder
,
type
Handler
}
from
"@netlify/functions"
;
const
myHandler
:
Handler
=
async
(
event
,
context
)
=>
{
// logic to generate the required content
}
;
const
handler
=
builder
(
myHandler
)
;
export
{
handler
}
;
const
{
builder
}
=
require
(
"@netlify/functions"
)
async
function
handler
(
event
,
context
)
{
// logic to generate the required content
}
exports
.
handler
=
builder
(
handler
)
;
For example, your builder could return a full HTML page or a processed image file. Here’s a “hello world” example:
Loading error: Refresh the page to access this code sample
import
{
builder
,
type
Handler
}
from
"@netlify/functions"
;
const
myHandler
:
Handler
=
async
(
event
,
context
)
=>
{
return
{
statusCode
:
200
,
headers
:
{
"Content-Type"
:
"text/html"
,
}
,
body
:
`
<!DOCTYPE html> <html> <body> Hello World </body> </html>
`
,
}
;
}
;
const
handler
=
builder
(
myHandler
)
;
export
{
handler
}
;
const
{
builder
}
=
require
(
"@netlify/functions"
)
async
function
handler
(
event
,
context
)
{
return
{
statusCode
:
200
,
headers
:
{
"Content-Type"
:
"text/html"
,
}
,
body
:
`
<!DOCTYPE html>
      <html>
        <body>
          Hello World
        </body>
    </html>
`
,
}
;
}
exports
.
handler
=
builder
(
handler
)
;
On success, this builder returns a
200
status code and an HTML page with a “Hello World” message. This successful response is cached at the edge and served to subsequent requests.
If the initial invocation of a builder fails with a status code that is not one of the
cached response codes
, for example because a third-party API is down and the response status is
500
, the erroring response is served but not cached. The next request will retry the builder to get a successful response.
For a working example of using On-demand builders with code to explore, you can visit this
example site
and its corresponding
code repository
.
#
Time to live (TTL)
On-demand Builders support an optional time to live (TTL) pattern that allows you to set a fixed duration of time after which a cached builder response is invalidated. This allows you to force a refresh of a builder-generated response without a new deploy.
You can set a TTL for your builder by including a
ttl
, in seconds, in your response.
ttl
has a minimum value of 60.
Loading error: Refresh the page to access this code sample
import
{
builder
,
type
Handler
}
from
"@netlify/functions"
;
const
originalResponse
=
{
body
:
':thumbsup:'
,
statusCode
:
200
,
ttl
:
3600
,
}
;
const
myHandler
:
Handler
=
async
(
event
,
context
)
=>
{
// logic to generate the required content
return
originalResponse
;
}
;
const
handler
=
builder
(
myHandler
)
;
export
{
handler
}
;
const
{
builder
}
=
require
(
"@netlify/functions"
)
const
originalResponse
=
{
body
:
':thumbsup:'
,
statusCode
:
200
,
ttl
:
3600
,
}
async
function
handler
(
event
,
context
)
{
// logic to generate the required content
return
originalResponse
}
exports
.
handler
=
builder
(
handler
)
;
After the TTL has expired, the next request triggers a builder invocation to regenerate the content. The previously cached response is served for 60 seconds after a refresh is triggered. If the refresh is successful and returns with one of the
cached response codes
, the updated response is cached and served until the next successful refresh. If the refresh fails and returns with any other status code, for example because a third-party API is down, the previously cached successful response is served until the next successful refresh.
#
Confirm request type
Incoming requests to On-demand Builders include a
x-nf-builder-cache
header that indicates whether the request is an initial request for your content or a background refresh request. This gives you the opportunity to add conditional logic to your builder depending on the request type — for example, you might want to serve a loading page while a user waits for an initial request to complete.
To confirm the type of the incoming request, check the
x-nf-builder-cache
header value in the
headers
property of the
event
object. If the header’s value is
miss
, the request is an initial blocking request from the browser that needs to complete before a user can take next steps. If the header’s value is
revalidate
, the request is an asynchronous TTL refresh request that runs in the background.
#
Environment variables
On-demand Builders have access to environment variables in the runtime environment. If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to On-demand Builders during runtime.
Learn more about how to set and use
environment variables with functions
.
#
Use On-demand Builders
Similar to other functions, On-demand Builders can be invoked at endpoints relative to the base URL of your site. Builders, however, use a unique
builders
path for invocation:
/.netlify/builders/FUNCTION_NAME
.
Builder endpoints can be called directly like regular web URLs or can be executed by redirecting traffic from another URL.
For example, consider a news site with a large amount of infrequently visited, archived content. You can use a builder to generate those less-frequented pages on-demand when a user requests them. The request URL might be something like this:
https://myawesomenews.com/.netlify/builders/my-archive-builder/article/199x-news
The first call to the builder invokes it and returns the generated page, assuming that’s the logic in your function. Subsequent calls return the cached page content until the next deploy or until the
time to live (TTL)
has elapsed.
In another example, if you want to replace a static image
src
with a custom-sized image generated using a builder, you can format an
img
tag like this:
<
img
alt
=
"
kittens.
"
src
=
"
/.netlify/builders/my-image-transformer/file/kittens.jpg/width/640
"
/>
The first builder call processes and returns the image, and subsequent calls return the cached image until the next deploy or until the
TTL
has elapsed.
#
Customize paths with redirects
In the example above, you might prefer to use a different URL instead of the default builder endpoint. You can do this by redirecting traffic from a URL to the builder using
redirect rules
in the
_redirects
file or
netlify.toml
Netlify configuration file.
Here are some examples with
_redirects
file
and
netlify.toml
syntax.
Loading error: Refresh the page to access this code sample
/images/*  /.netlify/builders/my-image-transformer   200

/archive /.netlify/builders/my-archive-builder 200
[
[
redirects
]
]
from
=
"/images/*"
to
=
"/.netlify/builders/my-image-transformer"
status
=
200
[
[
redirects
]
]
from
=
"/archive"
to
=
"/.netlify/builders/my-archive-builder"
status
=
200
The original path is passed to the builder as part of the event object. To continue an example from above, a call to
/images/kittens.jpg/width/640
triggers the
my-image-transformer
function with the following values passed to it as part of the
event
:
{
"path"
:
"/images/kittens.jpg/width/640"
,
"httpMethod"
:
"GET"
...
}
For more information about the
event
parameter and the Lambda-compatible Netlify Functions programming model, refer to our docs on
synchronous function format for TypeScript
or
JavaScript
.
#
Redirect workaround for query parameters
On-demand Builders currently don’t process or cache query parameters from redirected paths. In most cases, it’s preferable to embed these parameters into the path directly, but in cases where you don’t control the path, you can re-shape it with an additional redirect rule to the path resolution. The first rule must have a
3XX
HTTP status code
, as that ensures a new URL for our redirects engine to process the second rule, passing your new path to the builder. Here’s an example in
_redirects
syntax:
/generated/image url=:url w=:w /img/:url/:w 301!

/img/:url/:w /.netlify/builders/image 200
#
Shadowing
Redirect rules leverage
shadowing
, which means that they trigger only if there isn’t already an asset at the specified
from
path. This can be useful if your prebuilt assets and content generated by your builder share the same path.
If you prefer to trigger the proxy regardless of the presence of a pre-built asset, you can append
!
to the status code in the
_redirects
file, or add
force = true
in
netlify.toml
.
#
Local development
You can build and test logic like any other function using
Netlify Dev
. When testing locally, however, caching isn’t available.
#
Secure On-demand Builders
You can use the same authentication and authorization strategy as the rest of your Netlify site to secure builders. We recommend using JSON Web Tokens (JWT), roles, and redirect rules for managing granular access. Refer to
our docs on role-based access control
to learn more.
#
Limits
The maximum response payload size for a builder is 6 MB.
Pages or assets generated by On-demand Builders are limited to 10,000 per deploy. For a higher limit, please
contact sales
. If the limit is reached, additional generated pages or assets will have reduced caching and may be regenerated upon subsequent requests.
There is a 30 second execution time limit that results in a timeout.
#
Usage and billing
Requests to builders that return a previously non-cached response count towards your
Netlify Functions usage
for billing purposes. This includes requests per month and run time per month. If a cached response is available and served, no function invocation is made and no usage is incurred against your Netlify Functions allotment.
On-demand Builders execution doesn’t count towards build minutes.
Last updated: April 1, 2025
←
File-based configuration
Build hooks
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_overview.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/overview/
Scraped_At: 2025-06-02T19:56:40.623278

Contact
Forums
Contact support
Netlify lets you link a GitHub, GitLab, Bitbucket, or Azure DevOps repository to a site for
continuous deployment
. Each time you push to your Git provider, Netlify runs a build with your tool of choice and deploys the result to our powerful CDN.
#
Build settings
With continuous deployment configured, you can specify how Netlify will build your site. You can specify these settings when you first
add your site from an existing repository
and anytime afterwards by going to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
Missing
Build settings
?
If
Build settings
aren’t available for your site, you may not have continuous deployment set up. You can
link a Git repository
to enable continuous deployment and access these settings.
For basic site configurations, you may need to
set the build command
and
publish directory
. For more advanced configurations, such as sites that build from a subdirectory of a repository or a monorepo, you may also need to
set the base directory
and
package directory
.
If Netlify automatically detects that your site is a monorepo or uses a framework that Netlify is able to identify, Netlify will automatically fill in some of these configuration fields for you when you first
create your site
. You can update the fields afterwards as needed. Learn more about
commonly used build settings for frameworks
and how to
configure sites from monorepos
.
For public repositories, you can also toggle your deploy log visibility. With continuous deployment, builds are active by default. You can
stop or activate builds
at will for more control of your workflow.
You can also specify some of these build settings and others in a
configuration file
, which allows you to change your settings depending on the
deploy context
. For an example, refer to this
sample
netlify.toml
file
that illustrates how to configure some of the available build settings. The configuration file settings override build settings specified in the UI.
#
Definitions
The following definitions highlight terms related to build configuration. For definitions regarding branches and site deploys, visit the
site deploys overview
.
Base directory:
directory where Netlify checks for
dependency management
files such as
package.json
or
.nvmrc
, installs dependencies, and runs your build command. The build system will use this directory to perform caching during the build process. If not set, the base directory defaults to the root of the repository.
Site files:
source files in your repository that represent the code for your site and any related configurations. Also known as your site’s package.
Package directory:
typically used for monorepos, the directory that contains your site files, including the
netlify.toml
. Set this only if the location is different from the base directory. Learn more about how Netlify searches for your
configuration files in monorepos
.
Build command:
the command to run to build your site if you are using a static site generator or other build tool. For example,
npm run build
. The build command runs in the Bash shell, allowing you to add Bash-⁠compatible syntax to the command.
Visit the
frameworks
doc to learn about typical build commands for popular tools.
Publish directory:
directory that contains the deploy-ready HTML files and assets generated by the build. The directory is relative to the base directory, which is root by default (
/
). Visit the
frameworks
doc to learn about typical publish directories for popular tools.
Only files in the publish directory are deployed
Files and assets located outside of the publish directory won’t be included in site deploys.
Functions directory:
directory that contains function files and optional subdirectories for organizing function files. Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function. Default is
netlify/functions
. The functions directory is relative to the base directory.
Netlify configuration file:
optional configuration file (
netlify.toml
) that specifies how Netlify builds and deploys your site — including redirects, branch and context-specific settings, and more. Learn more about
file-based configuration
.
Deploy log visibility:
privacy level for the
deploy logs
for a site linked to a public repo. The default setting
Public logs
makes deploy logs available to anyone with a deploy detail URL. You can limit deploy log access to site members by selecting
Private logs
.
Active builds:
used to indicate when
builds are active
. Netlify builds your site according to your continuous deployment settings when you push to your Git provider.
Stopped builds:
used to indicate when
builds are stopped
. Netlify will never build your site. You can
build your site locally
instead using Netlify CLI and then publish new deploys manually
with the CLI
or
the API
.
#
Set the build command
You can manually set the
build command
in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing site, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
. Use the
command
property under
[build]
settings. Learn more about
file-based configuration
.
using
Netlify CLI
when setting up continuous deployment for a site.
To find the typical build command for your framework, refer to the
frameworks
doc.
#
Set the publish directory
You can manually set the
publish directory
in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing project, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
. Use the
publish
property under
[build]
settings. Learn more about
file-based configuration
.
using
Netlify CLI
when setting up continuous deployment for a site.
To find the typical publish directory for your framework, refer to the
frameworks
doc.
#
Set the base directory
If not explicitly set, the
base directory
defaults to the root of the repository. If you want to install dependencies and build your site in a subdirectory rather than root, you can specify this by setting a base directory.
You can set a base directory in the following ways:
in the Netlify UI, when you select
Add new project
. For an existing site, you can update the setting at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
in a
Netlify configuration file
stored at the root of your repository. Use the
base
property under
[build]
settings, and Netlify will use that value to set the base directory when you first set up the site.
if you’re creating a
Deploy to Netlify
button for other people to easily clone and deploy your site, use the
base
query parameter
to set the base directory for that button. You can create different buttons for each site in your monorepo by setting a different
base
value for each button.
A base directory specified in a root-level
netlify.toml
overrides the UI setting.
#
Set the package directory
If you use a
monorepo
and store your
site files
in a different directory from your base directory, you can specify the location using the
Package directory
field in the Netlify UI.
This is helpful if you want to install dependencies and run builds in the root but want to store your site’s source files, including the  corresponding
netlify.toml
, in separate project directories. If you don’t set this value, Netlify will
search for the
netlify.toml
in the base and root directories.
In addition, if you don’t
set an explicit publish directory
, Netlify uses the package directory to search for the directory that contains the output of your build (for example, a
dist
folder) and any related
_headers
and
_redirects
files within that directory.
To set the package directory for a site:
Navigate to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
Select
Configure
.
Enter the
Package directory
. For example,
/packages/website
.
Select
Save
.
#
Recommendations for specific setups
Consider the following suggestions based on your project configuration.
If your repository contains only the site you want to deploy, stored in the repository root, Netlify will automatically detect the build settings for you. In most cases, you can proceed with these default settings. But, if you do need to manually configure any settings, these would likely be the
build command
and the
publish directory
.
If your site is a
monorepo
, Netlify will automatically detect each site directory in your repository and configure the build settings automatically based on the site you select. But, you also have the option to manually configure the build settings. For monorepos, this will include setting the
package directory
. Refer to our documentation on the
recommended monorepo setup
to learn more.
If you have a larger repository that includes more than just your site files, you may need to deploy a self-contained site or monorepo workspace from a specific subdirectory. For example, a documentation site from the
/docs
subdirectory of your Python library. Or, a monorepo workspace set up in a
/frontend
subdirectory. To work from a specific subdirectory, update the
base directory
. The
publish directory
is relative to the base directory by default.
For larger repositories and monorepos, note that you can customize the default
ignore builds
behavior to determine whether or not your site builds as changes are made.
#
Build image selection
When a build is triggered on Netlify, our build system starts a Docker container running a build image. The build image is a snapshot of an operating system that has
various software tools and other settings
preinstalled and configured.
Although all new Netlify sites use a default build image, you may be able to select from multiple images with different operating system and software versions. You might choose a different build image to meet a software requirement for your build tool, to try out experimental pre-release build features, or to keep up-to-date with the included operating system environment. Build image selection also enables Netlify to release breaking changes into the build image while allowing you to accommodate those changes with time to upgrade.
We recommend upgrading to the most recent build image regularly to take advantage of the latest features and security enhancements.
To change the build image for a site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build image selection
, and select the build image you would like to use. Our build system will use this image for all production deploys, branch deploys, and Deploy Previews.
#
Build image defaults and project dependencies
Each build image has a set of
software with pre-defined default versions
. You can
customize these defaults
.
During your project’s first build, we pin a version of
Node
,
Ruby
,
Go
, and
Yarn
that matches the default version installed on the build image. These pinned versions are stored in your project’s repository object, associating those pinned versions with your project’s Git repository. This ensures your project’s software versions will not be affected if the build image’s defaults change.
#
More build configuration resources
Common framework configurations
Monorepos
JavaScript SPAs
Ignore builds
Manage build dependencies
Build environment variables
File-based configuration
Example
netlify.toml
file
On-demand Builders
Build hooks
Stop or activate builds
Build troubleshooting tips
Available software at build time
Private Connectivity
Compiled build and deploy resources - start here!
Last updated: May 13, 2025
JavaScript SPAs
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_stop-or-activate-builds.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/stop-or-activate-builds/
Scraped_At: 2025-06-02T19:56:41.457303

Contact
Forums
Contact support
If your site is linked to a Git repository, Netlify will by default build your site according to your continuous deployment settings when you push to your Git provider. You can
stop builds
for your site at will for more control of your workflow. When you’re ready for Netlify to build your site again, you can
activate builds
.
For example, you might:
stop builds while you use a continuous integration tool to run validations and then activate builds after all validations are successful.
stop builds while you’re sequentially pushing many small commits in response to review feedback on a pull/merge request and then activate builds before you push the last commit.
stop builds as part of implementing a content freeze and then activate builds when the freeze is over.
Stop builds vs. stop auto publishing
When you stop builds for a site, you prevent Netlify from building production deploys, Deploy Previews, and branch deploys. If you only want to stop new production deploys from being published, you can
stop auto publishing
.
#
Stop builds
To stop builds for a site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
, select
Configure
, and then toggle
Build status
to
Stopped builds
.
When builds are stopped, Netlify will never build your site.
If you push to your linked repository, Netlify will not build production deploys, Deploy Previews, or branch deploys.
If requests are sent to build hook URLs, Netlify will not build your site.
You will not be able to trigger a build of your site with the Netlify API. Any POST requests to
/api/v1/sites/{site_id}/builds
will return an error message.
You will not be able to build your site using the Netlify UI. On the
Deploys
page, the
Trigger deploy
button will be unavailable. On the detail page for a past deploy, the
Retry with latest branch commit
button will be unavailable.
Tip
You can still update your site by
running a build locally
with the CLI and then creating a deploy manually with the
CLI
or the
API
.
Netlify will send a notification email to let any other site members know that builds are stopped for the site. There will also be warnings in these locations in the Netlify UI:
your team’s
Sites
page.
the
Site overview
page.
the site’s
Deploys
page.
Site configuration
under
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
.
Relinking the Git repository will activate builds
If you
unlink
and then
relink
your site’s repository or
link to a different repository
, builds will be activated as part of the new configuration.
#
Activate builds
By default, builds are active. If builds have been stopped for a site, there are multiple ways you can activate them. You can:
go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
, select
Configure
, and then toggle
Build status
to
Active builds
.
go to the
Site overview
page and use the
Activate builds
button.
go to the site’s
Deploys
page and use the
Activate builds
button.
Activating builds does not trigger a build
Netlify does not immediately build your site when you activate builds. After you activate builds, Netlify will build your site when you push to your Git repository, trigger a build hook, POST to
/api/v1/sites/{site_id}/builds
, or trigger/retry a deploy using the Netlify UI.
Netlify will send a notification email to let any other site members know that builds have been activated for the site.
Last updated: May 13, 2025
←
Build hooks
Troubleshooting tips
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- configure-builds_troubleshooting-tips.txt --------
Start of file
URL: https://docs.netlify.com/configure-builds/troubleshooting-tips/
Scraped_At: 2025-06-02T19:56:42.273321

Contact
Forums
Contact support
This article provides troubleshooting tips for failing builds in Netlify’s build service.
Get suggested solutions for failed builds
To help you fix failed deploys, Netlify offers AI capabilities that diagnose and suggest solutions for deploy failures and build errors so you can get back to shipping code.
Learn more about Netlify’s AI capabilities to
give solutions for failed deploys
.
#
Best practices for troubleshooting your build
In case your build fails on Netlify,
first make sure it builds locally in your own development environment.
This is a prerequisite to all of the below suggestions.
If your build works locally,
the next debugging step is to ensure the package versions we use to build match yours.
You can find the settings for these in the
dependency management
doc. That’s the leading cause of build failure.
Once you’ve considered the most frequently encountered issues listed below, there is some additional reading linked at the bottom of this article which may help you debug in more depth or find answers to less commonly asked questions.
To understand the available software and tools that Netlify supports during a build, check out the
available software at build time
.
#
Command not found
If your build fails with
jekyll: command not found
or
gulp: command not found
or anything in that pattern, it means that the software required for that command hasn’t been installed in your build.
You can tell the build system to install the software you need by including the proper configuration file, like a
Gemfile
for Ruby programs like
jekyll
, or
package.json
for Node programs like
gulp
.
Check out the
dependency management
doc for more details on how to tell us to install your toolchain. Once we find your configuration file, we’ll automatically use it before trying to run your build command.
Note that by default the build system looks for the configuration file in your site’s
base directory
, which is the
root of your repository
by default. If your configuration file is located in a subdirectory, you will need to change your folder structure or
set the site’s package directory
to specify the location.
#
Unexpected 404 page errors
If your site unexpectedly serves a 404 page error, there can be several reasons why. For instance, if your geographic area or IP address is blocked from a site, then you will only see a Netlify-branded 404 page. Learn more about
Firewall traffic rules
.
For more possibilities and troubleshooting help, check out our verified
Support Forums guide on unexpected 404 page errors
.
#
Build command named
build
Don’t name your build command
build
in our production build environment. This will fail and give you a strange build log.
#
Build fails with
exit status 128
Typically this means that we don’t have permission to clone the repository you are trying to deploy. The usual cause for this is that someone made some changes to settings for the parent organization, or repository, some time after linking the repository to your site.
We only have permission to create a copy of your code when you link the repository. If you are seeing your build fail with
exit status 128
in the deploy log, relinking your repo using our UI is a good first attempt to fix things (go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
, select
Manage repository
, then
Link to a different repository
). If you do this, please check your webhook settings at your Git provider to be sure you don’t have any duplicate Netlify webhooks.
Permission levels
Your GitHub, GitLab, Bitbucket, or Azure DevOps user account may not have the privilege level required to link the repo to Netlify, even if you can log in and access it from the Git host’s website. You generally need administrative privileges on the repository, owning organization, or both. Related:
documentation about repository permissions and linking
.
#
Build fails on warning message
In some cases, a build may fail due to a warning message that would not cause a build failure when run locally. This is because some libraries and build tools handle warnings differently when they detect that they are being run in a Continuous Integration (CI) environment.
Like many other CI tools and platforms, Netlify sets a build environment variable,
CI=true
, as a convention to indicate that your build is running in an automated environment. Many libraries use the presence of the
CI
variable to trigger changes in their behavior, such as removing progress spinner animations or user prompts. In some cases, a library may also choose to treat warning messages as errors, failing the build.
Generally, libraries that choose to fail on warnings presume their users will want to fix the issues causing the warnings. If this isn’t practical for your use case, you can override the
CI
variable by adding
CI=''
to the beginning of your site
build command
. For example:
CI='' npm run build
“False” isn’t always false
Though it seems like the logical opposite of
CI=true
, setting
CI=false
may not work as expected. This is because environment variable values are processed as strings, and many libraries interpret
any
non-empty string value for
CI
as
true
.
#
Build fails on peer dependency conflict
Due to
behavior in npm 8.60 through 8.12.1
, you may find
Could not resolve dependency
or
Conflicting peer dependency
warnings in your Netlify deploy log that ultimately result in a failing build. This problem occurs mainly for sites using React 17 or later with Node 16.5.1 or later. To resolve this situation, set the
NPM_FLAGS
environment variable
to pass either
--force
or
--legacy-peer-deps
to the
npm install
command that Netlify runs at build time.
#
Case sensitivity
If you develop on Windows or OSX, and your code includes something like
jQuery/jquery.js
— the Netlify build may fail as the file system used in Netlify builds is case sensitive while your build environment is not. The error messages that result may not clearly indicate this!
To effectively change case of a file stored in Git from your case insensitive local environment, it may be necessary to
git mv
or
git rm
and then add the file again, as renaming and committing will not have the desired effect.
#
Large files or sites
Files over 10 MB in size are not well-supported by our CDN and may fail to upload to our system, causing your entire deploy to fail. You should host large content elsewhere, such as YouTube embedded videos.
Sites with tens of thousands of html files can lead to long processing times. This shouldn’t cause the deploy to fail, but even a “quick” manual deploy can take quite awhile (many minutes) to finish if you have tens of thousands of files.
#
Post processing
There are some situations during build that may lead to a failure in post processing — many things that fail will lead to a retry; if after 4 retries it still hasn’t worked, we fail the deploy. You’ll probably need to
contact support
in this case to get more details about the error.
Redirects or Custom header rules
that we can’t process at all are mentioned near the end of the build log and in the Deploy Summary for a deploy, but will
not
cause the build or deploy to fail.
#
Build cache
In order to make builds run faster, we cache certain directories created when we
install your dependencies
. You can check which directories are cached by searching for
$NETLIFY_CACHE_DIR
in the
run-build-functions.sh
file for your site’s selected
build image
.
If a build fails, it’s worth retrying with a cleared build cache to check if this works better. You can do this by
deploying the latest branch commit
with the clear cache option.
#
Enqueued builds
Builds may be enqueued for any of the three reasons described below. Visit our Forums for a verified Support Guide on reducing build queueing by
optimizing
what
you build
.
System queue.
Builds enter a system queue when the number of builds across all customers exceeds the current capacity on the build network. This triggers an increase in system capacity, so enqueued builds may start building as capacity increases as well as when other builds complete. To learn how to reduce your team’s exposure to system build queues,
contact sales
.
Team queue.
Builds enter your team queue when the number of concurrent builds across all sites on your team exceeds your team’s
build capacity
. Such builds appear in your team’s
Builds
page
with the label:
Enqueued: Awaiting Capacity
. You can select the
Manage build capacity
button on that page to increase team build capacity. If you have a build that you’d like to build right away, you can
prioritize
it.
(This feature is available on Enterprise
plans
.)
You can also
cancel
unneeded team builds to move other builds up in the queue.
Context queue.
When multiple builds are triggered on the same site, in an
identical
deploy context
(such as the same Deploy Preview number, or the same branch deploy) these builds enter a context queue to ensure they complete sequentially. When the current build completes, the newest enqueued build of identical context begins, skipping any others in the same context queue. To start the newest enqueued build in a given context, you can
cancel
the current active build of identical context.
#
Organization-owned private repository
If you have a Core Starter plan site connected to an organization-owned private GitHub repository, your builds will fail. You can resume deploys by taking one of these steps:
Upgrade your team plan
.
Deploy manually using the
CLI
,
API
, or
drag and drop
. You can
unlink the repository
from your site to remove UI warnings and enable drag and drop.
Transfer the repository
to a GitHub personal account.
Change the repository visibility
to public.
If you change your GitHub repository settings, you must push a commit for Netlify to receive the new settings in the triggered deploy hook.
#
Error:
Uncaught SyntaxError: Unexpected token
The
Uncaught SyntaxError: Unexpected token
error most commonly happens when your site’s code refers to an asset that’s no longer available.
If your SPA (single-page application) uses code splitting or hashed filenames with our atomic deploys, filename changes may break asset references on your site and result in this error.
To ensure your assets work across deploys, consider disabling hashed filenames, using permalinks, or using a service worker. For more details and solutions, check out our
official Support Guide on handling code-splitting issues on Netlify
.
#
Error:
Page not found
If your site returns a
Page not found
error after you’ve deployed, then we recommend you  check your deploy settings in the Netlify UI to confirm if you are publishing your site from the right folder.
For your site, go to
Configuration
>
Build & deploy
>
Build settings
.
For more troubleshooting help, check out our
official Support Guide for the
Page not found
error
.
#
More resources
If your issue doesn’t seem to be addressed above, you can visit our
Support Forums
to browse posts about common issues or start a new discussion. You can also visit our
compilation of verified Support Guides on builds and deploys
.
Many questions about specific build scenarios have also been
asked and answered on StackOverflow
.
Last updated: May 13, 2025
←
Stop or activate builds
Available software at build time
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_access-data.txt --------
Start of file
URL: https://docs.netlify.com/connect/access-data/
Scraped_At: 2025-06-02T19:56:43.462327

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
Netlify Connect makes it easy to access data from different data sources and types. Instead of having to make multiple API calls to retrieve data from each source, configure
cross-references
and make a single query to your data layer’s unified GraphQL API.
Plus, when you connect a site to your data layer, Netlify will automatically rebuild that site when a data source updates. For static sites, this ensures your site has the latest data from your GraphQL API.
Which data revision is the data layer’s GraphQL API using?
At the top of the data layer’s overview page, you will find information about the
data revision
that your data layer’s GraphQL API is currently using — including the data revision ID and whether or not the API is using a pinned revision.
This document outlines some
GraphQL concepts
, how to use the
GraphQL sandbox
, how to access data using the
GraphQL API
, and how to use the
Connect client
for a better user and developer experience.
#
GraphQL concepts
Every data revision for a data layer has a unique
GraphQL schema
that you use to build your data queries. Netlify automatically generates a new data revision to represent the latest schema whenever your data changes.
By default, the GraphQL API and sandbox for your data layer will use the latest data revision unless you pin a different revision. You also have the option to query a specific dataset using the revision’s unique sandbox and API URL.
You can use standard GraphQL queries and fragments to interact with your data. Note that mutations are not currently supported.
Queries
: how you get data.
Fragments
: reusable sets of fields.
Regex is not currently supported
While the GraphQL sandbox includes a regex option for filtering, regex is not currently supported in queries made in the sandbox or made directly to the GraphQL API.
#
Queries and edge caching
Connect automatically caches data at the network edge by default. Other than factoring in the query size limitation, noted below, there is no need to write queries a specific way to enable caching.
The cache key is the combination of the query + variables + API token used for that query.
If the body of your query (the GraphQL query plus the variables) is larger than 9 KB, the response will not be cached at the edge. You can calculate the size of your query body using a library such as
string-byte-length
. If your query body is larger than the limitation, you can
adjust your queries to add pagination
to ensure the responses are cached.
Note that edge caching does not apply to queries made in the GraphQL sandbox.
#
Query complexity
To help you consider performance while you write your queries, please note the following calculation that we use for query complexity in Connect.
If you are able to keep the complexity level to under 1,500 points, you should not expect a notable performance impact.
Calculated from request body (GraphQL query + schema):
Find many query: 10 points
Find one query: 5 points
Scalar field: 1 point
Non-scalar field: 3 points
Extra points per field:
Reference field: 5 points
List field: 5 points
Union field: 3 points
Calculated from response body:
Objects: 1 point per obj
Response size: 5 points per kb
#
Use the GraphQL sandbox
The GraphQL sandbox is an isolated environment in the Netlify UI that you can use to build and test GraphQL operations without directly affecting your sites. Netlify creates a unique
GraphiQL
sandbox for each data layer that you create, and for each data revision that results from a successful data sync.
Note that, although you query the GraphQL API from individual sites, the sandbox is only accessible from your team’s Connect page. Also, any queries you create in the sandbox have to be copied into your code manually.
Use the Connect client to write queries directly in your editor
Use the
Connect client
to write queries in your code editor and benefit from in-editor feedback, auto-completion, and type hints based on your data layer’s GraphQL schema.
To access the GraphQL sandbox for a data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer overview page, select
GraphQL sandbox
.
This sandbox represents the data revision that your API is currently using.
To access the GraphQL sandbox for a specific data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer‘s overview page, select
Revisions
to access the list of available revisions.
Find the revision you want to access, select
Options
, and then select
Open in GraphQL sandbox
.
At the top of the sandbox, you’ll find the ID of the data revision that the sandbox is using and when that revision was created. There is also an options menu that you can use to pin or unpin the data revision, download the changeset, and copy the data revision’s GraphQL sandbox link or API URL.
The sandbox consists of three main areas:
In the left pane, the sandbox menu and sub-sections, including:
the GraphiQL explorer, which contains schema fields and types that you can expand and select to build queries with
the documentation explorer, which contains the
schema reference docs
for the data revision
the sandbox history, which contains previous queries you have created and automatically
saved
In the center pane, the area that you build the query in and buttons to run, copy, prettify, and merge fragments into the query.
In the right pane, the area that will contain the output when you run a query.
#
Review the GraphQL schema
The sandbox includes a documentation explorer that contains the schema reference docs for that data revision. The explorer makes it easy to review the combined GraphQL schema for the data revision that was made while syncing all of the GraphQL types from your data sources.
If you have added multiple data sources of the same type, such as two Drupal instances, you will notice the type prefix for each source reflected in the schema. This is helpful to know as you start building your queries.
To review the schema in the GraphQL sandbox, select the book icon (labeled “Show Documentation Explorer” for screen readers) to open the documentation explorer and access the reference docs. You can select each type to learn more about all of the included Object types and fields.
#
Build and run a query
To build a query using the GraphQL schema for a data revision, you have two options:
Toggle open the types in the GraphiQL explorer to find the fields to add to your query. Select items as needed and the query in the center section of the sandbox will update to include your selection.
Enter your query directly in the center pane. As you write the query, the sandbox will suggest fields to add based on the schema. You can continue typing or just select the correct suggestion to add it to your query.
You can add more specificity to your query by selecting the
filter
,
limit
,
skip
, and
sort
options in the explorer and then entering the logic for your modifier either in the left pane or the center pane.
To run the query, press
control
+
enter
or select the play icon (labeled “Execute query” for screen readers) in the center pane. The query results will appear in the pane on the right.
Once you have a query that works for you, copy the query into your codebase and
use the GraphQL API
to request and access this data in your site.
#
Save queries for later
When you use the GraphQL sandbox, we automatically save the queries in the sandbox so that you can return to them later. You can find old queries by selecting the history icon (labeled “Show History” for screen readers) in the left pane to open the sandbox history section.
Since the sandbox uses your browser’s
localStorage
to save the queries, saved queries are only be available to you and in the browser you create them in. Other team members do not have access to your saved queries when they use the sandbox.
Note that saved queries will appear across all versions of the sandbox but the query will only run against and return data for the associated data revision. To confirm which data revision you are querying against, check the data revision ID at the top of the sandbox.
To clear all saved queries, select the settings icon (labeled “Open settings dialog” for screen readers) in the bottom left to open the sandbox settings. Then, under
Clear storage
, select
Clear data
.
#
Use the GraphQL API
To use data in your site, add code that sends a query to the data layer’s GraphQL API.
By default, your data layer’s GraphQL API uses the latest data revision unless you pin a different one. You also have the option to query a specific data revision using the unique API URL for that revision.
For the most part, the code to query a GraphQL API is the same whether you query in a component file or in a function. But, depending on where you query the API, you need to set up your data layer correctly to ensure your site always has access to the latest data. Learn more about
when to connect your site
.
Once you have the
GraphQL API URL
and an
API token
, you can write your query. We recommend using the
Connect client
for in-editor type system support and caching optimizations, but there are a number of other
tools you can use to query
. The examples below use the Connect client.
Use the GraphQL sandbox or Connect client to verify types
If you specify a prefix while adding a data source to your data layer, the prefix is added to all types synced from that data source. This impacts the types you use in your queries. You can confirm what the final types are in the
GraphQL sandbox
or by using the
Connect client
.
#
Generate an API token
You must authenticate all requests to your data layer’s GraphQL API using an
API token
. If your data layer restricts access to certain fields and types using
API scopes
, the API token must have the required scopes to access that data.
Make sure to include the API token in the authorization header for all API requests. If you use the
Connect client
, you can store the token in an environment variable and the client will automatically apply it for you.
Learn how to generate API tokens and scopes in the
API authentication
doc.
#
Find the GraphQL API URL
By default, your data layer’s GraphQL API uses the latest data revision unless you pin a different one.
The API URL is formatted as
https://{data_layer_key}-prod.api.netlify-connect.com
. Note that the data layer key is different from the data layer ID.
To find the GraphQL API URL for your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
Find the
API URL
at the top of the page.
You can also find the
API URL
under
Data layer settings
>
General
>
Data layer information
.
If you want to access the GraphQL API for a specific data revision, use the API URL for that revision. Learn how to
access the API for a specific data revision
.
#
Query in site code
Use Connect client if your site uses SSR with caching
For sites that use server-side rendering (SSR) with caching, we recommend querying your data layer’s API with the
Connect client
to benefit from more efficient caching of dynamic content.
It doesn’t matter if your site uses static site generation (SSG) or uses server-side rendering (SSR), the code to query the API is the same.
Here is an example that uses
Connect client
in an Astro project to query the API for the
id
and
title
of the first 10 nodes under
allContentfulAsset
.
Follow the three steps to
configure the Connect client
. Make sure to create
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables with the URL and API token for your data layer’s GraphQL API.
Depending on the architecture of your app, add the following code to the appropriate file to request data before your component is rendered. Make sure you update the query to reflect your schema.
Loading error: Refresh the page to access this code sample
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../netlify-connect/graphql"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id
           title
         }
       }
     }
`
)
;
const
getAssets
=
async
(
Astro
:
any
)
=>
{
const
res
=
await
query
(
assetQuery
,
{
Astro
}
)
;
return
res
.
allContentfulAsset
.
nodes
;
}
;
const
assets
=
await
getAssets
(
Astro
)
;
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../netlify-connect/graphql"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id
           title
         }
       }
     }
`
)
;
const
getAssets
=
async
(
Astro
)
=>
{
const
res
=
await
query
(
assetQuery
,
{
Astro
}
)
;
return
res
.
allContentfulAsset
.
nodes
;
}
;
const
assets
=
await
getAssets
(
Astro
)
;
When you query, the Connect client automatically accesses the
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables stored on Netlify and adds their values to the API request header for you.
Update your component code to use the results returned from the query (
assets
in the above example).
To ensure your site always has access to the latest data, review our doc on
when to connect your site
.
#
Query in a function
Here is an example of how to query the API in a function. Every request to this endpoint receives the latest results from the API.
This example uses
Connect client
to query the API for the
id
and
title
of the first 10 nodes under
allContentfulAsset
.
Follow the three steps to
configure the Connect client
. Make sure to create
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables with the URL and API token for your data layer’s GraphQL API.
Create a function file
in the functions directory. For example,
YOUR_BASE_DIRECTORY/netlify/functions/get-data.js
.
In the file, add the following code to create a function that queries the API and returns the data. Make sure you update the query to reflect your schema.
Loading error: Refresh the page to access this code sample
// YOUR_BASE_DIRECTORY/netlify/functions/get-data.ts
import
type
{
Context
}
from
"@netlify/functions"
;
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../../src/netlify-connect/graphql"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id
           title
         }
       }
     }
`
)
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
data
=
await
query
(
assetQuery
)
;
return
new
Response
(
JSON
.
stringify
(
data
)
)
;
}
;
// YOUR_BASE_DIRECTORY/netlify/functions/get-data.js
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../../src/netlify-connect/graphql"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id
           title
         }
       }
     }
`
)
;
export
default
async
(
req
,
context
)
=>
{
const
data
=
await
query
(
assetQuery
)
;
return
new
Response
(
JSON
.
stringify
(
data
)
)
;
}
;
When your site makes a request to the endpoint at
/.netlify/functions/get-data
relative to the base URL of your site, the function runs and uses the Connect client to query the data layer. The Connect client automatically accesses the
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables stored on Netlify and adds their values to the API request header before making the query.
Since the function makes the API request during runtime, it always gets the latest data from your data layer, even if you don’t rebuild your site.
#
Query in an edge function
Here is an example of how to query the API in an edge function. Every request to a path that matches the edge function path receives the latest results from the API.
This example uses
Connect client
to query the API for the
id
and
title
of the first 10 nodes under
allContentfulAsset
.
Follow the three steps to
configure the Connect client
. Make sure to create
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables with the URL and API token for your data layer’s GraphQL API.
Create an edge function file
in the edge functions directory. For example,
YOUR_BASE_DIRECTORY/netlify/edge-functions/get-data.js
.
In the file, add the following code to create an edge function that queries the API, transforms the data, and returns the result. Make sure you update the query to reflect your schema.
Loading error: Refresh the page to access this code sample
// YOUR_BASE_DIRECTORY/netlify/edge-functions/get-data.ts
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../../src/netlify-connect/graphql.ts"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id: _objectId
           title
           description
           customProperties // This is a JSON object
         }
       }
     }
`
)
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
data
=
await
query
(
assetQuery
)
;
const
dataTransformer
=
(
asset
)
=>
{
return
{
id
:
asset
.
id
         title
:
asset
.
title
,
description
:
{
body
:
asset
.
description
           header
:
customProperties
.
header
           footer
:
customProperties
.
footer
}
}
}
return
new
Response
(
JSON
.
stringify
(
data
.
map
(
dataTransformer
)
)
)
;
}
export
const
config
:
Config
=
{
path
:
"/get-data"
,
}
;
// YOUR_BASE_DIRECTORY/netlify/edge-functions/get-data.js
import
{
query
}
from
"@netlify/connect-client"
;
import
{
graphql
}
from
"../../src/netlify-connect/graphql.ts"
;
// Note this is a relative path
const
assetQuery
=
graphql
(
`
query MyQuery {
       allContentfulAsset(limit: 10) {
         nodes {
           id
           title
         }
       }
     }
`
)
;
export
default
async
(
)
=>
{
const
data
=
await
query
(
assetQuery
)
;
return
new
Response
(
JSON
.
stringify
(
data
)
)
;
}
export
const
config
=
{
path
:
"/get-data"
,
}
;
When your site makes a request to the
/get-data
path relative to the base URL of your site, the edge function runs and uses the Connect client to query the data layer. The Connect client automatically accesses the
DATA_LAYER_API_URL
and
DATA_LAYER_API_TOKEN
environment variables stored on Netlify and adds their values to the API request header before making the query.
Since the edge function makes the API request during runtime and does not cache the results, it always gets the latest data from your data layer, even if you don’t rebuild your site.
#
Avoid queries in edge functions configured for caching
Since Connect automatically caches data at the network edge, we don’t recommend using an
edge function configured for caching
to query the API.
There are no extra performance benefits to gain from using edge function caching on top of the built-in caching in Connect, and it will likely add unnecessary complexity. We recommend that you use an
edge function that is not configured for caching
instead.
#
Use the Connect client
Use the Connect JavaScript client,
connect-client
, to make requests to your data layer’s GraphQL API for an optimized user and developer experience.
When you use the client, you benefit from the following:
Efficient caching of dynamic content on Netlify’s CDN.
Instead of invalidating the full cache every time your data changes, you can invalidate only the stale content. This optimizes site performance for your users and is particularly helpful if your site uses a framework with SSR caching.
TypeScript type system support, enhanced by
gql.tada
.
Benefit from in-editor feedback, auto-completion, and type hints based on your data layer’s GraphQL schema. This provides a better developer experience and allows you to write queries directly in your site code instead of copying them over from the GraphQL sandbox.
Refer to the readme to learn more about
how Connect client supports caching
.
#
Cache optimization support
While you can use the client with any framework to query the API and get in-editor type system support, the built-in caching optimization is currently only supported for Astro and Next.js.
If you use a different framework with SSR caching, we recommend that you add your own cache management logic using
on-demand invalidation
.
Alternatively, you can choose to
connect your site
for a full redeploy and
cache invalidation
every time your data changes. While it may not be the most efficient option, it ensures you always have the latest data.
#
Configure and use the client
As outlined in the
connect-client
readme
, there are three steps to set up and use the client with your site:
Install the client and configure your project
.
If you only want to use the client to query your data layer’s API and to get in-editor type system support, stop here. Otherwise, complete the following steps to set up the client and your data layer to support cache invalidation.
Create a function to handle cache invalidation
.
Set up a notification on your data layer
.
Once you set up the client and your project, you can use the client to make queries in your site code. For examples, refer to the sections above on how to query in
site code
, a
function
, and an
edge function
. The client automatically adds the authorization headers for each request and, if you completed all three steps, manages the data caching as needed.
Ensure the API token has the correct scopes
If your data layer restricts access to certain fields and types using
API scopes
, make sure the API token you set for the client or pass to the individual query has the required scopes to access that data.
For detailed instructions, refer to the
connect-client
readme
.
#
Limitations and billing
Cache optimization is only for Next.js and Astro.
While you can use the client with any framework to query the API and get in-editor type system support, the built-in caching optimization is currently only supported for Astro and Next.js.
Netlify Functions limits and billing apply.
Since the client requires you to add a serverless function to your site, you should review the
default deployment options
and
usage and billing documentation
for Netlify Functions.
Manage connected sites in Netlify Connect: When to connect a site
Last updated: April 23, 2025
←
API authentication
Sync events
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_api-authentication.txt --------
Start of file
URL: https://docs.netlify.com/connect/api-authentication/
Scraped_At: 2025-06-02T19:56:44.401085

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
To ensure secure access to your data, configure API authentication settings for your data layer using API tokens and scopes.
You must authenticate all requests to your data layer’s
GraphQL API
using a token. However, API tokens and scopes do not apply to the
GraphQL sandbox
— an environment that is already limited to those in your Netlify team.
To support security tracking and auditing, Netlify records all activities related to generating, updating, and revoking API tokens and scopes in the
team audit log
.
#
Manage API tokens
To restrict access to sensitive data, create API scopes first
By default, API tokens have unrestricted access to all of your data. If you plan to restrict access to certain fields and types, you have to create the
API scope
first. You cannot edit an API token after you create it.
Team Owners and Developers can generate multiple API tokens for each data layer, as needed.
#
Generate an API token
To generate an API token for your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API tokens
section, select
Add an API token
.
Enter an
API token name
.
Select the
API scope(s)
for the token. You can add more than one scope to provide access to multiple data sets. If you leave this blank, the token will have unrestricted access. Unscoped types and fields are accessible to all API tokens.
Select
Generate token
.
After Netlify generates a token for you, select the clipboard icon to copy your token and then store it in a safe place. To protect your data, you won’t be able to reveal this token again.
Make sure to include the API token with all API requests. If you use the
Connect client
, you can store the token in an environment variable and the client will automatically apply it for you. If not, you need to ensure you manually add the token to the API request’s authorization header:
Authorization: Bearer <YOUR_AUTH_TOKEN>
.
Keep your API token secure
To keep your API token secure, we recommend that you store it in an
environment variable
on Netlify instead of in your repository. You can also avoid revealing the token in the browser by using the
Connect client
, a
serverless function
, or an
edge function
to access the variable and query the GraphQL API during runtime.
#
Revoke an API token
After you revoke an API token, any client applications or scripts that use that token will no longer be able to access the data layer’s GraphQL API.
This action cannot be reversed.
To revoke an API token:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API tokens
section, find the token you want to revoke and select
Revoke
.
In the confirmation prompt that appears, review the details and then select
Revoke
to confirm.
#
Manage API scopes
API scopes are available for select data sources
Support for API scopes is currently available for data layers that use the following data source types: Contentful, Contentstack, Drupal, Shopify, and WordPress. Additional support is coming soon.
API scopes allow you to restrict access to sensitive data. The first step is to create a scope for the types and fields you want to restrict. Then, you can create an API token with access to that scope.
Only API requests made with the correctly scoped API tokens can access restricted types and fields. Unscoped types and fields are accessible to all API tokens.
Note that API tokens created without a scope have unrestricted access and it’s not possible to edit their scope after you generate them.
Team Owners and Developers can add multiple API scopes for each data layer, as needed.
#
Add an API scope
To add an API scope to your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API scopes
section, select
Add an API scope
.
Enter a
Name
for the scope.
Select the types and fields for the scope. You can use the
Filter
field to search for specific ones.
Select
Save
.
When you add an API scope, Netlify automatically starts a data sync to apply the scope to the types and fields in your data layer’s schema.
You can now
generate an API token
and apply the new scope to it.
#
Edit an API scope
To edit an API scope on your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API scopes
section, find the scope you want to modify, and select it to reveal the details.
Select
Options
>
Edit
.
Update the scope as needed and then select
Save
.
When you edit an API scope, the changes immediately apply to all API tokens that use the scope, and Netlify automatically starts a data sync to update your data layer’s schema.
#
Delete an API scope
When you delete an API scope, the following access changes occur:
If you delete a scope and another one doesn’t already apply to the types and fields, the data included in the scope will be accessible by all API tokens.
If this is the only scope on an API token, the token will only have access to unscoped types and fields moving forward.
Only Team Owners can delete API scopes. This action cannot be reversed.
To delete an API scope from your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API scopes
section, find the scope you want to delete, and select it to reveal the details.
Select
Options
>
Delete
.
In the confirmation prompt that appears, review the details and then select
Delete API scope
to confirm.
When you delete an API scope, Netlify automatically starts a data sync to remove the specified scope from the types and fields in your data layer’s schema.
Last updated: October 2, 2024
←
Data revisions
Access data
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_data-revisions.txt --------
Start of file
URL: https://docs.netlify.com/connect/data-revisions/
Scraped_At: 2025-06-02T19:56:45.384138

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
Every data layer in Netlify Connect has access to a unified GraphQL API with support for multiple data revisions.
With each successful
data sync
, Netlify generates a new data revision for your data layer that represents the GraphQL schema and data at that point in time. You can query against each data revision using the revision’s GraphQL sandbox or its unique API URL.
By default, your data layer’s GraphQL API uses the latest data revision but you also have the option to pin a different data revision instead.
The ability to pin and access different data revisions for your data layer allows you to:
rollback and point your data layer’s API to a specific data revision while you troubleshoot and fix bugs
lock the data layer’s API to a specific data revision while you prepare for a major release
access and audit data from a specific date and time
Netlify records the pinning and unpinning of data revisions in the
team audit log
.
Data revisions include cross-references
When Netlify generates a new data revision for your data layer, the revision includes any
cross-references
that apply at the time. If you add, edit, or delete a cross-reference, the changes only apply to new data revisions generated after that modification.
This document provides an overview of data revisions in Connect. It also outlines how to pin and unpin revisions, and how to access their data.
#
Manage data revisions
Every successful sync to your data layer generates a new data revision, with a unique data revision ID.
At the top of the data layer’s overview page, you will find information about the data revision that your data layer’s GraphQL API is currently using — including the data revision ID and whether or not the API is using a pinned revision.
Netlify retains data revisions for 60 days
All data revisions are deleted after 60 days, except for the data revision that the API is currently using (by default or as a result of pinning).
In the Netlify UI, you can
review
all available data revisions. You can also manage which data revision your API uses by
pinning
and
unpinning
data revisions.
#
Review data revisions
To review the data revisions available for your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer’s overview page, select
Revisions
.
The data revision that your API is currently using is labelled with either the
Default
or
Pinned
badge. The
Pinned
badge indicates that you have pinned this specific data revision and the API will always use this one, even if newer revisions are available. The
Default
badge indicates that you have not pinned a data revision and the API is using this newest revision by default.
#
Pin a data revision
When you pin a data revision, the GraphQL API for your data layer will lock to that data revision. Successful syncs will continue to generate new data revisions but the API will always use this version.
The data layer’s API URL and GraphQL sandbox will reflect the pinned revision but you can still access other data revisions using each revision’s unique API URL and sandbox.
To pin the latest data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
At the top of the data layer’s overview page, select
Pin data revision
.
To confirm, select
Pin the latest data revision
.
To pin an older data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer‘s overview page, select
Revisions
to access the list of available data revisions.
Find the revision you want to pin, select
Options
, and then select
Pin this data revision
.
To confirm, select
Pin this data revision
.
Netlify will automatically rebuild and redeploy your connected sites to ensure they use data from this pinned data revision.
#
Unpin a data revision
When you unpin a data revision, the data layer’s GraphQL API will default to the most recent data revision. As Netlify syncs new data and generates new revisions, the API will always point to the latest one.
Note that if you unpin a data revision that is older than the retention period of 60 days and a newer revision is available, the old revision will be deleted within 24 hours.
To unpin the data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
At the top of the data layer’s overview page, select
Unpin data revision
.
To confirm, select
Unpin data revision
.
Netlify will automatically rebuild and redeploy your connected sites to ensure they use data from the most recent data revision.
#
Access data revisions
For each data revision, you have the option to download the changeset and make GraphQL queries using a revision-specific sandbox and API URL.
#
Download the changeset for a revision
For each data revision, you get access to a changeset JSON file that outlines what new data was synced in the selected data revision compared to the previous data revision.
To access the changeset for a data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer‘s overview page, select
Revisions
to access the list of available revisions.
Find the revision you want to review, select
Options
, and then select
Download changeset (JSON)
.
#
Use the GraphQL sandbox for a revision
You can access the GraphQL sandbox for a data revision to build, test, and run queries on the data from a specific point in time.
To access the sandbox for a specific data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer‘s overview page, select
Revisions
to access the list of available revisions.
Find the revision you want to access, select
Options
, and then select
Open in GraphQL sandbox
.
Note that saved queries will appear across all versions of the sandbox but the query will only run against and return data for the associated data revision. To confirm which data revision you are querying against, check the data revision ID at the top of the sandbox.
Learn more about
using the GraphQL sandbox
in Connect.
#
Query the GraphQL API for a revision
You can access the GraphQL API for a data revision to query the data as it existed at a specific point in time.
Each data revision has a unique API URL, with the following format:
https://{data_layer_key}-{data_revision_id}.api.netlify-connect.com
. Note that the data layer key is different from the data layer ID.
If you haven’t already, remember to
generate an API token
before you query the API.
To find the GraphQL API URL for a specific data revision:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
On the data layer‘s overview page, select
Revisions
to access the list of available revisions.
Find the revision you want to access, select
Options
, and then select
Copy revision API URL
.
Learn more about
using the GraphQL API
in Connect.
Last updated: May 29, 2024
←
Manage data layers
API authentication
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_get-started.txt --------
Start of file
URL: https://docs.netlify.com/connect/get-started/
Scraped_At: 2025-06-02T19:56:46.346566

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
To get started with Netlify Connect, create and configure your first data layer.
A data layer allows you to sync and combine data from multiple sources into a single real-time graph database that you can query against with a GraphQL API. When you set up a data layer, you add data sources to sync data from. You also connect sites and add webhooks to notify whenever data updates.
This document outlines some
key terms
, the four steps to
create and configure a data layer
, and
what to do next
.
#
Definitions
Here are some key terms that are useful to understand as you get started with Connect:
Data layer:
contains connections to one or more data sources, a real-time graph database containing all data synced from those sources, and a GraphQL API to access that data. It also supports connecting to sites to trigger builds when your data changes, and setting up notifications to notify external services.
Data revisions:
every successful sync to a data layer generates a new
data revision
that represents the GraphQL schema and data at that point in time. By default, a data layer’s GraphQL API uses the latest data revision, but you can also pin a different revision instead. You can query a specific data revision using the revision’s GraphQL sandbox or its unique API URL.
Data source:
an external system or service that contains your data, such as a content management system (CMS). Connect has built-in support for a number of
data source types
and you can add support for your own custom data source with the
Netlify SDK
.
Data integration:
an extension built using the
Netlify SDK
that allows you to sync data from a custom data source to Connect. Data integrations use
Connectors
.
Type prefix:
required when you want to add multiple data sources of the same type to a data layer, such as two Contentful CMS instances. When Netlify generates the GraphQL schema for your data layer, it will add the prefix to all GraphQL types from that data source.
Cross-reference:
a link that you can create between fields across data sources. Netlify automatically resolves
cross-references
when you query, so you can retrieve combined data through one query instead of a series of queries.
GraphQL API:
allows web clients to query and receive data from a data layer on Connect. A data layer’s GraphQL API defaults to use the latest data revision unless you pin a different data revision. Each data revision has a specific GraphQL
schema
based on your data sources, and you use this schema to construct queries and API requests.
GraphQL sandbox:
an isolated environment in the Netlify UI that you can use to build and test queries against a data layer’s GraphQL API. Netlify creates a unique sandbox for each data layer that you create and for each data revision that results from a successful sync.
Connected sites:
sites in your Netlify team that will automatically build and deploy when data changes. We use
build hooks
to trigger these builds.
Notifications:
outgoing webhooks that will notify other services when there is a new sync for your data layer.
Webhooks:
used to trigger a data layer sync from an external system. For example, your data source may send a POST request to a webhook URL to start a new sync.
Sync events:
activities
that occur in Connect when you add a data source and when data changes. These events include
Sync from all data sources
and
Sync from {data source type}
.
#
Prerequisite: Enable Connect
To enable Connect,
contact our sales team
to request a demo.
Once enabled, the
Connect
page will be unlocked in the Netlify UI for your team.
#
Create and configure a data layer
Team Owners and Developers can set up data layers for your team. This includes creating the data layer, adding data sources, connecting Netlify sites, and adding notifications — activities that Netlify automatically logs to the
team audit log
.
You can create more than one data layer to fit your needs. For example:
One data layer for production data and sites to use, and another for staging data and sites to use
Different data layers for different departments or products across your organization
Once you create a data layer, you can add one or more data sources to sync data from. You can select from the data sources Netlify officially supports as well as custom data sources supported through integrations built with the
Netlify SDK
.
The Netlify UI includes a guided flow to help you create and configure a new data layer. To get started,
add a data layer
.
Need to add a new data source to an existing data layer?
If you want to add a new data source, site, notification, or webhook to an existing data layer, you can do this from the data layer settings page. To learn more, review our
manage data layers
doc.
#
1. Add a data layer
To start the guided flow to add and configure a new data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select
Add new data layer
.
Enter a
Name
for this data layer.
(Optional) Enter a
Description
.
Select
Add data layer
.
At this point, Netlify will create an empty data layer for your team with the provided name and description. The
next step
is to add data sources.
#
2. Add data sources
The second step in the data layer configuration flow is to add one or more data sources to your data layer. We recommend that you add at least one data source now, but you will have the option to add more after you complete this flow.
Each supported data source type has different credentials, options, and set up instructions.
Select the type of data source:
commercetools
Contentful
Contentstack
Drupal
Salesforce Commerce Cloud
Shopify
WordPress
Other
commercetools
Contentful
Contentstack
Drupal
Salesforce Commerce Cloud
Shopify
WordPress
Other
#
commercetools
commercetools is a dynamic data source
The data integration for commercetools uses a dynamic connector, which means that Netlify proxies requests directly to the commercetools API every time you make a request for data. As a result, the data is never cached in Connect and you cannot use
cross-references
and
API scopes
with this data source.
To use commercetools, complete the following steps:
Set up an API client in Account Manager
.
Add your commercetools instance
and API information to your data layer.
#
Set up an API client in your commercetools project
To enable syncing data from commercetools, you need to
create an API Client
with the correct scopes in the commercetools Merchant Center:
In the Merchant Center for your commercetools project, navigate to
Settings
>
Developer settings
.
Select
Create New API Client
.
Enter a
name
for the client.
Under
Scopes
, select the
Admin client
template.
Select
Create API client
to finish.
Copy and save the
client_id
,
secret
, and
scope
values in a safe place because you will need them to set up the data source connection.
#
Add your commercetools instance
Once you have
set up an API client
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
commercetools
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
commercetools extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
When you query data, the data types synced from this data source should be nested under this prefix in the GraphQL schema. For example, if your prefix is
StoreCA
, your query for
orders
would be formatted as:
query {
    StoreCA {
        orders {
            ...
        }
    }
}
Enter the
Secret
for the
API client you created
in commercetools Merchant Center.
Enter the
Client ID
for the API client. The Merchant Center displays this value as the
client_id
.
Enter the
Region
for your project. For example,
us-east-2.aws
.
Enter the
Scope
for the API client.
Enter the
Project key
for your project.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Contentful
To use Contentful with Netlify Connect, complete the following steps:
Prepare your Contentful instance
.
Add your Contentful instance
to your data layer.
#
Prepare your Contentful instance
Take the following steps on your Contentful space before you add it to your data layer:
In the Contentful web app, navigate to
Settings
>
API keys
, and select
Add API key
to
create an API key
and generate access tokens for the space you want to sync. Netlify will need one of these tokens to access your data.
In the Contentful web app, navigate to
Settings
>
CMA tokens
, and select
Create personal access token
to generate a
Content Management API
access token. Copy this token and store it in a safe place. Netlify will need this token to automatically set up a webhook in your Contentful space that will notify Connect whenever data changes in your CMS.
To enable automatic syncing to Netlify, add your data layer webhook to your Contentful instance:
In your Contentful account, navigate to
Settings
>
Webhooks
, and select
Add webhook
.
Add the following webhook to the
URL
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Triggers
, select the content types that you wish to sync and the events that should trigger a sync. For more information on how to configure webhooks, refer to the
Contentful docs
.
Select
Save
to finish.
If you decide to configure the webhook using the Contentful API instead, add a
x-connect-data-source
header to the request with
contentful
as the header’s value. This ensures that the webhook only triggers a sync for this specific data source, instead of all data sources on your data layer.
#
Add your Contentful instance
Once you have
prepared your Contentful instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Contentful
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Contentful extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ContentfulPost
with the prefix
Marketing
becomes
MarketingContentfulPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Access token
for your Contentful instance. To sync published content, enter the
Content Delivery API access token
. To sync preview content instead, enter the
Content Preview API access token
.
Enter the
Space ID
for your Contentful instance.
Enter the
Content Management API access token
for your Contentful instance. Netlify will use this token to automatically set up a webhook in your Contentful space that will notify Connect whenever data changes in your CMS.
(Optional) Select the
Host URL
for your Contentful instance. The default is
cdn.contentful.com
. To use the Contentful Preview API, select
preview.contentful.com
.
(Optional) Enter the Contentful
Environment
to sync data from. The default is
master
.
(Optional) Enter a
Page limit
to specify the number of entries to fetch per page when syncing data from Contentful. The default is
100
.
(Optional) Select
Enable Contentful Tags
if your Contentful instance uses the
Contentful Tags feature
. Note that if you enable this option, you cannot use the content type name
tags
at this time.
(Optional) Fill in the
Locales
field to limit the locales Netlify will sync. By default, Netlify will sync all locales. Make sure these locales are enabled on Contentful. Netlify will use the default locale set in Contentful as the default locale for your source.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Contentstack
To use Contentstack with Connect, complete the following steps:
Prepare your Contentstack instance
.
Add your Contentstack instance
to your data layer.
#
Prepare your Contentstack instance
Take the following steps on your Contentstack instance before you add it to your data layer:
In your Contentstack account, navigate to
Settings
>
API Tokens
for your stack, and generate a
delivery token
for the environment you want to sync. You’ll need to enter this token when you set up your Contentstack data source in the Netlify UI, and Netlify will use this token to access your data.
To enable automatic syncing to Netlify, add your data layer webhook to your Contentstack instance:
In your Contentstack account, navigate to
Settings
>
Webhooks
for your stack, and select
New Webhook
.
Add the following webhook to the
URL To Notify
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Trigger Conditions
, add a
Condition
for each content type and event that you wish to sync. At minimum, you should configure the webhook to trigger when the
Entry
type is
Created
,
Updated
, and
Deleted
. For more information on how to configure webhook conditions, refer to the
Contentstack docs
.
Select
Save
to finish.
#
Add your Contentstack instance
Once you have
prepared your Contentstack instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Contentstack
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Contentstack extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ContentstackPost
with the prefix
Marketing
becomes
MarketingContentstackPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
API key
for your stack.
Enter the read-only
Delivery token
for your stack environment.
Enter the stack
Environment
to sync data from. For example, the
production
environment.
(Optional) Enter the
Region
to sync data from. Valid options are
na-aws
,
eu-aws
,
na-azure
, and
eu-azure
. The default is
na-aws
.
(Optional) Specify the
Locales
to sync entries from. For example,
en-us, fr-ch
.
(Optional) When entries aren't available for the specified locale, you can sync them in the fallback language instead. Select
Include Fallback Locale
to enable this. The default is
false
.
(Optional) Enter a
Limit
to specify the number of entries or assets to sync per page. The default is
50
.
(Optional) Enter the
Content Types
to sync from Contentstack. For example,
author, book
.
(Optional) Enter the
Content Types to exclude
from Contentstack syncs.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Drupal
Connect supports Drupal versions 9 and 10.
To use Drupal with Connect, complete the following steps:
Prepare your Drupal instance
.
Add your Drupal instance
to your data layer.
#
Prepare your Drupal instance
Take the following steps on your Drupal instance before you add it to your data layer:
Install
Gatsby Integration module
version 2. During the installation flow, follow the prompts to enable the
JSON:API Extras
module.
In the
JSON:API Extras
module, enable
Include count in collection queries
. This setting helps improve performance during data syncs.
Navigate to
Manage
>
Extend
and enable:
Gatsby
Gatsby JSON:API Extras
Install
JSON:API Schema module
.
To enable automatic syncing to Netlify, add your data layer webhook to the Gatsby Integration module.
Navigate to
Manage
>
Configuration
>
Web Services
>
Gatsby Integration
>
Gatsby Settings
.
Add the following webhook to the
Build Webhook URLs
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Entity types to send to Gatsby Preview and Build Server
, select the types you wish to sync. At minimum, you should select the
Content
type.
Select
Save configuration
to finish.
Navigate to
Manage
>
People
>
Permissions
to add the following permissions for data syncing:
Add
Sync Gatsby Fastbuild log entities
permissions. If your Drupal instance does not use authentication, then select
Anonymous user
. Otherwise, select the appropriate Drupal role.
Add
View Gatsby log entity entities
permissions. If your Drupal instance does not use authentication, then select
Anonymous user
. Otherwise, select the appropriate Drupal role.
#
Add your Drupal instance
Once you have
prepared your Drupal instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Drupal
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Drupal extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
DrupalPost
with the prefix
Marketing
becomes
MarketingDrupalPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Site URL
for your Drupal site, including the trailing slash.
(Optional) Enter the
JSON API Path Prefix
to use as the relative path to the
JSON:API
root. The default is
jsonapi
.
(Optional) If your Drupal instance has
basic authentication
enabled, enter the
HTTP Basic Auth username
and
HTTP Basic Auth password
.
(Optional) Enter any
Disabled types
that you would like to exclude from the GraphQL API.
(Optional) Enter the number of
Concurrent API requests
a user can make to the Drupal API. The default is
20
.
(Optional) Enter a
Request timeout
value. This is the time in milliseconds before requests to Drupal will time out. The default is
30000
.
(Optional) Enter the
Default language
of your Drupal site. This will determine what language content to sync from Drupal. The default is to sync the English language content.
(Optional) Enter the
Enabled languages
for your Drupal site. This will allow you to sync different translations from Drupal, depending on what languages your site has enabled.
(Optional) Select
Filter by language
to filter the data you sync from Drupal based on the current language.
(Optional) Enter the
Translatable entities
to specify what entities to sync translations for. For example,
node--page, node--article
.
(Optional) Enter the
Non-translatable entities
from your Drupal site. These entities will use the default language of your site. For example,
taxonomy_term--tags, taxonomy_term--categories
.
(Optional) Enter the
Request Headers used for Drupal API
to apply specific headers for the API.
(Optional) Enter the
Filters used for Drupal API
to specify what content to sync. This will allow you to control the data you receive from Drupal. For example,
{"recipe": "filter[tags.name][value]=British"}
.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Salesforce Commerce Cloud
To use Salesforce Commerce Cloud (SFCC), complete the following steps:
Set up an API Client in Account Manager
.
Add your SFCC instance
and API information to your data layer.
#
Set up an API Client in Account Manager
Netlify Connect utilizes the Salesforce Admin API to sync product data. To enable this, you need to set up an API Client with the correct scopes in Account Manager on Salesforce.
Create an API Client in Account Manager by following the
instructions provided by Salesforce
. While you set up the API client, note the following:
Take note of the password you set for the API Client. This will be used as the
Client Secret
later.
The API Client will require the following scopes:
sfcc.products
and
sfcc.catalogs
.
When you finish creating the client, find it in the table of API clients and take note of the value in the
API Client ID
column of the table, as described in Salesforce’s instructions. For example,
1d763261-6522-4913-9d52-5d947d3b94c4
.
#
Add your SFCC instance
Once you have
set up an API client
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Salesforce Commerce Cloud
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Salesforce Commerce Cloud extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
SfccProduct
with the prefix
Marketing
becomes
MarketingSfccProduct
in the schema.
Enter the
Client ID
for the
API Client you created
in Account Manager.
Enter the password for the API Client as the
Client Secret
.
Enter the
Organization ID
for your B2C Commerce instance. For example,
f_ecom_zzte_053
.
Enter the
Short Code
that is assigned to your realm. The
short code
applies to your entire realm, across all instances. For example,
kv7kzm78
.
Enter the
Site ID
for the site that you want to access data for (sometimes called a “channel”). For example,
RefArch
or
SiteGenesis
.
Enter a comma-separated list of
Locales
to sync data for. For example,
default, en-US, fr-FR, zh-CN, ja-JP, it-IT, en-GB
.
Enter the
Request Concurrency
to set the maximum number of concurrent requests to make to the B2C Commerce API.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Shopify
To use Shopify with Connect, complete the following steps:
Prepare your Shopify store
.
Add your Shopify store
to your data layer.
#
Prepare your Shopify store
To add a Shopify store to your data layer in Netlify Connect, first you need to set up a
custom Shopify app
that we can use to access Shopify’s Admin API and sync data. You will need the
Admin API access token
to set up your Shopify data source in Netlify Connect.
Log in to your Shopify store as the store owner and search for
Apps and sales channels
.
Enable
custom app development
. To do this, select
Develop apps
, then
Allow custom app development
. After reading the warning and information provided, select
Allow custom app development
.
Create a custom app
. From the
App development
section, select
Create an app
. Enter an app name and developer, then select
Create app
.
Set admin API scopes
for the app. On the custom app page, select
Configure Admin API scopes
. Enable the
read_products
,
read_product_listings
, and
read_files
scopes, and then select
Save
.
You can use this data integration to proxy directly to the Shopify GraphQL API as well. To allow additional CRUD operations through the proxy, enable the admin API scopes for these operations, such as
write_products
.
Install the app and get the API access token
. Select the
API credentials
tab and select
Install app
under
Access tokens
. Follow the prompts to install the app on your Shopify store.
Next, under the
Admin API access token
section, select
Reveal token once
to access the token. Store the token in a safe place as you will need it to set up the data source connection.
To enable automatic syncing to Netlify, you also need to add your data layer webhook to Shopify. This ensures that Shopify will notify Netlify when data updates.
In Shopify, navigate to
Settings
>
Notifications
, and under
Webhooks
, select
Create webhook
.
Select each
Event
that should trigger a sync to Netlify.
Select
JSON
as the format.
Add the following webhook to the
URL
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Select
Add webhook
to finish.
#
Add your Shopify store
Once you have
created a custom Shopify app
, take the following steps in the Netlify UI to add your Shopify store to your data layer:
Select
Add a data source
.
Select
Shopify
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Shopify extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ShopifyProduct
with the prefix
Marketing
becomes
MarketingShopifyProduct
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Admin API access token
. This is the access token for the custom Shopify app you created in the
prepare your store step
. The token starts with
shpat_
.
Enter the
Store Name
for your Shopify store. You can find store name in the Shopify URL. For example,
STORENAME.myshopify.com
.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
WordPress
To use WordPress with Netlify Connect, complete the following steps:
Prepare your WordPress instance
.
Add your WordPress instance
to your data layer.
#
Prepare your WordPress instance
Take the following steps on your WordPress instance before you add it to your data layer:
Install and activate the
Netlify Connect
WordPress plugin:
Download the
Netlify Connect
WordPress plugin
.
In your WordPress admin dashboard, navigate to
Plugins
and then select
Add New Plugin
.
Select
Upload Plugin
and follow the prompts to upload the
netlify-connect-wp-plugin.zip
file that you downloaded in step 1.
Select
Install now
.
In your WordPress admin dashboard, navigate to
Edit Profile
>
Application Passwords
and
create an application password
. You’ll need to enter this as your
token
when you set up your WordPress data source in the Netlify UI, and Netlify will use this token to access your data.
To enable automatic syncing to Netlify, add your data layer
Webhook URL
in your WordPress plugin settings for Connect:
In your WordPress admin dashboard, navigate to
Settings
>
Netlify Connect
.
Add the following webhook to the
Data layer Webhook URL
field. Make sure to replace the placeholder
YOUR-DATA-LAYER-ID
with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Select
Save Changes
to finish.
#
Add your WordPress instance
Once you have
prepared your WordPress instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
WordPress
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
WordPress extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter and can only consist of alphanumeric characters and underscores.
Connect will add the prefix to all data types synced from this data source in the GraphQL schema, which you will use when you query the GraphQL API. For example,
Post
with the prefix
Marketing
becomes
MarketingPost
in the schema.
Enter the
User
(the username for which you created the application password).
Enter the
Token
(the application password you created in WordPress).
Enter the full
API Host
URL for your WordPress instance (for example,
https://example.com
without a trailing slash).
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Optional configuration
If you need to customize your setup further, you can configure the following optional settings during the setup process:
Instance ID
unique value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Per page
: specify the number of nodes to fetch per page when syncing data from WordPress. The default is
100
.
Request concurrency
: set the number of concurrent requests to make during node sourcing. You can lower this if your WordPress server experiences issues during data sourcing. The default is
15
.
Types to exclude globally
: specify the slugs of post types, taxonomies, or other content types to exclude from sourcing, listed as comma-separated values.
#
Custom data source
To use a custom data source, an integration must already exist for it
If a data integration doesn’t already exist for your custom data source type, create one with the
Netlify SDK
. Once you publish your data integration, you can start using it in Netlify Connect.
To use a custom data source with Netlify Connect, complete the following steps:
Install the data integration
.
Prepare your data source instance
.
Add your custom data source
to your data layer.
Support for private and partner data integrations
For help with a custom data source, refer to the data integration’s details page in the Netlify UI and any external documentation the page links out to. You can find the details page by navigating to
Extensions
and searching for the integration by name.
#
Install the data integration
Before you can add a custom data source to your data layer, you must install the data integration for that type of source on your team.
As a Team Owner, navigate to the
Extensions
page for your team in the Netlify UI.
Find the data integration for the custom data source type that you wish to use and select it in the search results.
If it’s not already installed, on the details page, select
Install
.
If you can’t find the data integration, speak with the integration developer to ensure they have followed all of the steps to
publish an extension
.
#
Prepare your data source instance
To enable automatic syncing to Netlify, you need to manually add a webhook to your custom data source instance. The exact instructions vary for each system but you need to do the following:
Log in to your data source and navigate to the webhook settings.
Follow the prompts to create a new webhook and add the following to the URL field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
If the options are available, select the data types and events that should trigger the webhook. We suggest including any create, edit, and delete events for all content types that you wish to store in your data layer.
If you have the option to add a header to the webhook, add a
x-connect-data-source
header to the request with the
data integration’s slug
as the header’s value. This ensures that the webhook only triggers a sync for this specific data source, instead of all data sources on your data layer.
Save and enable the webhook.
You may need to complete other configuration steps on your data source instance. Please refer to the documentation provided by the integration developer.
#
Add your custom data source
Once you have
installed the data integration for your team
and
prepared your data source instance
, take the following steps in the Netlify UI to add the custom data source to your data layer:
If you are not already on the data layer settings page, on your team’s
Connect
page, select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Select
Add a data source
.
Select the data integration that you
installed
as the
Data source type
.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
Post
with the prefix
Marketing
becomes
MarketingPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Fill in the remaining configuration fields with the values for your data source instance. For example, you may need to provide the API key for your CMS instance.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
In the meantime, you can
add another source
or select
Continue
to move to the
next step
in the data layer configuration flow.
If you want to add
cross-references
between your data sources, you can configure them after you complete the data layer configuration flow.
#
3. Connect sites
The third step in the data layer configuration flow is to set up connections to sites on Netlify that should automatically build and deploy when data changes in this data layer.
We recommend that you connect any sites that use static site generation (SSG) to ensure they always have access to the latest data. All other site types should skip this step. Learn more about
when to connect your site
.
For Netlify to automatically build and deploy your site when data changes, your site must be
linked to a Git repository
to enable continuous deployment, and it must have
active builds
.
To connect a site to this data layer:
Select
Search by site name or domain
and start entering the name or domain of the site you want to connect.
When the site appears in the results list, select the site. The connected site will appear in the
Connected sites
list.
Once you connect a site, the
build hooks
for the site will include a
Netlify Connect - Data layer
build hook with the data layer ID as the value. This provides a convenient way on the site level to check whether a site is connected to a data layer.
Repeat the above steps to connect as many sites as needed. Once you’re done, select
Continue
to move to the last step.
#
4. Add notifications
The final step in the flow allows you to add notifications to notify external services whenever data changes in your data layer. For example, you may want to add a notification to notify a Slack channel when your data layer updates.
To add a notification:
Select
Add a notification
.
Enter a
Name
and
URL
for the notification.
Select
Create notification
.
Repeat these steps to add as many notifications as needed.
Once you’re done, select
Finish data layer configuration
to complete the set up process.
#
What next?
Once you finish the configuration flow for a new data layer, you can
review sync events
while Netlify completes the initial data sync from your data sources.
After the sync events are successful, you need to
generate an API token
for the GraphQL API. Once you do that, you can
access the data
with the GraphQL sandbox or through the GraphQL API in your app.
If the sync events are not successful, review our
troubleshooting tips
for support.
If you need to, you can now
pin a data revision
so that your data layer’s API always uses that specific data revision.
You can also
review and modify the data layer
to add or update configured data sources, sites, and webhooks. After you configure more than one data source on the data layer, you can add
cross-references
to create links between fields across data sources and retrieve the combined data through a single query.
You may also want to restrict access to certain data using
API scopes
and
generate new API tokens
to access that data.
Last updated: November 26, 2024
←
Overview
Manage data layers
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_manage-data-layers_manage-cross-references.txt --------
Start of file
URL: https://docs.netlify.com/connect/manage-data-layers/manage-cross-references/
Scraped_At: 2025-06-02T19:56:47.231463

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
After you
create and configure a data layer
, you can add cross-references to create links between fields across data sources.
When you request data, Netlify automatically resolves the cross-references so that you can get all of the related information at once and through a single query. This makes for a better developer experience and a faster user experience because you avoid having to do a series of queries, waiting for each one to resolve before making the next, and then manually combining the data yourself.
Cross-references resolve for queries made in the
GraphQL sandbox
and through the
GraphQL API
.
Team Owners and Developers can add and update cross-references. Netlify records all activities related to adding, editing, and deleting cross-references in the
team audit log
.
New to Connect? Set up a data layer first
If you haven’t already created a data layer, navigate to the
Connect
page for your team and select
Add new data layer
. Follow the prompts to configure the data layer and to add data sources, connected sites, and notifications. For more information, refer to our
get started with Netlify Connect
guide.
#
How cross-references work
To understand how cross-references work, consider an example where you use Drupal for your site copy and Contentstack for your product information.
Each
DrupalPage
represents a page in your site and contains a
contentstack_sku
field that identifies a product from Contentstack to display on that page. Similarly, each
ContentstackProduct
represents a product and contains a unique identifier in the
sku
field.
Without cross-references, you would query for all the
DrupalPage
entities first and then do a second query using the
contentstack_sku
field to get the related
ContentstackProduct
entity for each
DrupalPage
.
Instead of making a series of queries, you can add a cross-reference to create a link between the
contentstack_sku
field on
DrupalPage
and the
sku
field on
ContentstackProduct
first.
Then, whenever you query for
DrupalPage
entities, Netlify resolves the cross-reference and automatically returns the
ContentstackProduct
entity for the
contentstack_sku
field on each
DrupalPage
.
Essentially, the type of
contentstack_sku
becomes
ContentstackProduct
, so you can access all of the fields on the product directly in the query for the
DrupalPage
:
query drupalToContentstack
{
drupalPage
(
title
:
{
eq
:
"Store"
}
)
{
id
        title
        field_description
        body
{
value
}
contentstack_sku
{
refId
            reference
{
id
                title
                price
                image
{
url
}
}
}
}
}
#
Add a cross-reference
Cross-references are available for select data sources
Support for cross-references is currently available for data layers that use the following data source types: Contentful, Contentstack, Drupal, Shopify, and WordPress. Additional support is coming soon.
Connect supports cross-references for string and number field types. You can configure cross-references to one level deep but you can query the resolved links to any depth required.
To add a cross-reference to your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Cross-references
.
Select
Add a cross-reference
.
Select a
Data source
, a
Type
on that data source, and then a
Field
on that type.
Next, define the other half of the cross-reference relationship. Select a
Data source
, a
Type
on that data source, and then a
Field
on that type. Then, specify whether this field references a
Single
entity with a unique identifier, or if there are
Multiple
entities that share the same identifier.
Select
Save
.
When you add a cross-reference, Netlify automatically starts a data sync to generate a new
data revision
that reflects the updated schema.
Existing data revisions represent the schema at a specific point in time and will not include the new cross-reference.
#
Edit a cross-reference
To edit a cross-reference on your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Cross-references
.
Find the cross-reference you want to edit and select
Options
>
Edit
.
Update the cross-reference as needed and then select
Save
.
When you edit a cross-reference, Netlify automatically starts a data sync to generate a new
data revision
that reflects the updated schema.
Existing data revisions represent the schema at a specific point in time and will not include the updated cross-reference.
#
Delete a cross-reference
When you delete a cross-reference, the change applies to new
data revisions
generated after the update. Existing data revisions represent the schema at a specific point in time and will still include the deleted cross-reference.
Unless you
pin the current data revision
or update your site to
use the GraphQL API for that revision
, any queries for cross-referenced data will break once the deletion takes effect. Make sure to update the queries in your site or pin the data revision before deleting the cross-reference.
Because this action cannot be reversed, only Team Owners can delete a cross-reference.
To delete a cross-reference from your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Cross-references
.
Find the cross-reference you want to delete and select
Options
>
Delete
.
Review the confirmation prompt and then select
Delete cross-reference
.
When you delete a cross-reference, Netlify automatically starts a data sync to generate a new
data revision
that reflects the updated schema.
Last updated: November 26, 2024
←
Manage data sources
Manage connected sites
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_manage-data-layers_manage-data-sources.txt --------
Start of file
URL: https://docs.netlify.com/connect/manage-data-layers/manage-data-sources/
Scraped_At: 2025-06-02T19:56:48.217877

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
After you
create and configure a data layer
, you can review and modify the data layer on the settings page in the Netlify UI. This document outlines how to add, edit, and delete data sources for an existing data layer.
A
data source
is an external system or service that contains your data, such as a content management system (CMS). Connect includes built-in support for a number of popular data source types such as Contentful and Drupal, but you can also build support for your custom data source using the
Netlify SDK
.
Team Owners and Developers can add, edit, or delete data sources on a data layer. They can also specify
cross-references
between data sources to retrieve related data with a single query.
When you modify data source configurations on your data layer, Netlify
re-syncs all data sources
and updates the data layer’s GraphQL schema to reflect the change. Netlify also records the data source changes in the
team audit log
.
New to Connect? Set up a data layer first
If you haven’t already created a data layer, navigate to the
Connect
page for your team and select
Add new data layer
. Follow the prompts to configure the data layer and to add data sources, connected sites, and notifications. For more information, refer to our
get started with Netlify Connect
guide.
#
Add new data sources
To add a new data source to your data layer, first navigate to the data source section for your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Each supported data source type has different credentials, options, and setup instructions:
commercetools
Contentful
Contentstack
Drupal
Salesforce Commerce Cloud
Shopify
WordPress
Other
After you save a data source configuration, Netlify connects to the data source and starts syncing data to your data layer. If the initial sync fails, review our
troubleshooting tips
for support.
#
commercetools
commercetools is a dynamic data source
The data integration for commercetools uses a dynamic connector, which means that Netlify proxies requests directly to the commercetools API every time you make a request for data. As a result, the data is never cached in Connect and you cannot use
cross-references
and
API scopes
with this data source.
To use commercetools, complete the following steps:
Set up an API client in Account Manager
.
Add your commercetools instance
and API information to your data layer.
#
Set up an API client in your commercetools project
To enable syncing data from commercetools, you need to
create an API Client
with the correct scopes in the commercetools Merchant Center:
In the Merchant Center for your commercetools project, navigate to
Settings
>
Developer settings
.
Select
Create New API Client
.
Enter a
name
for the client.
Under
Scopes
, select the
Admin client
template.
Select
Create API client
to finish.
Copy and save the
client_id
,
secret
, and
scope
values in a safe place because you will need them to set up the data source connection.
#
Add your commercetools instance
Once you have
set up an API client
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
commercetools
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
commercetools extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
When you query data, the data types synced from this data source should be nested under this prefix in the GraphQL schema. For example, if your prefix is
StoreCA
, your query for
orders
would be formatted as:
query {
    StoreCA {
        orders {
            ...
        }
    }
}
Enter the
Secret
for the
API client you created
in commercetools Merchant Center.
Enter the
Client ID
for the API client. The Merchant Center displays this value as the
client_id
.
Enter the
Region
for your project. For example,
us-east-2.aws
.
Enter the
Scope
for the API client.
Enter the
Project key
for your project.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Contentful
To use Contentful with Netlify Connect, complete the following steps:
Prepare your Contentful instance
.
Add your Contentful instance
to your data layer.
#
Prepare your Contentful instance
Take the following steps on your Contentful space before you add it to your data layer:
In the Contentful web app, navigate to
Settings
>
API keys
, and select
Add API key
to
create an API key
and generate access tokens for the space you want to sync. Netlify will need one of these tokens to access your data.
In the Contentful web app, navigate to
Settings
>
CMA tokens
, and select
Create personal access token
to generate a
Content Management API
access token. Copy this token and store it in a safe place. Netlify will need this token to automatically set up a webhook in your Contentful space that will notify Connect whenever data changes in your CMS.
To enable automatic syncing to Netlify, add your data layer webhook to your Contentful instance:
In your Contentful account, navigate to
Settings
>
Webhooks
, and select
Add webhook
.
Add the following webhook to the
URL
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Triggers
, select the content types that you wish to sync and the events that should trigger a sync. For more information on how to configure webhooks, refer to the
Contentful docs
.
Select
Save
to finish.
If you decide to configure the webhook using the Contentful API instead, add a
x-connect-data-source
header to the request with
contentful
as the header’s value. This ensures that the webhook only triggers a sync for this specific data source, instead of all data sources on your data layer.
#
Add your Contentful instance
Once you have
prepared your Contentful instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Contentful
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Contentful extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ContentfulPost
with the prefix
Marketing
becomes
MarketingContentfulPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Access token
for your Contentful instance. To sync published content, enter the
Content Delivery API access token
. To sync preview content instead, enter the
Content Preview API access token
.
Enter the
Space ID
for your Contentful instance.
Enter the
Content Management API access token
for your Contentful instance. Netlify will use this token to automatically set up a webhook in your Contentful space that will notify Connect whenever data changes in your CMS.
(Optional) Select the
Host URL
for your Contentful instance. The default is
cdn.contentful.com
. To use the Contentful Preview API, select
preview.contentful.com
.
(Optional) Enter the Contentful
Environment
to sync data from. The default is
master
.
(Optional) Enter a
Page limit
to specify the number of entries to fetch per page when syncing data from Contentful. The default is
100
.
(Optional) Select
Enable Contentful Tags
if your Contentful instance uses the
Contentful Tags feature
. Note that if you enable this option, you cannot use the content type name
tags
at this time.
(Optional) Fill in the
Locales
field to limit the locales Netlify will sync. By default, Netlify will sync all locales. Make sure these locales are enabled on Contentful. Netlify will use the default locale set in Contentful as the default locale for your source.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Contentstack
To use Contentstack with Connect, complete the following steps:
Prepare your Contentstack instance
.
Add your Contentstack instance
to your data layer.
#
Prepare your Contentstack instance
Take the following steps on your Contentstack instance before you add it to your data layer:
In your Contentstack account, navigate to
Settings
>
API Tokens
for your stack, and generate a
delivery token
for the environment you want to sync. You’ll need to enter this token when you set up your Contentstack data source in the Netlify UI, and Netlify will use this token to access your data.
To enable automatic syncing to Netlify, add your data layer webhook to your Contentstack instance:
In your Contentstack account, navigate to
Settings
>
Webhooks
for your stack, and select
New Webhook
.
Add the following webhook to the
URL To Notify
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Trigger Conditions
, add a
Condition
for each content type and event that you wish to sync. At minimum, you should configure the webhook to trigger when the
Entry
type is
Created
,
Updated
, and
Deleted
. For more information on how to configure webhook conditions, refer to the
Contentstack docs
.
Select
Save
to finish.
#
Add your Contentstack instance
Once you have
prepared your Contentstack instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Contentstack
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Contentstack extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ContentstackPost
with the prefix
Marketing
becomes
MarketingContentstackPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
API key
for your stack.
Enter the read-only
Delivery token
for your stack environment.
Enter the stack
Environment
to sync data from. For example, the
production
environment.
(Optional) Enter the
Region
to sync data from. Valid options are
na-aws
,
eu-aws
,
na-azure
, and
eu-azure
. The default is
na-aws
.
(Optional) Specify the
Locales
to sync entries from. For example,
en-us, fr-ch
.
(Optional) When entries aren't available for the specified locale, you can sync them in the fallback language instead. Select
Include Fallback Locale
to enable this. The default is
false
.
(Optional) Enter a
Limit
to specify the number of entries or assets to sync per page. The default is
50
.
(Optional) Enter the
Content Types
to sync from Contentstack. For example,
author, book
.
(Optional) Enter the
Content Types to exclude
from Contentstack syncs.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Drupal
Connect supports Drupal versions 9 and 10.
To use Drupal with Connect, complete the following steps:
Prepare your Drupal instance
.
Add your Drupal instance
to your data layer.
#
Prepare your Drupal instance
Take the following steps on your Drupal instance before you add it to your data layer:
Install
Gatsby Integration module
version 2. During the installation flow, follow the prompts to enable the
JSON:API Extras
module.
In the
JSON:API Extras
module, enable
Include count in collection queries
. This setting helps improve performance during data syncs.
Navigate to
Manage
>
Extend
and enable:
Gatsby
Gatsby JSON:API Extras
Install
JSON:API Schema module
.
To enable automatic syncing to Netlify, add your data layer webhook to the Gatsby Integration module.
Navigate to
Manage
>
Configuration
>
Web Services
>
Gatsby Integration
>
Gatsby Settings
.
Add the following webhook to the
Build Webhook URLs
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Under
Entity types to send to Gatsby Preview and Build Server
, select the types you wish to sync. At minimum, you should select the
Content
type.
Select
Save configuration
to finish.
Navigate to
Manage
>
People
>
Permissions
to add the following permissions for data syncing:
Add
Sync Gatsby Fastbuild log entities
permissions. If your Drupal instance does not use authentication, then select
Anonymous user
. Otherwise, select the appropriate Drupal role.
Add
View Gatsby log entity entities
permissions. If your Drupal instance does not use authentication, then select
Anonymous user
. Otherwise, select the appropriate Drupal role.
#
Add your Drupal instance
Once you have
prepared your Drupal instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Drupal
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Drupal extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
DrupalPost
with the prefix
Marketing
becomes
MarketingDrupalPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Site URL
for your Drupal site, including the trailing slash.
(Optional) Enter the
JSON API Path Prefix
to use as the relative path to the
JSON:API
root. The default is
jsonapi
.
(Optional) If your Drupal instance has
basic authentication
enabled, enter the
HTTP Basic Auth username
and
HTTP Basic Auth password
.
(Optional) Enter any
Disabled types
that you would like to exclude from the GraphQL API.
(Optional) Enter the number of
Concurrent API requests
a user can make to the Drupal API. The default is
20
.
(Optional) Enter a
Request timeout
value. This is the time in milliseconds before requests to Drupal will time out. The default is
30000
.
(Optional) Enter the
Default language
of your Drupal site. This will determine what language content to sync from Drupal. The default is to sync the English language content.
(Optional) Enter the
Enabled languages
for your Drupal site. This will allow you to sync different translations from Drupal, depending on what languages your site has enabled.
(Optional) Select
Filter by language
to filter the data you sync from Drupal based on the current language.
(Optional) Enter the
Translatable entities
to specify what entities to sync translations for. For example,
node--page, node--article
.
(Optional) Enter the
Non-translatable entities
from your Drupal site. These entities will use the default language of your site. For example,
taxonomy_term--tags, taxonomy_term--categories
.
(Optional) Enter the
Request Headers used for Drupal API
to apply specific headers for the API.
(Optional) Enter the
Filters used for Drupal API
to specify what content to sync. This will allow you to control the data you receive from Drupal. For example,
{"recipe": "filter[tags.name][value]=British"}
.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Salesforce Commerce Cloud
To use Salesforce Commerce Cloud (SFCC), complete the following steps:
Set up an API Client in Account Manager
.
Add your SFCC instance
and API information to your data layer.
#
Set up an API Client in Account Manager
Netlify Connect utilizes the Salesforce Admin API to sync product data. To enable this, you need to set up an API Client with the correct scopes in Account Manager on Salesforce.
Create an API Client in Account Manager by following the
instructions provided by Salesforce
. While you set up the API client, note the following:
Take note of the password you set for the API Client. This will be used as the
Client Secret
later.
The API Client will require the following scopes:
sfcc.products
and
sfcc.catalogs
.
When you finish creating the client, find it in the table of API clients and take note of the value in the
API Client ID
column of the table, as described in Salesforce’s instructions. For example,
1d763261-6522-4913-9d52-5d947d3b94c4
.
#
Add your SFCC instance
Once you have
set up an API client
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
Salesforce Commerce Cloud
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Salesforce Commerce Cloud extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
SfccProduct
with the prefix
Marketing
becomes
MarketingSfccProduct
in the schema.
Enter the
Client ID
for the
API Client you created
in Account Manager.
Enter the password for the API Client as the
Client Secret
.
Enter the
Organization ID
for your B2C Commerce instance. For example,
f_ecom_zzte_053
.
Enter the
Short Code
that is assigned to your realm. The
short code
applies to your entire realm, across all instances. For example,
kv7kzm78
.
Enter the
Site ID
for the site that you want to access data for (sometimes called a “channel”). For example,
RefArch
or
SiteGenesis
.
Enter a comma-separated list of
Locales
to sync data for. For example,
default, en-US, fr-FR, zh-CN, ja-JP, it-IT, en-GB
.
Enter the
Request Concurrency
to set the maximum number of concurrent requests to make to the B2C Commerce API.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Shopify
To use Shopify with Connect, complete the following steps:
Prepare your Shopify store
.
Add your Shopify store
to your data layer.
#
Prepare your Shopify store
To add a Shopify store to your data layer in Netlify Connect, first you need to set up a
custom Shopify app
that we can use to access Shopify’s Admin API and sync data. You will need the
Admin API access token
to set up your Shopify data source in Netlify Connect.
Log in to your Shopify store as the store owner and search for
Apps and sales channels
.
Enable
custom app development
. To do this, select
Develop apps
, then
Allow custom app development
. After reading the warning and information provided, select
Allow custom app development
.
Create a custom app
. From the
App development
section, select
Create an app
. Enter an app name and developer, then select
Create app
.
Set admin API scopes
for the app. On the custom app page, select
Configure Admin API scopes
. Enable the
read_products
,
read_product_listings
, and
read_files
scopes, and then select
Save
.
You can use this data integration to proxy directly to the Shopify GraphQL API as well. To allow additional CRUD operations through the proxy, enable the admin API scopes for these operations, such as
write_products
.
Install the app and get the API access token
. Select the
API credentials
tab and select
Install app
under
Access tokens
. Follow the prompts to install the app on your Shopify store.
Next, under the
Admin API access token
section, select
Reveal token once
to access the token. Store the token in a safe place as you will need it to set up the data source connection.
To enable automatic syncing to Netlify, you also need to add your data layer webhook to Shopify. This ensures that Shopify will notify Netlify when data updates.
In Shopify, navigate to
Settings
>
Notifications
, and under
Webhooks
, select
Create webhook
.
Select each
Event
that should trigger a sync to Netlify.
Select
JSON
as the format.
Add the following webhook to the
URL
field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Select
Add webhook
to finish.
#
Add your Shopify store
Once you have
created a custom Shopify app
, take the following steps in the Netlify UI to add your Shopify store to your data layer:
Select
Add a data source
.
Select
Shopify
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
Shopify extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
ShopifyProduct
with the prefix
Marketing
becomes
MarketingShopifyProduct
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Enter the
Admin API access token
. This is the access token for the custom Shopify app you created in the
prepare your store step
. The token starts with
shpat_
.
Enter the
Store Name
for your Shopify store. You can find store name in the Shopify URL. For example,
STORENAME.myshopify.com
.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
WordPress
To use WordPress with Netlify Connect, complete the following steps:
Prepare your WordPress instance
.
Add your WordPress instance
to your data layer.
#
Prepare your WordPress instance
Take the following steps on your WordPress instance before you add it to your data layer:
Install and activate the
Netlify Connect
WordPress plugin:
Download the
Netlify Connect
WordPress plugin
.
In your WordPress admin dashboard, navigate to
Plugins
and then select
Add New Plugin
.
Select
Upload Plugin
and follow the prompts to upload the
netlify-connect-wp-plugin.zip
file that you downloaded in step 1.
Select
Install now
.
In your WordPress admin dashboard, navigate to
Edit Profile
>
Application Passwords
and
create an application password
. You’ll need to enter this as your
token
when you set up your WordPress data source in the Netlify UI, and Netlify will use this token to access your data.
To enable automatic syncing to Netlify, add your data layer
Webhook URL
in your WordPress plugin settings for Connect:
In your WordPress admin dashboard, navigate to
Settings
>
Netlify Connect
.
Add the following webhook to the
Data layer Webhook URL
field. Make sure to replace the placeholder
YOUR-DATA-LAYER-ID
with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
Select
Save Changes
to finish.
#
Add your WordPress instance
Once you have
prepared your WordPress instance
, take the following steps in the Netlify UI to add it to your data layer:
Select
Add a data source
.
Select
WordPress
as the
Data source type
.
If you haven’t already installed the extension for this data source, follow the
install extension
prompt to open the
WordPress extension details page
in a new tab. As a Team Owner, select
Install
to install and make the extension available to all data layers on your team.
After you install the extension, close the tab and return to the
Add a data source
flow in Connect to continue with the next steps.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter and can only consist of alphanumeric characters and underscores.
Connect will add the prefix to all data types synced from this data source in the GraphQL schema, which you will use when you query the GraphQL API. For example,
Post
with the prefix
Marketing
becomes
MarketingPost
in the schema.
Enter the
User
(the username for which you created the application password).
Enter the
Token
(the application password you created in WordPress).
Enter the full
API Host
URL for your WordPress instance (for example,
https://example.com
without a trailing slash).
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Optional configuration
If you need to customize your setup further, you can configure the following optional settings during the setup process:
Instance ID
unique value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Per page
: specify the number of nodes to fetch per page when syncing data from WordPress. The default is
100
.
Request concurrency
: set the number of concurrent requests to make during node sourcing. You can lower this if your WordPress server experiences issues during data sourcing. The default is
15
.
Types to exclude globally
: specify the slugs of post types, taxonomies, or other content types to exclude from sourcing, listed as comma-separated values.
#
Other
To use a custom data source, an integration must already exist for it
If a data integration doesn’t already exist for your custom data source type, create one with the
Netlify SDK
. Once you publish your data integration, you can start using it in Netlify Connect.
To use a custom data source with Netlify Connect, complete the following steps:
Install the data integration
.
Prepare your data source instance
.
Add your custom data source
to your data layer.
Support for private and partner data integrations
For help with a custom data source, refer to the data integration’s details page in the Netlify UI and any external documentation the page links out to. You can find the details page by navigating to
Extensions
and searching for the integration by name.
#
Install the data integration
Before you can add a custom data source to your data layer, you must install the data integration for that type of source on your team.
As a Team Owner, navigate to the
Extensions
page for your team in the Netlify UI.
Find the data integration for the custom data source type that you wish to use and select it in the search results.
If it’s not already installed, on the details page, select
Install
.
If you can’t find the data integration, speak with the integration developer to ensure they have followed all of the steps to
publish an extension
.
#
Prepare your data source instance
To enable automatic syncing to Netlify, you need to manually add a webhook to your custom data source instance. The exact instructions vary for each system but you need to do the following:
Log in to your data source and navigate to the webhook settings.
Follow the prompts to create a new webhook and add the following to the URL field. Make sure to replace the placeholder with your
data layer ID
.
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/YOUR-DATA-LAYER-ID
Note that you also have the ability to create a custom authenticated webhook and use that instead of the default webhook. Learn more about
managing webhooks
.
If the options are available, select the data types and events that should trigger the webhook. We suggest including any create, edit, and delete events for all content types that you wish to store in your data layer.
If you have the option to add a header to the webhook, add a
x-connect-data-source
header to the request with the
data integration’s slug
as the header’s value. This ensures that the webhook only triggers a sync for this specific data source, instead of all data sources on your data layer.
Save and enable the webhook.
You may need to complete other configuration steps on your data source instance. Please refer to the documentation provided by the integration developer.
#
Add your custom data source
Once you have
installed the data integration for your team
and
prepared your data source instance
, take the following steps in the Netlify UI to add the custom data source to your data layer:
If you are not already on the data layer settings page, on your team’s
Connect
page, select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Select
Add a data source
.
Select the data integration that you
installed
as the
Data source type
.
Enter a
Name
for this data source.
Add a
Type prefix
for this data source. The prefix must start with an uppercase letter, and can only consist of alphanumeric characters and underscores.
The prefix will be added to all data types synced from this data source in the GraphQL schema and you will use it when you query the GraphQL API. For example,
Post
with the prefix
Marketing
becomes
MarketingPost
in the schema.
(Optional) Enter a unique
Instance ID
value to use for this data source. Netlify uses this value to support
cross-references
and linking between data sources.
Fill in the remaining configuration fields with the values for your data source instance. For example, you may need to provide the API key for your CMS instance.
Select
Save
to add this data source.
When you add a new data source, Netlify automatically connects to it and starts syncing data to your data layer.
#
Edit data sources
Want to create links between data sources?
Use cross-references to create links between fields across data sources so you can retrieve combined data through a single query. To set up cross-references, navigate to the
Cross-references
section of your
Data layer settings
. Learn more about
cross-references
.
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Select the data source you want to edit.
Select
Edit
and update the fields as needed.
Select
Save
.
#
Delete data sources
Deleting data sources from deprecated integrations
With the launch of Netlify SDK v2, a number of data integrations are
deprecated
. While the integrations will continue to function for teams that currently have them enabled, once you delete a data source that uses a deprecated data integration, it’s not possible to add a new one to your data layer.
When you delete a data source, Netlify will delete all data related to that source from the data layer and then update the data layer’s schema to reflect the change.
To delete a data source from your data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Select the data source you want to delete.
Select
Delete
.
A confirmation prompt will appear. Enter the name of the data source to confirm.
Select
Delete
.
After the
sync events
are complete, make sure you
review the new schema
and update any sites that make queries to the GraphQL API to reflect this change.
Last updated: November 26, 2024
←
Manage data layers
Manage cross-references
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_monitor-activity.txt --------
Start of file
URL: https://docs.netlify.com/connect/monitor-activity/
Scraped_At: 2025-06-02T19:56:49.317083

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
Netlify provides logs to help you observe and troubleshoot activity on your data layer.
You can access data layer activity logs to
review sync activity
and the team audit log to
review team member activity
.
#
Review data layer sync events
Logs are retained for 5 days
Currently, Netlify only retains Connect logs for five days. Older events are listed in the
Activity
section, but the logs are unavailable.
To review
sync events
for a data layer, navigate to the overview page for that data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer you want to review from the
Data layers
list.
Review the
Activity
section and select a sync event in the list to access the detailed log.
To review the associated data revision for a successful sync, select
Revisions
.
#
Set up Slack notifications
Set up subscriptions to get notified of sync event failures with the
Netlify App for Slack
. If a data layer sync event fails, the app automatically notifies the Slack channel you specify.
Follow the instructions to
authorize and install the Netlify App for Slack
.
Go to
Team settings
>
Notifications
>
Slack notifications
.
Select
Add subscription
.
Select
Connect sync events
as the
Event type
, and select the Slack
Channel
to notify.
Select
Create subscription
.
Note that you can only set up the subscription using the Netlify UI. It is not possible to set up the subscription from a Slack channel.
#
Review team member activity
To help you audit and troubleshoot changes to your data layer, Netlify automatically logs changes to the following items in your team audit log:
API scopes:
when a team member adds, edits, or deletes an API scope for a data layer.
API tokens:
when a team member generates, updates, or revokes an API token for a data layer.
Connected sites:
when a team member connects or disconnects a site.
Cross-references:
when a team member adds, edits, or deletes a cross-reference.
Data layers:
when a team member creates, updates, or deletes a data layer.
Data revisions:
when a team member pins or unpins a data revision.
Data sources:
when a team member creates, updates, or deletes a data source.
Notifications:
when a team member creates or deletes a notification.
Webhooks:
when a team member creates or deletes a webhook.
To access these logs, navigate to your team’s
Audit log
.
Learn more about the
team audit log
.
Last updated: November 26, 2024
←
Sync events
Troubleshooting tips
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_overview.txt --------
Start of file
URL: https://docs.netlify.com/connect/overview/
Scraped_At: 2025-06-02T19:56:49.935643

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
With Netlify Connect, you can integrate content from multiple sources into a single data unification layer for easy access through a GraphQL API. Data updates sync automatically to ensure your sites and other web properties always have access to the latest content, all cached at the edge.
When you unify your content sources through Connect, you unlock a number of benefits that make it easier to modernize your web architecture:
A single data unification layer that is cached at the network edge and is optimized for global availability, reliability, and performance
No-code integrations that allow you to use data from legacy systems alongside data from your modern CMS
The ability to create private data integrations that allow you to use data from your proprietary systems
A scalable GraphQL API that allows you to use CMS providers without having to worry about the CMS API’s rate-limiting or expensive bandwidth usage limits
Flexibility to access data through the GraphQL API with any frontend framework — including Remix, Next.js, Gatsby, Vue, Svelte, and Astro
Multiple data revisions cached for each data layer that capture the GraphQL schema and data at a point in time, with the ability to pin a specific revision for your API to use while planning for a major release or troubleshooting an error
The ability to specify cross-references between data sources and retrieve combined data through a single query for a faster user experience and better developer experience
Reduced web architecture migration risk with a modular approach that allows you to create data redundancy (by caching data in  Connect) and then change or update architecture components over time
Individual integrations versus Connect
Connect is an Enterprise-only feature that’s best for those who have data spread across multiple data sources. If you want to sync data from a single data source, we recommend you review our individual
integrations
instead, including our
Contentful integration
.
#
How Connect works
Netlify helps you build for an open web by allowing you to synchronize data from a single data unification layer, which is cached at the network edge and optimized for global availability, reliability, and performance.
#
Caching data
Connect queries and caches data following these general steps:
Connect client queries data
CDN checks token-scoped cache for query
Connect client validates access token and determines token scope
Connect client fetches and combines dynamic and cached data
Connect client returns query results to the CDN
CDN caches token-scoped query and sends it to the client
#
Syncing data
A person makes a change to content
Data update triggers sync
Fetch data layer using configuration from
app.netlify.com
Schema is created
Schema is customized by cross-referencing API scopes from the configuration
Fetch data
Persist to Connect data cache
Invalidations (invalidate site pages & queries with content that has changed)
Send notifications by triggering builds and alerting third-party apps of syncs
#
Supported data sources
Connect supports the following data source types:
commercetools
Contentful
Contentstack
Drupal
Salesforce Commerce Cloud
Shopify
WordPress
Custom — third-party or proprietary data sources supported by private or partner data integrations built with the
Netlify SDK
Build support for your custom data source with the Netlify SDK
Use the
Netlify SDK
to develop a data integration for Connect. Data integrations use
Connectors
to specify the data model and logic for syncing data from a third-party or proprietary data source. Once you publish your data integration, users can install and configure it to start syncing data.
#
Enable Connect
To enable Connect,
contact our sales team
to request a demo.
Once enabled, the
Connect
page will be unlocked in the Netlify UI for your team.
#
Get started
Once a Sales team member has enabled Connect for your team, here’s how to get started:
Create your first data layer
with at least one data source and site connected.
Monitor the events
as we complete the initial data sync for your new data layer.
Use the GraphQL sandbox
to create and test queries against your data layer.
Generate an API token
to use in all requests to the GraphQL API.
Add code to your site to
query the GraphQL API
for your data layer and use the results in your site. For a better user and developer experience, use the
Connect client
for your queries.
Modify content in your data source,
review the data sync event
, and confirm that your connected sites rebuild to get the latest data.
Go back and edit your data layer to
add more data sources
and
add cross-references
. If you need to, you can also
access different data revisions
and
pin
a specific revision for your API to use. You can also add
API scopes
to restrict access to certain data and then
generate new API tokens
to access that data.
Repeat the above steps to
add additional data layers
, as needed.
#
Limitations
Connect logs are retained for 5 days
. All
sync events
are listed in the
Activities
section but the logs are currently retained for only five days.
Data revisions are retained for 60 days
. All
data revisions
are deleted after 60 days, except for the data revision that the API is currently using (by default or as a result of pinning).
Continuous deployment is required for site updates
. For Netlify to automatically build and deploy your site when data changes, your site must be
linked to a Git repository
to enable continuous deployment, and it must have
active builds
.
Data changes trigger only production branch builds for connected sites
. When data changes in your data layer, Netlify automatically builds and deploys the
production branch
of all connected sites. Currently, it’s not possible to specify a different branch to connect. But, you can
use notifications as a workaround
.
Responses to large queries do not get cached
. If your query is larger than 9 KB, the response will not be cached at the edge. Learn more about
how to adjust your queries
to ensure the responses are cached and data is returned faster.
#
More Connect resources
Video: introducing Netlify Connect
Video: Netlify Connect demo
Netlify SDK: build data integrations for Connect
Troubleshooting tips for Connect
Connect usage and billing
Connect JavaScript client
Last updated: March 28, 2025
Get started with Netlify Connect
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_sync-events.txt --------
Start of file
URL: https://docs.netlify.com/connect/sync-events/
Scraped_At: 2025-06-02T19:56:50.837461

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
Netlify Connect automatically syncs and updates your data layer to ensure that you always have access to the latest data.
This document covers the
types of sync events
that occur, what triggers
automatic data syncs
, and how to
trigger a sync manually
in the Netlify UI or through webhooks.
To learn how to access sync event logs and set up Slack notifications for failures, review
monitor activity
.
#
Sync event types
There are two types of events that can occur in Connect:
Sync from all data sources:
the system reads data source configurations, installs dependencies, and then retrieves data from all data sources. Once the data is retrieved, the system uses the information to build or update the GraphQL schema for the data layer
Sync from {data source type}:
the system retrieves data from the specified data source
Netlify does a full sync to set up or update your data layer when you create a new data layer and when you add or update
data source configurations
,
cross-references
, and
API scopes
. Netlify also does a full sync when you
manually trigger a sync
. When a full sync occurs, the event is
Sync from all data sources
.
When there is a data update, such as newly published content in your CMS, Netlify syncs the updated data source. If the
webhook notification
from the data source includes a header to specify that only that data source should update, the event is
Sync from {data source type}
. If not, the update will trigger a full sync and the event will be
Sync from all data sources
.
Each successful sync generates a new data revision. You can review all available data revisions in the
Revisions
section on the data layer’s overview page. Learn more about
data revisions
.
#
Automated syncs
One of the benefits of Connect is that it automatically updates your data layers to ensure they always have access to the latest data.
The API will use the pinned revision, even if syncs generate new ones
If you pin a data revision, successful syncs will continue to generate new revisions but the GraphQL API for your data layer will always use the pinned one.
Automated syncs occur in the following scenarios:
When you create a new data layer and when you add or update
data source configurations
,
cross-references
, and
API scopes
. This triggers a sync of all data sources and Netlify creates a new data revision and updates the GraphQL schema and API to reflect the change.
When data in a data source updates, such as when you publish new content in your CMS. Netlify is notified of the change and automatically creates a new data revision and updates your data layer.
#
Manual syncs
If you are troubleshooting and want to manually trigger a refresh of all data in your data layer, you can start a sync from all data sources through the Netlify UI or a webhook.
Note that if your data layer’s API is using a pinned data revision, Netlify will generate a new revision to reflect the data sync but the API will continue to use the old data. Make sure to unpin the old data revision and/or pin the new revision once the data refresh is complete.
#
Trigger a sync with the Netlify UI
Navigate to the
Connect
page for your team and select the data layer from the
Data layers
list.
In the
Activity
section, select
Trigger sync
>
Sync from all data sources
. Netlify will start syncing the data.
#
Trigger a sync with the webhook
You can use webhooks in external systems to trigger a sync in Connect. Learn more about how to
create and use webhooks
for your data layer.
#
Review data layer sync events
Netlify retains sync event logs for five days. Review the
monitor activity
doc to learn how to access logs for data layer sync events and how to set up Slack notifications for sync event failures.
Last updated: November 26, 2024
←
Access data
Monitor activity
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_troubleshooting-tips.txt --------
Start of file
URL: https://docs.netlify.com/connect/troubleshooting-tips/
Scraped_At: 2025-06-02T19:56:51.668589

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
This document provides troubleshooting tips for Netlify Connect.
#
Find your data layer ID
Need your data layer ID for a support conversation or for a manual set-up step for a data source? Once you add a data layer, you can find the ID in the URL for the data layer’s pages in the Netlify UI.
The URL is formatted as
https://app.netlify.com/teams/YOUR-TEAM-NAME/connect/data-layers/YOUR-DATA-LAYER-ID/...
If you are in the initial flow to create and configure a new data layer, you can find the ID for the data layer in the URL starting from the
add data sources step
.
If you have already created a data layer, the ID will appear in the URL as you navigate through the different Netlify UI pages for that data layer:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
Find the data layer ID in the URL.
#
Find your data layer’s webhook URL
Every data layer comes with a default
Webhook URL
that can be found in your
Data layer settings
under
General
>
Data layer information
. It is formatted as
https://webhook.netlify-connect.com/hooks/data_layer/data_source/publish/{data_layer_id}
.
However, we recommend generating a new authenticated webhook URL and using that instead. Learn more about how to
create and manage webhooks
for your data layer.
#
Find the slug for a data integration
While setting up a webhook on a data source or troubleshooting an error, you may need to refer to the slug for the data integration you’re using.
To find the slug:
Navigate to the
Extensions
page for your team.
Find the extension for the data integration and then select it.
Review the URL to find the slug, which is the last part of the URL.
For example, if the URL for the Drupal data integration is
https://app.netlify.com/teams/your-team-name/extensions/cms/drupal-content
, the slug is
drupal-content
.
#
Data integration for custom data source doesn’t show up as an option
If you try to add a custom data source to your data layer and the data integration for that data source doesn’t appear as an option in the Netlify UI, confirm that you have installed the integration for your team.
In the Netlify UI, navigate to the
Extensions
page for your team.
Find the data integration for the custom data source you wish to use and select it.
If it’s not already installed, select
Install
.
If you can’t find the data integration or the integration is already installed, work with the integration developer to ensure that it was
published correctly
.
If the above steps don’t seem to resolve this issue,
contact support
.
#
Other questions about custom data sources
For help with a custom data source, refer to the data integration’s details page in the Netlify UI and any external documentation the page links out to. You can find the details page by navigating to
Extensions
and searching for the integration by name.
If you have questions, please contact the integration developer directly.
#
Initial sync fails after configuring a data source
If you add a new data source and the initial sync isn’t successful, check the following:
Confirm that you completed the steps to prepare your data source instance for Connect, if applicable. To review the preparation steps, check our documentation on
how to add new data sources
and filter for the data source type to reveal the instructions. If there are additional steps to take, the instructions include a section with a title that begins with
Prepare
, such as
Prepare your Contentful instance
.
Confirm that the configuration details entered for your data source instance are correct. To review your settings:
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Data sources
.
Select the data source you want to review.
If there are any errors, select
Edit
, update the fields as needed, and then select
Save
.
After you make any changes,
manually trigger a sync
.
If the above steps don’t seem to resolve this issue,
contact support
.
#
Changes in data source don’t trigger a sync
Connect relies on your data source to send a notification whenever data changes. If a change does not trigger a sync in Connect, check the settings on your data source:
Confirm that a
webhook with your data layer’s webhook URL
exists. If a webhook doesn’t exist, you likely need to add one manually. This is often a prerequisite step for adding a data source to Connect, especially custom data sources. Review our documentation on how to
add and configure data sources
.
Confirm that the webhook is set to trigger on the data types and events you want to sync. For example, you may be missing a “product” type or a “delete” event. Refer to the documentation for your data source to learn more about configuring webhooks on their system.
Confirm that the webhook is enabled.
If the above steps don’t seem to resolve this issue,
contact support
.
#
Handle large Contentful or WordPress payloads
If you encounter errors syncing a Contentful data source due to the payload size,
edit the data source
to lower the
Page limit
value from the default of
1000
so that data is retrieved in smaller batches.
Similarly, if your WordPress data source has errors due to the payload size,
edit the data source
to lower the
Per page
value from the default of
100
so that data is retrieved in smaller batches.
#
Responses from the data layer API are slow
Responses to queries that are larger than 9 KB are not cached. If a large response is not cached, each subsequent query for the data will take a similar length of time to process.
To get maximum performance from your data layer’s API, we recommend that you take advantage of pagination by using
skip
and
limit
filters in your queries. If that’s not possible, consider making multiple small queries that return smaller response bodies, which can be cached separately.
Note that a data sync clears the edge cache entries for the modified data and that updates to more than 100 or so entries purge the cache for the entire data layer. As a result, initial queries following a data sync may take longer than usual.
Learn more about
how we calculate query complexity
.
#
Clear database cache and sync again
If you are debugging an issue and want to clear out your data layer’s database and start fresh, you can use the clear cache option.
Navigate to the
Connect
page for your team and select the data layer from the
Data layers
list.
In the
Activity
section, select
Trigger sync
>
Clear cache and sync from all data sources
.
Netlify will clear the database cache and start syncing the data from all sources again to create a fresh database for your data layer.
#
Sync event is complete but the API reflects old data
If the
Activity
section reflects a successful data sync but the data layer API still reflects old data, make sure your API isn’t using a pinned data revision. If a data revision is pinned, successful syncs will continue to generate new data revisions but the API will always use the pinned version.
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list.
Check the data layer overview to confirm whether or not the API is using a
pinned
revision.
If a specific data revision is pinned and you want to check the data in a revision before unpinning or updating the pin, you can
query the data for that specific revision
.
#
Trigger builds automatically for a specific branch
When data changes in your data layer, Netlify automatically builds and deploys the
production branch
of all connected sites. Currently, it’s not possible to specify a different branch when you connect a site.
If you would like to trigger builds for a different branch, you can follow this workaround to create a Netlify
build hook
and add it as a
notification
to your data layer.
First, create a build hook for your site. Navigate to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build hooks
.
Select
Add build hook
.
Enter a
Build hook name
and select the
Branch to build
, then select
Save
.
Find the new build hook in the list and copy the webhook URL.
Now, create a notification for your data layer. Navigate to the
Connect
page for your team.
Select the data layer from the
Data Layers
list, and then select
Data layer settings
.
On the data layer settings page, select
Notifications
.
Select
Add a notification
.
Enter a
Name
for this notification.
Paste the copied build hook into the
URL
field.
Select
Create notification
to add the notification to your data layer.
Now, whenever your data layer updates, Netlify automatically triggers the notification. The notification then triggers the build hook to start a new build and deploy for the specified branch.
#
API query does not return the expected types and fields
If you make a query to your data layer’s API and not all of the data you expect is returned, make sure your API token has the correct scopes for that data.
Navigate to the
Connect
page for your team in the Netlify UI.
Select the data layer from the
Data layers
list, and then select
Data layer settings
.
On the data layer settings page, select
API access control
.
In the
API scopes
section, find the scope for the data required.
Select the scope to expand the details and review the list of tokens, fields, and types that the scope applies to.
If your token is not on the list, use one of the tokens listed instead. Or
generate a new token with that scope
.
#
Get help with Connect client
If you use the
Connect client
to query your data layer’s GraphQL API, refer to the
connect-client
readme
for troubleshooting tips and support.
Last updated: May 13, 2025
←
Monitor activity
Usage & billing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- connect_usage-and-billing.txt --------
Start of file
URL: https://docs.netlify.com/connect/usage-and-billing/
Scraped_At: 2025-06-02T19:56:52.585925

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
You can check your Netlify Connect service usage at the top of the your team’s
Connect
page in the Netlify UI. This shows your current usage level and tracks the following metrics:
Bandwidth:
total bandwidth used by your team’s data layers in Connect. This bandwidth factors into your
team’s overall bandwidth usage metric
.
Data layers:
the number of data layers configured on your team.
Data sources:
the number of data sources configured across all data layers on your team.
You can monitor which data layers use the most bandwidth under
Billing
>
Bandwidth usage data
. Scroll down and select the caret next to
Top bandwidth usage per Netlify Connect data layer
for a list of
data layer IDs
and the bandwidth used by each data layer. Bandwidth usage data updates in near real-time and may require a browser refresh.
Visit our
pricing page
to learn more about Connect pricing, including feature limits and add-ons. When your team’s usage reaches a feature limit, our
Sales team
will contact you to discuss next steps
#
More usage and billing resources
Billing FAQ
Billing
Last updated: May 29, 2024
←
Troubleshooting tips
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- create_get-started.txt --------
Start of file
URL: https://docs.netlify.com/create/get-started/
Scraped_At: 2025-06-02T19:56:53.521156

Contact
Forums
Contact support
Get started with the Netlify Visual Editor by choosing your setup path and checking that your site meets the requirements to use the visual editor.
Netlify Visual Editor is an environment for content editors to work with structured content in a visual way. It is designed for composable architectures, and is compatible with any site framework and API-enabled content source.
The visual editor is optimized for giving Developers the most flexibility in setting up a visual editing environment and custom workflow for a Content team.
This allows
Content editors and other custom roles
to build new pages with ease and publish content in a streamlined workflow.
Learn more about
how the visual editor works
or learn as you go by getting started.
#
Setup pathways
There are several ways to start setting up the visual editor. We recommend you set up in different ways based on what you are optimizing for.
Optimizing for
Site Type
Setup guide
Fastest way to try out visual editor experience on Netlify with new site
New site using a pre-configured template
Visual Editor Quickstart
Configuring more than one content source & advanced customization
An existing site or new template site
Set up visual editor locally
Existing sites deployed on Netlify with simpler customization
Existing sites
Visual editor walkthrough setup guide
After your initial setup of the visual editor, we recommend you customize the visual editor for your site and workflow needs. Learn more in the
customize editing experience docs
.
#
Visual Editor Support Requirements
For the most success getting visual editing working for your site, you should have the following:
Site framework
that runs a development server on a local port using Node.js v16 or later.
Content stored in
a supported headless CMS
or in individual content files separated from code.
If your site doesn't meet these requirements, you can likely still get visual editing working with additional code and configuration.
Contact us
for help.
#
Site repository requirements
When you set up the visual editor for your site you need to have access to the site repository, including the remote site repository once your site is deployed to Netlify.
The visual editor only supports site repository syncing from these Git providers at this time:
GitHub
BitBucket
Your site repository also needs a unique working branch for visual editor changes. The default working branch is
preview
.
#
Content source requirements
If using an API-based CMS, you must also have a user account with read and write access to that content source.
If using file-based content, the content must be defined by a schema that the visual editor can understand. This requires adding
content modeling properties
to your visual editor configuration file. We'll cover a bit on configuration later in this guide.
Learn more about how Visual Editor works with structured content
.
#
Example template sites
Explore a template site pre-configured for visual editing. Consider starting with the quickstart or local setup guide for a template site that is closer to your site’s needs.
Site repository
Content source
Optimized for
TypeScript + MUI Starter
Git CMS
- a tutorial-like experience
- learning about visual editor capabilities
ContentOps Starter
Git CMS
- learning about content types with over 35 content types
- try more complex content type scenarios
Auto-annotated portfolio
Git CMS
- learning about auto annotating your site
- lots of auto annotated components
Next.js & Contentful Starter
Headless CMS: Contentful
getting started with Contentful
Astro & Sanity Starter
Headless CMS: Sanity
getting started with Sanity
#
Troubleshooting help
For help getting the visual editor setup, check out
troubleshoot visual editor setup
.
Last updated: January 31, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- create_overview.txt --------
Start of file
URL: https://docs.netlify.com/create/overview/
Scraped_At: 2025-06-02T19:56:54.804625

Contact
Forums
Contact support
Netlify Visual Editor is an environment for content editors to work with structured content in a visual way. It is designed for composable architectures, and is compatible with any site framework and API-enabled content source.
Learn more about how Visual Editor works and what it can do for your team below. Or move on to
enable visual editing for your site
.
#
Key visual editing features
Content Source Interface:
an engine that makes content from any source editable with Visual Editor.
No production dependencies:
all required packages can be installed as development dependencies. You do not need to use Visual Editor in production.
Visual editing:
your site runs in a preview window inside Visual Editor. Content changes are reflected immediately in the preview.
Two-way content sync:
Visual Editor also listens for changes from content sources and updates the preview immediately.
Inline editing:
in addition to traditional form fields, Visual Editor makes it possible for editors to change content by clicking directly on elements in the preview window.
#
Learn how Visual Editor works
If you want a deeper understanding of how Visual Editor works, dig into our concept guides:
Visual Editor concepts overview
:
a deeper dive into how Visual Editor fits into your modern web stack and how its major elements work.
How the visual editor works
:
walk through the core concepts of how Visual Editor works by following a developer’s typical journey.
Content-driven development
:
empowering non-technical editors to make structural changes to a website without the help of a developer.
Reusable content
:
help content editors work faster by providing a starting point for content.
Structured content
:
how Visual Editor works with structured content, along with content modeling basics.
Two-way content sync
:
Visual Editor stores content back to the appropriate source, while also listening for changes from each source.
#
Supported tools, services, and frameworks
As part of the Netlify platform, Visual Editor supports most tools, services, and frameworks supported by Netlify. Find more information below on details specific to Visual Editor.
#
Supported frameworks
The visual editor is run in a Node-based environment by default, but can be customized to run any framework. Local development supports any framework that runs on a local port.
Enabling automatic content reloading (showing content updates in real-time in the visual editor UI) may require additional code and configuration in some frameworks. See
framework integration guides
for specific cases.
#
Supported content sources
Content Source Interface (CSI) supports any structured content source with read and write abilities via an API.
There are several content sources
supported by default
, though you can always
build your own CSI module
or
contact us
for additional support.
#
Unsupported tools
Visual Editor is designed to be composable and flexible, and we’re always working to expand our integrations. If your tool isn’t supported,
get in touch
to discuss your needs.
It is likely that if we aren’t already working on support for your desired integration, you can create the necessary support through code and configuration.
Last updated: January 29, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- create_visual-editing.txt --------
Start of file
URL: https://docs.netlify.com/create/visual-editing/
Scraped_At: 2025-06-02T19:56:55.490138

Contact
Forums
Contact support
Understand methods for adjusting code and content in Visual Editor.
#
Editing methods
The visual editor is an editing application that provides three different ways to directly edit code and content.
Page Editor
: editing panel that changes based on the context of the current page in the preview.
Content Editor
: classic CMS mode, with the ability to edit content within page and data models.
Inline Editor
: highlights around elements in the preview that enable direct, in-place editing.
While inline editing is done directly on the preview, all others are enabled through icons on the left sidebar in the visual editing application.
#
Page editor
The page editor is a panel on the left side of the screen that changes context based on actions taken within the preview and sitemap navigator.
Learn more about Visual Editor’s page editor
#
Content editor
The content editor provides a means to quickly edit structured pages and data objects. This is similar to traditional form-based editing within a CMS.
Learn more about Visual Editor’s content editor
#
Inline editor
Visual Editor provides the ability to make changes directly in the preview by clicking directly on editable content.
Learn more about Visual Editor’s inline editor
#
Editor extensions
These editing methods can be further customized with various editing features.
Sidebar Shortcuts
customize sidebar buttons in Visual Editor.
Field Controls
: how form fields are displayed for content editors.
Field Groups
: tidy up form fields into tabbed groups.
Custom Fields
: bring your own field controls.
#
Sidebar shortcuts
Custom buttons can be added to the sidebar as direct links and shortcuts to content or editing controls.
Learn more about customizing the sidebar
#
Field controls
Visual Editor infers field editor controls as best as possible. Fields can then be further customized through model extensions.
Learn more about customizing field controls
#
Field groups
Fields can be broken up into tabbed groups for better organization when using the page or content editors.
Learn more about grouping fields
#
Custom fields
When the default field controls are not enough, you can bring your own custom field controls.
Learn more about custom fields
#
Additional features
This section contains additional features to aid with visual editing.
#
Document statuses
Document titles are paired with labels (in some cases) to indicate their current status, providing a quick visual representation of the state of content.
Learn more about document status labels
Last updated: July 15, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_add-a-domain-alias.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/add-a-domain-alias/
Scraped_At: 2025-06-02T19:56:56.385478

Contact
Forums
Contact support
Ensure your site is available at all the expected domains by assigning multiple custom domains to your production site as domain aliases.
You can assign multiple custom domains to the same production site. When you do this, one is designated as the
primary domain
, and all others are called
domain aliases
.
We recommend assigning no more than 50 domain aliases to a site.
To add a domain alias:
For your site, go to your site configuration settings under
Domain management
>
Production domains
.
Select
Add domain alias
, and follow the prompts to assign the domain to your site.
Optionally, to change a domain alias to the primary domain, select the
Options
button next to the domain, then select
Set as primary domain
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_bring-a-domain-to-netlify.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/bring-a-domain-to-netlify/
Scraped_At: 2025-06-02T19:57:00.079318

Contact
Forums
Contact support
Bring an existing domain you’ve already registered to Netlify DNS and set it as a custom domain for your production site.
#
Step 1: Add custom domain to your Netlify site
Go to your Site Overview dashboard in Netlify and in the left sidebar, select
Domain management
.
Select
Add domain
, then
Add a domain you already own
.
Enter your domain and select
Verify
. Next, confirm with
Add domain
.
The custom domain you added will be the primary domain for your production site by default.
#
Step 2: Update your DNS configuration
The next steps will vary depending on your DNS provider, domain, and the DNS records you need but here is a general overview.
Go to the DNS provider settings for your custom domain.
Based on the custom domain you entered, you typically need to add a new DNS record for your domain.
Which DNS record type?
It’s important you understand the DNS record type you need. Check out your DNS provider’s documentation or our
DNS reords docs
for help.
Select or enter the DNS record type you need, add your custom domain or subdomain.
In Netlify, go to your domain dashboard for your site and select
Awaiting External DNS
next to your custom domain. You’ll find more details there you can use to set up your custom domain. These details are customized for your domain.
For example, you may find this instruction:
Create an A record for blueberry.com pointing to our load balancer’s IP address 75.2.60.5.

blueberry.com A 75.2.60.5
You can copy the value
75.2.60.5
to add to an A record in your DNS provider for blueberry.com.
For more detailed help, check out
Configure external DNS
.
#
Step 3: (Optional) Verify your setup
After updating your DNS settings, you may need to wait up to 48 hours for your changes to take full effect.
In the meantime, you can re-review your setup and then verify your DNS propagation is working with the
dig
command in your terminal.
For example:
dig YOUR-DOMAIN @DNS-IP-ADDRESS
Or you can try a Dig lookup site like
https://www.digwebinterface.com/
.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_configure-an-automatic-subdomain-for-deploys.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/configure-an-automatic-subdomain-for-deploys/
Scraped_At: 2025-06-02T19:57:00.992606

Contact
Forums
Contact support
With automatic deploy subdomains, you can set up automatically branded URLs for Deploy Previews or branch deploys — unifying your site’s preview environments, auth flows, third-party services, and other site versions with a shared custom domain.
Automatic deploy subdomains are a type of custom domain that you can set for all Deploy Previews or all branch deploys.
#
Use cases
When you set up an automatic deploy subdomain for all of your Deploy Previews or branch deploys, you can:
Share branded deploy URLs that don’t include the Netlify subdomain. For example, build greater trust with your stakeholders by sharing
deploy-preview-42.company.com
instead of
deploy-preview-42--yoursitename.netlify.app
.
Use third-party services the way you do for your production site, such as auth flow services that rely on a custom domain.
Ensure deploys are “trusted” and in the “allowed domain list” for any third-party scripts or services that require this.
Meet internal security requirements while leveraging Netlify’s Deploy Previews and branch deploys to preview and collaborate on changes before they go live.
Once you configure an automatic deploy subdomain, Netlify uses this custom domain for your Deploy Previews and/or branch deploys by default within the Netlify UI, the API, CLI, and deploy notifications.
#
Domain requirements
The custom domain you set as your automatic deploy subdomain must be managed by
Netlify DNS
and available to your team.
By default, domains managed by Netlify DNS can be applied to your Deploy Previews or branch deploys.
For example, if you already delegated
company.com
to Netlify DNS, then subdomains of
company.com
, such as
early-access.company.com
, are also delegated to Netlify DNS by default. That means you can use
early-access.company.com
as your automatic deploy subdomain.
If you want to use a custom domain that Netlify DNS does not already manage, add the custom domain to your Netlify team and configure it to be managed by Netlify DNS. Learn more in these
domain setup steps
.
Want to use a subdomain without bringing the apex domain to Netlify DNS?
You can bring a subdomain to Netlify DNS without the apex domain. For example, you can delegate
docs.company.com
to Netlify DNS without also delegating
company.com
. Learn more about
stand-alone subdomain support
.
#
Example deploy URLs
Site deploys
Netlify subdomain
Automatic deploy subdomain
Deploy Preview
deploy-preview-42--yoursitename.netlify.app
deploy-preview-42.company-internal-testing.com
Branch deploy
, e.g.
staging
branch
staging--yoursitename.netlify.app
staging.company-internal-testing.com
Atomic deploy permalink
Uses the Netlify subdomain and a deploy ID, such as
1234abcd12acde000111cdef--yoursitename.netlify.app
.
N/A
When you set an automatic deploy subdomain for all Deploy Previews or all branch deploys, your deploys are still accessible at the Netlify subdomain, such as
deploy-preview-42--yoursitename.netlify.app
or
staging--yoursitename.netlify.app
.
Using High-Performance Edge?
If your site is on the
High-Performance Edge
, then automatic deploy subdomains are served from the High-Performance Edge. However, Netlify subdomains (
*.netlify.app
) are always served from the standard network.
Your
deploy permalinks
, which offer unique URLs for successful deploys of your site, will continue to use the Netlify subdomain. Unlike other deploy URLs, deploy permalinks do not update with new Git commits. Instead, Netlify generates new deploy permalinks for each successful deploy of your site.
Not sure if you want to use Deploy Previews or branch deploys?
Deploy Previews are scoped to a pull/merge request while branch deploys are scoped to a branch. Branch deploys can offer a longer-standing URL than Deploy Previews since they are based on the branch name and not the pull/merge request. Learn more about the difference between these deploys in these
docs
.
#
Automatic deploy subdomains for Deploy Previews
Deploy Previews are automatically enabled for all sites using continuous integration with Netlify. If your site doesn’t have Netlify continuous integration set up, check out
these docs
.
#
Set an automatic deploy subdomain for Deploy Previews
To set up an automatic deploy subdomain for your site’s Deploy Previews:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Deploy Previews
, select
Add custom domain
.
Under
Domain
, you’ll find domains managed by Netlify DNS. Select your chosen custom domain. Optionally, enter an additional subdomain, such as
early-access
or
qa
.
Want to use a different domain?
If you can’t find the domain you want to add in the drop-down menu, check out these docs for
adding a new custom domain
.
Review the preview of the deploy URL for your Deploy Previews. To confirm,  select
Save
.
Once saved, Netlify updates the domain for all open Deploy Previews. If you applied a custom domain that is not already live as your primary site domain (or does not already have a security certificate), then your new deploy URL may take up to 24 hours to resolve and work with HTTPS.
#
Automatic deploy subdomains for branch deploys
Branch deploys are often used for maintaining a separate version of your site for QA, internal testing, or even to manage different versions of site content for different audiences or product versions.
If you are already using
branch subdomains
, check out
our branch subdomain comparison docs
to understand the key differences between these subdomains and how they can work together.
If you set up an automatic deploy subdomain for branch deploys on your site, then each branch deploy will generate the same automatic deploy subdomain and include your branch deploy’s unique branch name.
#
Prerequisites
To set up an automatic deploy subdomain for your site’s branch deploys, you must first enable branch deploys for your site.
To enable branch deploys for your site, go to
Project configuration
>
Build & deploy
>
Branches and deploy contexts
.
Select
Configure
.
Next to
Branch deploys
, set up branch deploys for a specific branch or for all non-production branches. To confirm, select
Save
.
Once branch deploys are enabled, create a new branch and push a commit to this branch in your connected site repo. Netlify will automatically generate a branch deploy, which you can preview in your site’s deploy list.
Created a deploy with the CLI?
If you created a deploy using the
Netlify CLI’s
--alias
flag
, then be aware that these deploys are not branch deploys and do not support branch subdomains or automatic deploy subdomains. We recommend you avoid using
--alias
with any of your branch names.
#
Set an automatic deploy subdomain for branch deploys
To set up an automatic deploy subdomain for your site’s branch deploys:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Branch deploys
, select
Add custom domain
.
Under
Domain
, you’ll find domains managed by Netlify DNS. Select your chosen custom domain. Optionally, enter an additional subdomain, such as
early-access
or
qa
.
Want to use a different domain?
If you can’t find the domain you want to add in the drop-down menu, check out these docs for
adding a new custom domain
.
Review the preview of the deploy URL for your branch deploys. To confirm,  select
Save
.
Once saved, Netlify updates the domain for all active branch deploys. If you applied a custom domain that is not already live as your primary site domain (or does not already have a security certificate), then your new deploy URL may take up to 24 hours to resolve and work with HTTPS.
#
Choose a unique URL for your branch deploys
It is possible to configure automatic subdomains for branch deploys so that a branch subdomain conflicts with another site’s production domain. Since Deploy Previews are appended with the pull/merge request number, their automatic subdomains are unlikely to conflict with other domains.
For example:
Site A has a primary site domain of
staging.company.com
for the production site.
Site B has an automated domain of
staging.company.com
for its
staging
branch.
When there is a conflict, domains listed in your
Production domains
settings will take precedence over other internal domains. So in this example,
staging.company.com
will resolve to the content of site A.
To prevent accidental domain duplication, you might choose to add another subdomain level to your branch subdomains that is not used in production, such as
internal
in
staging.internal.company.com
.
If you get a domain conflict, you can rename the branch. For example, you can rename the branch from
staging
to
qa
. Then, the next time you deploy this branch, it would use the
qa.company.com
domain.
#
Limitations for sites with existing branch subdomains
Once you add an automatic deploy subdomain for branch deploys, you cannot edit or change existing manual
branch subdomains
. You also cannot manually add new branch subdomains, but existing branch subdomains will still work.
If you configured branch subdomains before enabling automatic deploy subdomains, both the branch subdomains and automatic deploy subdomains will resolve and be available. If both are set up, the Netlify UI, CLI, API, and deploy notifications will link to the automatic deploy subdomain by default.
To make changes to your branch subdomain, you must
remove the automatic deploy subdomain
first.
If you want to compare using branch subdomains with automatic deploy subdomains, check out our
comparison docs for applying a custom domain to a branch deploy
.
#
Use a new custom domain for your automatic deploy subdomain
By default, you can choose primary site domains that are also managed by
Netlify DNS
as your automatic deploy subdomain. You can also add additional subdomains to these domains, such as
early-access
or
qa
.
If you want to use a custom domain that is not listed in the Netlify UI, you must first delegate this domain to Netlify DNS.
Want to use a subdomain without bringing the apex domain to Netlify DNS?
You can bring a subdomain to Netlify DNS without the apex domain. For example, you can delegate
docs.company.com
to Netlify DNS without also delegating
company.com
. Learn more about
stand-alone subdomain support
.
To delegate a new domain to Netlify DNS:
In the Netlify UI, navigate to your team’s
Domains
page.
Select
Add or register a domain
.
Enter your domain, and follow the UI prompts to delegate your domain to Netlify DNS. The UI may prompt you to add this domain to Netlify DNS.
DNS updates can take up to 24 hours to take effect. On occasion, DNS record changes can take longer than this to propagate. Learn more in our
Support Guide on DNS propagation
.
Once you have delegated your domain to Netlify DNS, your new domain should appear as a new drop-down menu option when you add your automatic deploy subdomain.
#
Use the Netlify API to set automatic deploy subdomains
You can set automatic deploy subdomains when you create a site using the Netlify API. In your
createSite
request, use the following query parameters to pass the values to use for the subdomains:
deploy_preview_custom_domain
branch_deploy_custom_domain
Note that when you create or update a site with an automatic deploy subdomain, the build environment variable
DEPLOY_PRIME_URL
will update for all relevant deploys. Learn more about
DEPLOY_PRIME_URL
.
#
Custom certificate requirements
If you use a
custom certificate
for your site’s domains, that certificate must explicitly include any new subdomains used for automatic deploy subdomains. The standard wildcard syntax, such as
*.company.com
, does not cover this new subdomain.
For example, your custom certificate will not work as expected in this scenario:
you have
early-access.company.com
as your automatic deploy subdomain, where
early-access
is the optional new subdomain you
added in the Netlify UI
you have a custom certificate with
*.company.com
as your wildcard domain but not
*.early-access.company.com
In this scenario, you must update your certificate to include the domains
*.company.com, *.early-access.company.com
so that
early-access.company.com
will work as expected.
#
Remove an automatic deploy subdomain
To remove an automatic deploy subdomain from your Deploy Previews or branch deploys:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Branch deploys
or
Deploy Previews
, clear the
Add custom domain
checkbox.
To confirm,  select
Save
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_configure-external-dns.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/configure-external-dns/
Scraped_At: 2025-06-02T19:57:02.012814

Contact
Forums
Contact support
If you’ve assigned an externally registered domain to your site, and you don’t want to use
Netlify DNS
, you need to configure your external DNS provider to point your domain to Netlify.
To access customized details about the DNS records you need to configure, go to
Domain management
>
Production domains
and select
Awaiting External DNS
next to the custom domain.
The next steps vary depending on the type of domain or subdomain.
For a
subdomain
of a domain you own, such as
blog.petsofnetlify.com
or
www.petsofnetlify.com
, follow the directions below for
subdomain configuration
.
For an
apex domain
with no subdomain, such as
petsofnetlify.com
, make sure to read our
advice about using apex domains
, then follow the directions below for
apex domain configuration
.
Special handling for apex and
www
If you assign an apex domain or a
www
subdomain to your site, Netlify will automatically add
both
the apex domain and the
www
subdomain. This means you should follow directions for both
configuring a subdomain
and
configuring an apex domain
. For more information, visit the section on
apex domains and
www
subdomains
.
Need to delegate just a subdomain?
You can delegate a subdomain to Netlify DNS without the apex domain. Learn more in this
doc
.
#
Configure a subdomain
To point a subdomain such as
blog.petsofnetlify.com
or
www.petsofnetlify.com
to your site on Netlify, you must first
add the domain to your site
on Netlify and then create a CNAME record with your DNS provider.
For example, if your site’s domain is
blog.petsofnetlify.com
and your
Netlify subdomain
is
brave-curie-12345.netlify.app
:
Follow the instructions to
add the domain
blog.petsofnetlify.com
to the
brave-curie-12345.netlify.app
site on Netlify. At the end of the process, Netlify provides a CNAME record to add to your DNS provider.
Find your DNS provider’s DNS record settings for your apex domain,
petsofnetlify.com
.
On your DNS provider’s site, add the CNAME record with your subdomain,
blog
, as the host.
Point the record to your Netlify subdomain,
brave-curie-12345.netlify.app
.
High-Performance Edge uses a different subdomain
If your site is on the High-Performance Edge, point the record to the dedicated subdomain in your High-Performance Edge onboarding PDF.
Save your settings. It may take a full day for the settings to propagate across the global Domain Name System.
If your site uses the
www
subdomain, as in
www.petsofnetlify.com
, you will use the same procedure described above. Once you configure the
www
subdomain, an apex domain will also be added automatically to your site. You’ll need to follow the steps in the section below to configure the apex domain too. Learn more about our
special handling for
www
subdomains
.
#
Configure an apex domain
Unlike subdomains, apex domains don’t support CNAME records. You must configure your apex domain with an ALIAS, ANAME, flattened CNAME, or A record. Different DNS providers support different record types. Depending on what your DNS provider supports, use either the recommended configuration or the fallback option below.
If your
DNS provider supports ALIAS, ANAME, or flattened CNAME records
, use this recommended configuration, which is more resilient than the fallback option.
Find your DNS provider’s DNS record settings for your apex domain, such as
petsofnetlify.com
.
Add an
ALIAS
,
ANAME
, or
flattened CNAME record
. Depending on your provider, leave the host field empty or enter
@
.
Point the record to Netlify’s load balancer at:
apex-loadbalancer.netlify.com
.
High-Performance Edge uses a different load balancer
If your site is on the High-Performance Edge, point the record to the High-Performance Edge load balancer noted in the
Awaiting External DNS
modal’s customized details
.
Save your settings. It may take a full day for the settings to propagate across the global Domain Name System.
If your DNS provider does not support ALIAS, ANAME, or flattened CNAME records, use this fallback option.
Find your DNS provider’s DNS record settings for your apex domain, such as
petsofnetlify.com
.
Add an
A record
. Depending on your provider, leave the host field empty or enter
@
.
Point the record to Netlify’s load balancer IP address:
75.2.60.5
.
High-Performance Edge uses a different load balancer
If your site is on the High-Performance Edge, point the record to the High-Performance Edge load balancer IP address noted in the
Awaiting External DNS
modal’s customized details
.
Save your settings. It may take a full day for the settings to propagate across the global Domain Name System.
In both cases, the apex domain eventually resolves to our load balancer IP address. This means the apex domain can’t take advantage of direct DNS routing on a
global CDN like Netlify’s
. Because of this, we recommend using a subdomain for your
primary domain
when using external DNS.
Special handling for apex domains
If you assign an apex domain to your site, Netlify will automatically add a
www
subdomain for the domain as well, which requires the
subdomain configuration
as described above. To find out how this affects your site configuration, visit the section on
apex domains and
www
subdomains
.
#
DNS record propagation
Depending on your DNS provider,
changes to DNS records can take several hours to propagate and take effect for the entire internet.
If more than 24 hours have passed since you configured your DNS records, and your site is still not accessible at your custom domain, try our
DNS troubleshooting tips
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_delegate-a-standalone-subdomain.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain/
Scraped_At: 2025-06-02T19:57:03.320597

Contact
Forums
Contact support
You can bring just a subdomain to Netlify DNS and keep your apex domain on a separate domain registrar. This makes all the benefits of Netlify DNS available to your subdomain, including automated wildcard SSL certificates and expanded use cases for your site with branch subdomains.
For example, you can delegate
docs.example.com
to Netlify DNS and keep
example.com
on a different
domain registrar
.
If you delegate the stand-alone subdomain
docs.example.com
to Netlify DNS, your site gains these advantages:
Automatic site security benefits.
Netlify DNS provisions your subdomain, and all subdomains of your subdomain, with
wildcard SSL certificates
.
More use cases with branch subdomains.
Your site can serve different content from different branches using
branch subdomains
. For example, the
staging
branch of your site can serve unique content at
staging.docs.example.com
. Likewise, your site’s
beta
branch can serve unique content at
beta.docs.example.com
.
Wider reach with IPv6 support.
Your subdomain can reach a wider audience with
IPv6
, which you can enable for your subdomain in the Netlify UI.
Performance gains with the Netlify CDN.
Your site will be served from our global CDN, from the server closest to your site visitors. Between this and CDN-level routing, sites will often gain a performance boost from being served on the Netlify CDN.
#
Netlify DNS support for subdomains and apex domains
When you add an
apex domain
to Netlify DNS, subdomains of this apex domain are managed by Netlify DNS automatically.
If you delegate a stand-alone subdomain to Netlify DNS, additional configuration is required outside of Netlify. You will need to access the domain registrar for the related apex domain to set NS records (
Name Server records
for your subdomain.
For example, if you’ve already added the apex domain
petsofnetlify.com
to Netlify DNS and you add the subdomain
rover.petsofnetlify.com
to your site on Netlify, then Netlify DNS will automatically manage this subdomain for you.
Alternatively, if you have an apex domain that is already managed by an external domain registrar, such as
example.com
, and you want to bring just the subdomain
docs.example.com
to Netlify DNS, then you need to follow the steps below.
#
Delegate a stand-alone subdomain to Netlify DNS
There are two main starting places in the Netlify UI to delegate just a subdomain to Netlify DNS:
From your team’s Domains page:
If you have access to your team’s
Domains
page, then you can delegate a subdomain to Netlify DNS for your team and use this subdomain for one of your team’s sites. This flow allows you to wait for DNS propagation to complete before adding this subdomain to your site.
From your site configuration:
If you only have access to a single site or want to add a subdomain directly to a site before the domain is live and then delegate it to Netlify DNS, then you can manage this through your site’s
Domain management
configuration.
Avoid
www
as a stand-alone subdomain
We recommend that you do not delegate
www
as a stand-alone subdomain. Netlify treats
www
subdomains and apex domains as alternates for each other. Attempts to delegate
www
as a stand-alone subdomain may lead to inconsistent behavior if one site is using the
www
subdomain while another uses the apex domain.
#
Delegate a subdomain to Netlify DNS for your team
When you delegate a subdomain to Netlify DNS through your team’s
Domains
page, this domain is available to any of your team’s sites.
If you haven’t already, check the
domain registrar
that manages your apex domain to make sure it supports NS records for subdomains. You will need to access this domain registrar to update the NS records for your subdomain later in these steps.
In the Netlify UI, navigate to your team’s
Domains
page.
Select
Add or register a domain
.
Enter your subdomain, such as
docs.example.com
, and follow the UI prompts to delegate this subdomain to Netlify DNS.
To complete your subdomain delegation setup, copy the NS records for your subdomain from the Netlify UI. Log in to the domain registrar that manages the related apex domain, such as
example.com
, and enter NS records for your subdomain.
DNS updates can take up to 24 hours to take effect. On occasion, record changes can take longer than this to propagate. Learn more in our
Support Guide on DNS propagation
.
Once you are ready to add your subdomain to a specific site, navigate to your team’s
Projects
page in the Netlify UI and select your project in the list.
Go to
Domain management
.
Select
Add a domain
and enter the stand-alone subdomain, such as
docs.example.com
, that you already delegated to Netlify DNS in the last steps.
Select
Verify
, then
Add subdomain
. Now the subdomain that you delegated to Netlify DNS is connected to your site.
#
Delegate a subdomain to Netlify DNS through site configuration
When you delegate a subdomain to Netlify DNS through your site configuration, we recommend you add your stand-alone subdomain and then delegate this domain to Netlify DNS.
Check the
domain registrar
that manages your apex domain to make sure it supports NS records for subdomains. You will need to access this domain registrar to update the NS records for your subdomain later in these steps.
Navigate to your site and go to
Domain management
.
Select
Add custom domain
.
Enter your stand-alone subdomain, such as
docs.example.com
. This flow assumes that your subdomain stems from an apex domain, such as
example.com
, that is already registered through an external domain registrar.
Select
Verify
, then
Add subdomain
. Now this subdomain is connected to your site but is not yet delegated to Netlify DNS.
To delegate your subdomain to Netlify DNS, next to your subdomain, use the
Options
menu to select
Set up Netlify DNS
.
Follow the UI prompts to delegate your subdomain to Netlify DNS. During this UI flow, you may be asked to select
Verify
and
Add subdomain
again.
To complete your subdomain delegation setup, copy the NS records for your subdomain from the Netlify UI. Log in to the domain registrar that manages the related apex domain, such as
example.com
, and enter NS records for your subdomain.
These DNS updates can take up to 48 hours to take effect. Learn more in our
Support Guide on DNS propagation
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_dns-records.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/dns-records/
Scraped_At: 2025-06-02T19:57:04.137555

Contact
Forums
Contact support
DNS records are rules that tell domain name servers how to handle traffic to your domains and subdomains.
For domains managed by Netlify, we will automatically create “NETLIFY” records that point to our servers when you assign a domain or subdomain for your site. To learn more, visit our Forums for a verified support guide on
this type of DNS record
.
You can also add your own DNS records to point to other services, such as an email provider. Visit our Forums for a verified Support Guide on
how to receive emails on your domain
.
#
Supported record types
Netlify DNS supports the following types of records:
A
: Address record, which is used to map host names to their IPv4 address.
AAAA
: IPv6 Address record, which is used to map host names to their IPv6 address.
CAA
: Certificate Authority (CA) Authorization, which is used to specify which CAs are allowed to create certificates for a domain.
CNAME
: Canonical name record, which is used to specify alias names.
MX
: Mail exchange record, which is used in routing requests to mail servers.
NS
: Name server record, which delegates a DNS zone to an authoritative server.
SPF
: Sender Policy Framework record, a deprecated record type formerly used in e-mail validation systems (use a TXT record instead).
SRV
: Service locator record, which is used by some voice over IP, instant messaging protocols, and other applications.
TXT
: Text record, up to 255 characters. Can contain arbitrary text and can also be used to define machine-readable data, such as security or abuse prevention information.
#
Add a new record
To add a new DNS record:
Go to the
Domains
tab for your team.
Select the domain you want to edit.
At the bottom of the
DNS records
section, select
Add new record
.
Choose the type of record to create from the menu and fill in the remaining options. The fields you need to fill out will depend on the type of record you select.
Select
Save
to create the record and make the changes live.
Remember, it may take up to a few hours for record changes to propagate.
Note that you can host records for other services, such as your mail provider or your backend API, with us as long as you host at least one website with us that uses the domain.
Next step
If you’re adding DNS records as part of the process of moving your DNS service to Netlify DNS, your next step is to
delegate your domain to Netlify
.
#
Edit a record
To make DNS changes, you need to first
add a new record
with the new value and then
delete the old record
. DNS allows multiple entries for the same name and type, so you can avoid downtime by making changes this way.
#
Delete a record
To delete a DNS record:
Go to the
Domains
tab for your team.
Select the domain you want to edit.
In the
DNS records
section, find the record you want to delete.
Select the record to expand the details and then select the delete option.
Review the warning message and select
Delete
to confirm.
Remember, it may take up to a few hours for record changes to propagate.
#
API endpoints
You can use the
API
to get DNS records, create DNS records, and more.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_enable-ipv6.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/enable-ipv6/
Scraped_At: 2025-06-02T19:57:04.981934

Contact
Forums
Contact support
Enable IPv6 for your site or app to use the newer IP protocol, which has a range of benefits over the older IPv4 protocol.
IPv6 is a newer protocol for how devices communicate over the internet. Among other differences, it uses a 128-bit address instead of the IPv4’s 32-bit address, supports more IP addresses, and is the process of replacing IPv4.
By default, IPv6 is not enabled on all Netlify sites and apps. If you use Netlify DNS, you can enable it explicitly in your Domains dashboard.
To enable IPv6 for your site or app:
From your Team overview, select
Domains
from the left sidebar.
Select the domain you want to enable IPv6 for and select
Enable IPv6
.
Last updated: March 19, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_netlify-name-servers.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/netlify-name-servers/
Scraped_At: 2025-06-02T19:57:05.839487

Contact
Forums
Contact support
Netlify’s name servers will vary depending on your domain.
To get a list of available name servers for your domain, you must first add a domain to your site or team.
Next you can find Netlify’s available name servers for that domain in the Netlify domains dashboard.
Go to your Netlify team dashboard and select domains.
Select the specific domain you want to set up name servers for.
From your domain dashboard, under
Name servers
, you’ll find a list of available name servers for your domain in a format simliar to
dns1.p01.nsone.net
.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_configure-domains_register-and-buy-a-domain.txt --------
Start of file
URL: https://docs.netlify.com/domains/configure-domains/register-and-buy-a-domain/
Scraped_At: 2025-06-02T19:57:06.708663

Contact
Forums
Contact support
Register and buy a new domain from Netlify and let Netlify DNS help you manage your domain for the fastest and smoothest setup.
We will automatically configure your site or app to use the domain on the best CDN (content delivery network) for your Netlify plan.
Once you register the domain name, Netlify creates a
Netlify DNS zone
for the domain, and provisions a
wildcard certificate for HTTPS
.
#
Register and buy a domain for a site
As a Team Owner or Organization Owner:
From your Site overview, in the left sidebar, select
Domain management
from the left sidebar.
Select
Register and buy a domain
and follow the prompts to register and buy your domain.
Now this domain is automatically assigned as the primary domain for your site.
#
Register and buy a domain for any site on a team
As a Team Owner or Organization Owner:
From your Team overview, in the left sidebar, select
Domains
from the left sidebar.
Select
Register and buy a domain
and follow the prompts to register and buy your domain.
Now this domain is available for any site on your team.
#
Supported domains
Netlify offers support for many different TLD domains, which you can confirm when verifying your domain.
#
Domains with special characters
To add a domain name that uses Unicode (or non-ASCII) characters such as ñ or é, use Punycode format. First, convert your domain name to Punycode using a Punycode converter, such as
Punycoder
. Then, use the converted output for the domain name as you follow the
Add or register domain
prompts.
#
Domain renewal and expiration
Domain registrations are valid for one year. To ensure continuous service, Netlify-registered domains automatically renew by default using the
payment method
on file for the team. You can turn off auto-renewal in the domain detail page of the Netlify UI.
Near the end of the registration period, Netlify will send you an email informing you of the cost for renewal, as well as whether your domain is set to renew automatically or not.
If you have
disabled auto-renewal
on a domain, and the registration expires, all DNS records for the domain will stop working. You have the option to get the domain back, subject to the following timeline:
For the first 30 days after expiration, you can request assistance with domain renewal by contacting
support@netlify.com
from an email address associated with the Netlify team that paid for the domain.
For the next 30 days, days 31-60 after expiration, you can neither renew nor purchase the domain.
When 60 days have passed after expiration, the domain becomes available for sale to the public. You can then purchase it again as a new domain.
#
Transfer registration
To learn about your options for transferring a domain registration, check out the
transfer domains docs
.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_domains-fundamentals_domains-glossary.txt --------
Start of file
URL: https://docs.netlify.com/domains/domains-fundamentals/domains-glossary/
Scraped_At: 2025-06-02T19:57:07.334843

Contact
Forums
Contact support
#
Apex domain
The
apex domain
, also known as a
root, bare, or naked domain
, is the
yourcustomdomain.com
part in the domain
www.yourcustomdomain.com
.
#
Atomic deploy permalink
An
atomic deploy permalink
is the unique URL for a specific successful deploy. Also called a
deploy permalink
or
permalink
. Unlike the other site deploys, the web content at this URL never changes. A new deploy permalink is generated for each successful deploy of your site. For example,
1234abcd12acde000111cdef--yoursitename.netlify.app
is an atomic deploy.
#
Automatic deploy subdomain
An
automatic deploy subdomain
is a subdomain that can be customized for all Deploy Previews and/or for all branch deploys. It can use your production site’s primary domain or a different custom domain with additional subdomains and requires Netlify DNS.
#
Branch deploy URL
A
branch deploy URL
is a URL for a branch deploy that uses your production site’s primary domain or a different custom domain with additional subdomains and requires Netlify DNS.
#
Branch subdomain
A
branch subdomain
is a subdomain for a branch deploy that applies your production site’s primary domain to specified branch deploys. It can apply to an individual branch deploy or to all branches besides your production branch and requires Netlify DNS.
#
Custom domain
A
custom domain
is a domain you can assign to a site.
#
Deploy Preview URL
A
Deploy Preview URL
is a URL for a Deploy Preview that uses your production site’s primary domain or a different custom domain with additional subdomains and requires Netlify DNS.
#
Domain alias
A
domain alias
is an additional custom domain assigned to a production site.
#
Domain name
A
domain name
(or domain for short) is the full name used to access a site, such as
yoursitename.netlify.app
or
www.yourcustomdomain.com
.
#
Domain registrar
A
domain registrar
(or domain registration service) is a company that lets you register a domain name.
#
DNS provider
A
DNS provider
is a company that maintains the DNS servers that translate a domain name to a destination.
#
DNS server
A
DNS server
(or Name server) is a specialized server that translates domain names into IP addresses.
#
DNS zone
A
DNS zone
is used to provide information about one or more domain names. Each zone contains a list of DNS records with mappings between domain names and IP addresses.
#
Netlify DNS
Netlify DNS
is Netlify’s managed DNS service.
#
Netlify subdomain
A
Netlify subdomain
is Netlify's term for the default domain with the form
[name-of-your-site].netlify.app
given to each site.
#
Primary domain
A
primary domain
is Netlify's term for the main custom domain assigned to a production site.
#
Production deploy URL
A
production deploy
is a deploy made to the desiginated production branch. If you haven’t assigned a custom domain for your site, then the production deploy URL will take this form:
yoursitename.netlify.app
.
#
Subdomain
A
subdomain
is a domain that is part of a larger domain; the only domain that is not also a subdomain is the apex domain. For example,
www.yourcustomdomain.com
and
app.yourcustomdomain.com
are subdomains of
yourcustomdomain.com
.
#
Top-level domain
The
top-level domain
is the last part of the domain name. For example, the
.com
part in
www.yourcustomdomain.com
.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_domains-fundamentals_understand-domains.txt --------
Start of file
URL: https://docs.netlify.com/domains/domains-fundamentals/understand-domains/
Scraped_At: 2025-06-02T19:57:08.207302

Contact
Forums
Contact support
Learn the fundamentals of working with domains on Netlify.
A domain name is the URL or web address where visitors find your site.
To access your deploys on Netlify, you can set up a custom domain or use the default Netlify subdomain.
#
Supported custom domains
Custom domains allow you to make your sites accessible at your own domain names, such as
www.yourcustomdomain.com
or
docs.example.dev
. All top-level domains are supported for your custom domain.
Netlify supports custom domains for your production site, Deploy Previews, and branch deploys.
For your production site, Netlify supports a primary site domain,
domain aliases
, and
domain-based redirects
.
For Deploy Previews, you can customize your domain after the Deploy Preview prefix
deploy-preview-#
with an
automatic deploy subdomain
.  For example:
deploy-preview-123.company.com
.
For branch deploys, you can customize your domain after your branch name with
automatic deploy subdomains or branch subdomains
.
For example:
branch-name.company.com
For more example custom domains, check out the chart below.
#
Default Netlify subdomain
Unless you’ve set up a basic password protection or authentication, a production site/app on Netlify is accessible from its Netlify subdomain, which takes the form
[name-of-your-site].netlify.app
. Note that you can change the name of your site to change this Netlify subdomain.
For example, if your site is named
brave-curie-12345
, then by default your site is available at
https://brave-curie-12345.netlify.app/
.
Learn more about other types of default Netlify subdomains for other types of deploys in the
chart
below.
#
Example domains for deploys
Your site deploys can have different domain patterns based on the type of site deploy.
#
Custom domain examples
Site deploy type
Custom domain
Use case
Production deploy
company.com
Can set a primary domain for your production site.
Deploy Preview
deploy-preview-42.early-access.company.com
Can set a custom domain for Deploy Previews with an automatic deploy subdomain.
Branch deploy
for a branch named
staging
Branch subdomain:
staging.company.com
Automatic deploy subdomain:
staging.early-access.company.com
or
staging.internal-events.com
Can set a custom domain for your branch deploys with an
automatic deploy subdomain or branch subdomains
.
#
Netlify subdomain examples
By default, your site deploys are available at a URL using the Netlify subdomain
yoursitename.netlify.app
. The Netlify subdomain URLs will always work even if you set up a custom domain for your site.
Site deploy type
Netlify subdomain
Use case
Production deploy URL
yoursitename.netlify.app
Typically a placeholder URL, ideal for internal development before assigning a custom domain for site visitors.
Deploy Preview
deploy-preview-42--yoursitename.netlify.app
Unique URL for previewing and collaborating on each pull/merge request.
Branch deploy
for a branch named
staging
staging--yoursitename.netlify.app
Note: With a branch subdomain set up, the URL can be
staging.yourcustomdomain.com
.
Long-standing URL ideal for internal testing, QA teams, and ongoing development. To set up branch deploys, check out
branch deploy controls
.
Atomic deploy
1234abcd12acde000111cdef--yoursitename.netlify.app
Unique URL for a specific successful deploy. Also called
deploy permalinks
or just permalinks. Unlike the other site deploys, the web content at this URL never changes. A new deploy permalink is generated for each successful deploy of your site.
Last updated: March 19, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_get-started-with-domains.txt --------
Start of file
URL: https://docs.netlify.com/domains/get-started-with-domains/
Scraped_At: 2025-06-02T19:57:08.820328

Contact
Forums
Contact support
Find the best setup path and next steps based on your needs for a custom domain.
To review your domain options, check out our
Understand domains
or
domains glossary
docs.
I want to set up . . .
Docs
a new custom domain
Register and buy a new custom domain with the option to manage it with Netlify DNS
Why Netlify DNS?
a custom domain for my site/app that I already own, such as
company.com
or
shop.company.com
Bring your own domain
Netlify DNS
Set up Netlifly DNS
just a standalone subdomain, such as
docs.company.com
, where
company.com
is a domain managed or hosted outside of Netlify and where
docs.company.com
is managed by Netlify DNS for your production branch
Delegate a standalone subdomain
just
https
for my domain or an SSL certificate
HTTPS SSL
An alias domain or an additional custom domain since my site/app on Netlify already has a primary domain
Add an alias domain
A domain redirect
Add domain redirect
A domain transfer
Transfer a domain
A shared custom subdomain for preview environments of my site/app, such as
early-access.company.com
instead of the default Netlify subdomain of
yoursitename.netlify.app
so I can use tools requiring shared subdomains with the production URL
Configure an automatic subdomain for deploys
#
Domain migration best practices
To keep your site/app running smoothly while you migrate your domain, check out this blog post on
Migrating a domain to Netlify
.
#
Custom help
You can also use
Ask Netlify
to ask specific questions about your domain setup needs.
Let us know in the docs feedback form comments below if you’d like to see a guide for your specific domain scenario.
Last updated: March 19, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_add-domain-redirect.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/add-domain-redirect/
Scraped_At: 2025-06-02T19:57:09.429183

Contact
Forums
Contact support
If you have multiple domains assigned to your site, you can redirect visitors between them or add other custom
redirect and rewrite rules
based on the domain entered into the browser by your visitors.
For more information, visit the docs on
domain-level redirects
.
For additional help in setting up domains redirects, check out these forums posts:
Redirect old domain to new one
Official Support guide on making redirects work
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_assign-a-domain-to-your-site-app.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/assign-a-domain-to-your-site-app/
Scraped_At: 2025-06-02T19:57:10.196592

Contact
Forums
Contact support
Use your own domain for your Netlify site for free or you can add a domain you already own, then set up Netlify DNS for it.
From your Site Overview or Site dashboard, on the left sidebar, select
Domain management
.
Next, choose
Add a domain
, then
Add a domain you already own
.
Enter your domain and follow the setup prompts.
Choose whether you will use Netlify DNS or an External DNS Provider.
If you’re using an External DNS Provider, check out their docs for help updating your DNS records and our
DNS records docs
. Find some customized help by selecting
Awaiting External DNS
next to your domain. These in-app instructions are customized based on your added domain.
If you decide to use
Netlify DNS
, select
Options > Set up Netlify DNS
and follow the setup prompts.
Last updated: March 7, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_automatic-deploy-subdomains.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/automatic-deploy-subdomains/
Scraped_At: 2025-06-02T19:57:10.983348

Contact
Forums
Contact support
With automatic deploy subdomains, you can set up automatically  branded URLs for Deploy Previews or branch deploys — unifying your site’s preview environments, auth flows, third-party services, and other site versions with a shared custom domain.
Automatic deploy subdomains are a type of custom domain that you can set for all Deploy Previews or all branch deploys.
#
Use cases
When you set up an automatic deploy subdomain for all of your Deploy Previews or branch deploys, you can:
Share branded deploy URLs that don’t include the Netlify subdomain. For example, build greater trust with your stakeholders by sharing
deploy-preview-42.company.com
instead of
deploy-preview-42--yoursitename.netlify.app
.
Use third-party services the way you do for your production site, such as auth flow services that rely on a custom domain.
Ensure deploys are “trusted” and in the “allowed domain list” for any third-party scripts or services that require this.
Meet internal security requirements while leveraging Netlify’s Deploy Previews and branch deploys to preview and collaborate on changes before they go live.
Once you configure an automatic deploy subdomain, Netlify uses this custom domain for your Deploy Previews and/or branch deploys by default within the Netlify UI, the API, CLI, and deploy notifications.
#
Domain requirements
The custom domain you set as your automatic deploy subdomain must be managed by
Netlify DNS
and available to your team.
By default, domains managed by Netlify DNS can be applied to your Deploy Previews or branch deploys.
For example, if you already delegated
company.com
to Netlify DNS, then subdomains of
company.com
, such as
early-access.company.com
, are also delegated to Netlify DNS by default. That means you can use
early-access.company.com
as your automatic deploy subdomain.
If you want to use a custom domain that Netlify DNS does not already manage, add the custom domain to your Netlify team and configure it to be managed by Netlify DNS. Learn more in these
domain setup steps
.
Want to use a subdomain without bringing the apex domain to Netlify DNS?
You can bring a subdomain to Netlify DNS without the apex domain. For example, you can delegate
docs.company.com
to Netlify DNS without also delegating
company.com
. Learn more about
stand-alone subdomain support
.
#
Example deploy URLs
Site deploys
Netlify subdomain
Automatic deploy subdomain
Deploy Preview
deploy-preview-42--yoursitename.netlify.app
deploy-preview-42.company-internal-testing.com
Branch deploy
, e.g.
staging
branch
staging--yoursitename.netlify.app
staging.company-internal-testing.com
Atomic deploy permalink
Uses the Netlify subdomain and a deploy ID, such as
1234abcd12acde000111cdef--yoursitename.netlify.app
.
N/A
When you set an automatic deploy subdomain for all Deploy Previews or all branch deploys, your deploys are still accessible at the Netlify subdomain, such as
deploy-preview-42--yoursitename.netlify.app
or
staging--yoursitename.netlify.app
.
Using High-Performance Edge?
If your site is on the
High-Performance Edge
, then automatic deploy subdomains are served from the High-Performance Edge. However, Netlify subdomains (
*.netlify.app
) are always served from the standard network.
Your
deploy permalinks
, which offer unique URLs for successful deploys of your site, will continue to use the Netlify subdomain. Unlike other deploy URLs, deploy permalinks do not update with new Git commits. Instead, Netlify generates new deploy permalinks for each successful deploy of your site.
Not sure if you want to use Deploy Previews or branch deploys?
Deploy Previews are scoped to a pull/merge request while branch deploys are scoped to a branch. Branch deploys can offer a longer-standing URL than Deploy Previews since they are based on the branch name and not the pull/merge request. Learn more about the difference between these deploys in these
docs
.
#
Automatic deploy subdomains for Deploy Previews
Deploy Previews are automatically enabled for all sites using continuous integration with Netlify. If your site doesn’t have Netlify continuous integration set up, check out
these docs
.
#
Set an automatic deploy subdomain for Deploy Previews
To set up an automatic deploy subdomain for your site’s Deploy Previews:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Deploy Previews
, select
Add custom domain
.
Under
Domain
, you’ll find domains managed by Netlify DNS. Select your chosen custom domain. Optionally, enter an additional subdomain, such as
early-access
or
qa
.
Want to use a different domain?
If you can’t find the domain you want to add in the drop-down menu, check out these docs for
adding a new custom domain
.
Review the preview of the deploy URL for your Deploy Previews. To confirm,  select
Save
.
Once saved, Netlify updates the domain for all open Deploy Previews. If you applied a custom domain that is not already live as your primary site domain (or does not already have a security certificate), then your new deploy URL may take up to 24 hours to resolve and work with HTTPS.
#
Automatic deploy subdomains for branch deploys
Branch deploys are often used for maintaining a separate version of your site for QA, internal testing, or even to manage different versions of site content for different audiences or product versions.
If you are already using
branch subdomains
, check out
our branch subdomain comparison docs
to understand the key differences between these subdomains and how they can work together.
If you set up an automatic deploy subdomain for branch deploys on your site, then each branch deploy will generate the same automatic deploy subdomain and include your branch deploy’s unique branch name.
#
Prerequisites
To set up an automatic deploy subdomain for your site’s branch deploys, you must first enable branch deploys for your site.
To enable branch deploys for your site, go to
Project configuration
>
Build & deploy
>
Branches and deploy contexts
.
Select
Configure
.
Next to
Branch deploys
, set up branch deploys for a specific branch or for all non-production branches. To confirm, select
Save
.
Once branch deploys are enabled, create a new branch and push a commit to this branch in your connected site repo. Netlify will automatically generate a branch deploy, which you can preview in your site’s deploy list.
Created a deploy with the CLI?
If you created a deploy using the
Netlify CLI’s
--alias
flag
, then be aware that these deploys are not branch deploys and do not support branch subdomains or automatic deploy subdomains. We recommend you avoid using
--alias
with any of your branch names.
#
Set an automatic deploy subdomain for branch deploys
To set up an automatic deploy subdomain for your site’s branch deploys:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Branch deploys
, select
Add custom domain
.
Under
Domain
, you’ll find domains managed by Netlify DNS. Select your chosen custom domain. Optionally, enter an additional subdomain, such as
early-access
or
qa
.
Want to use a different domain?
If you can’t find the domain you want to add in the drop-down menu, check out these docs for
adding a new custom domain
.
Review the preview of the deploy URL for your branch deploys. To confirm,  select
Save
.
Once saved, Netlify updates the domain for all active branch deploys. If you applied a custom domain that is not already live as your primary site domain (or does not already have a security certificate), then your new deploy URL may take up to 24 hours to resolve and work with HTTPS.
#
Choose a unique URL for your branch deploys
It is possible to configure automatic subdomains for branch deploys so that a branch subdomain conflicts with another site’s production domain. Since Deploy Previews are appended with the pull/merge request number, their automatic subdomains are unlikely to conflict with other domains.
For example:
Site A has a primary site domain of
staging.company.com
for the production site.
Site B has an automated domain of
staging.company.com
for its
staging
branch.
When there is a conflict, domains listed in your
Production domains
settings will take precedence over other internal domains. So in this example,
staging.company.com
will resolve to the content of site A.
To prevent accidental domain duplication, you might choose to add another subdomain level to your branch subdomains that is not used in production, such as
internal
in
staging.internal.company.com
.
If you get a domain conflict, you can rename the branch. For example, you can rename the branch from
staging
to
qa
. Then, the next time you deploy this branch, it would use the
qa.company.com
domain.
#
Limitations for sites with existing branch subdomains
Once you add an automatic deploy subdomain for branch deploys, you cannot edit or change existing manual
branch subdomains
. You also cannot manually add new branch subdomains, but existing branch subdomains will still work.
If you configured branch subdomains before enabling automatic deploy subdomains, both the branch subdomains and automatic deploy subdomains will resolve and be available. If both are set up, the Netlify UI, CLI, API, and deploy notifications will link to the automatic deploy subdomain by default.
To make changes to your branch subdomain, you must
remove the automatic deploy subdomain
first.
If you want to compare using branch subdomains with automatic deploy subdomains, check out our
comparison docs for applying a custom domain to a branch deploy
.
#
Use a new custom domain for your automatic deploy subdomain
By default, you can choose primary site domains that are also managed by
Netlify DNS
as your automatic deploy subdomain. You can also add additional subdomains to these domains, such as
early-access
or
qa
.
If you want to use a custom domain that is not listed in the Netlify UI, you must first delegate this domain to Netlify DNS.
Want to use a subdomain without bringing the apex domain to Netlify DNS?
You can bring a subdomain to Netlify DNS without the apex domain. For example, you can delegate
docs.company.com
to Netlify DNS without also delegating
company.com
. Learn more about
stand-alone subdomain support
.
To delegate a new domain to Netlify DNS:
In the Netlify UI, navigate to your team’s
Domains
page.
Select
Add or register a domain
.
Enter your domain, and follow the UI prompts to delegate your domain to Netlify DNS. The UI may prompt you to add this domain to Netlify DNS.
DNS updates can take up to 24 hours to take effect. On occasion, DNS record changes can take longer than this to propagate. Learn more in our
Support Guide on DNS propagation
.
Once you have delegated your domain to Netlify DNS, your new domain should appear as a new drop-down menu option when you add your automatic deploy subdomain.
#
Use the Netlify API to set automatic deploy subdomains
You can set automatic deploy subdomains when you create a site using the Netlify API. In your
createSite
request, use the following query parameters to pass the values to use for the subdomains:
deploy_preview_custom_domain
branch_deploy_custom_domain
Note that when you create or update a site with an automatic deploy subdomain, the build environment variable
DEPLOY_PRIME_URL
will update for all relevant deploys. Learn more about
DEPLOY_PRIME_URL
.
#
Custom certificate requirements
If you use a
custom certificate
for your site’s domains, that certificate must explicitly include any new subdomains used for automatic deploy subdomains. The standard wildcard syntax, such as
*.company.com
, does not cover this new subdomain.
For example, your custom certificate will not work as expected in this scenario:
you have
early-access.company.com
as your automatic deploy subdomain, where
early-access
is the optional new subdomain you
added in the Netlify UI
you have a custom certificate with
*.company.com
as your wildcard domain but not
*.early-access.company.com
In this scenario, you must update your certificate to include the domains
*.company.com, *.early-access.company.com
so that
early-access.company.com
will work as expected.
#
Remove an automatic deploy subdomain
To remove an automatic deploy subdomain from your Deploy Previews or branch deploys:
Go to
Domain management
>
Automatic deploy subdomains
.
Select
Edit custom domains
.
Next to
Branch deploys
or
Deploy Previews
, clear the
Add custom domain
checkbox.
To confirm,  select
Save
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_manage-domains-for-a-site-app.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-a-site-app/
Scraped_At: 2025-06-02T19:57:11.902365

Contact
Forums
Contact support
Manage domains for a site or app from the Netlify UI or the Netlify API.
#
Manage production domains from the Netlify UI
As a Developer, you can review domains for a team and add or change domains for a site.
As an Owner, you can transfer domains between teams you own, or delete DNS records.
#
Manage domains for a site
You can find the domains for your production site at
Domain management
>
Production domains
. You have several options for managing multiple domains for your production site.
To manage domains for an individual site or app:
Go to your site or app dashboard.
Select
Domain management
from the left sidebar.
Select the domain you want to manage.
#
Review domains for a team
To find a list of domains available to your team:
Go to your Team Dashboard and select
Domains
from the left sidebar.
You’ll find a list of your domains available to your team’s sites. Note that some of these domains may not be
assigned to a site yet
.
#
Review a domain’s DNS records
If applicable, you can check out a domain’s DNS records from your domain dashboard.
Go to your Team Dashboard and select
Domains
from the left sidebar.
Next, select your chosen domain.
#
Review a domain’s Netlify name servers
Check out our docs at
Netlify name servers
.
#
Manage domains from the API
Check out the
Netlify API reference
for DNS endpoints for more information on managing domains from the API.
You can find the domains associated with your site in the
Domain management
section of your site configuration.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_manage-domains-for-branch-deploys.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-branch-deploys/
Scraped_At: 2025-06-02T19:57:15.157665

Contact
Forums
Contact support
By default, branch deploys use the Netlify subdomain
netlify.app
with your branch name but you can customize your branch deploy URL with an automatic deploy subdomain.
#
Understand your domain options
#
Default URL for branch deploys
By default branch deploys use the Netlify subdomain
netlify.app
with the branch name, such as
https://staging.netlify.app
where
staging
is your branch name.
#
URL limitation
Be aware that the branch name combined with the site name should not exceed 63 characters, as described in the
RFC 1035
or the auto-generated branch deploy URL will not work. You will need to create a new branch deploy with either a shorter site name or branch name so that the total characters and symbols do not exceed 63.
For example, if your site domain is
my-personal-site
and the branch name is
my-very-long-and-important-for-release-feature-name
, it will produce a URL which looks like:
https://my-very-long-and-important-for-release-feature-name--my-personal-site.netlify.app
.
This URL won't work, as the first part of the domain
my-very-long-and-important-for-release-feature-name--my-personal-site
is longer than 63 symbols.
#
Custom branch subdomains for branch deploys
This feature is available in our UI with
Netlify DNS
.
Netlify can generate a branch subdomain for specified branch deploys using your site’s primary custom domain designated for your production site.
The resulting branch subdomains use the fixed syntax
branchname.yourcustomdomain.com
and can’t use a different pattern. For example, if your custom domain is
example.com
and your branch is
staging
, you can check the latest deploy of that branch at
staging.example.com
.
Before you can enable branch subdomains, you must
enable branch deploys
for your branch and successfully deploy your branch.
To add a new branch subdomain, go to
Domain management
>
Domains
>
Branch subdomains
, and select
New subdomain
.
A branch subdomain can be deleted by using the
x
button in the corresponding subdomain row.
Visit our Forums for a verified Support Guide on
setting up branch subdomains without Netlify DNS
.
#
Compare subdomain options for branch deploys
For an overview of the main differences between these subdomains, consider these key differences.
Automatic deploy subdomains
Branch subdomains
Custom domain options
Can use your production site’s primary domain or any other custom domain or subdomain managed by Netlify DNS and available to your team.
Can only use your production site’s primary domain, which must be managed by Netlify DNS.
Additional subdomain support
X
Requires Netlify DNS
X
X
Pricing plan
Core Pro plan and above
All plans
Branch deploy scope
Applies to all branch deploys.
Applies to user-specified branch deploys:
individual branches or all branches except the designated production branch.
Setup interactions
Once set up, becomes the primary deploy URL for branch deploys. Cannot change existing branch subdomain settings without
removing your automatic deploy subdomain
.
Once automatic deploy subdomains are set up, cannot change existing branch subdomain settings but branch subdomain URLs still resolve for pre-existing branches.
#
Set up both a branch subdomain and an automatic deploy subdomain
If you want to use both branch subdomains and an automatic deploy subdomain for branch deploys, ensure that you set up any branch subdomains before your automatic deploy subdomain.
We recommend setting up only stable or internal branch subdomains since you would need to remove your automatic deploy subdomain to make changes to your branch subdomain settings.
Also, note that the Netlify UI, CLI, and API will use the automatic deploy subdomain for branch deploys configured with a branch subdomain. The branch deploy URL featuring your branch subdomain, such as
staging.company.com
should still resolve and work for site visitors though.
Learn more about
limitations to using both types of subdomains for branch deploys
.
#
Set up an automatic deploy subdomain
To set up an automatic deploy subdomain for your branch deploys, check out
Automatic Deploy Subdomains
.
#
Set up a branch subdomain
To set up a branch subdomain for your branch deploys, check out our
Branch deploy docs
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_manage-domains-for-deploy-previews.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-deploy-previews/
Scraped_At: 2025-06-02T19:57:16.041311

Contact
Forums
Contact support
By default, Deploy Previews use the Netlify subdomain
netlify.app
with your site name but you can customize your Deploy Preview URL with an automatic deploy subdomain.
#
Understand your domain options
You have a few options for the domain of your Deploy Preview if you use Netlify DNS.
#
Default URL for Deploy Previews
For example, Deploy Previews use a default Netlify subdomain, such as
deploy-preview-#--yoursitename.netlify.app
, where
#
represents your pull or merge request.
#
Custom domain for Deploy Previews
You can customize your Deploy Preview URL by setting up an automatic deploy subdomain, which is available with
Netlify DNS
.
Netlify can generate a custom domain for all of your Deploy Previews and/or branch deploys when you set up an automatic deploy subdomain.
Automatic deploy subdomains include a custom domain or subdomain that must be managed by Netlify DNS and an optional additional subdomain.
#
Why customize?
Standardizing a custom subdomain for your Deploy Previews can unlock new ways of integrating deploys with your branding, review workflows, or security needs.
We recommend automatic deploy subdomains for
Core Pro plans and above
with these scenarios:
you want a custom domain for a Deploy Preview
you want maximum flexibility with your custom domain
to use certain tools that require a shared subdomain with your product site domain
#
Set up custom domain for Deploy Previews
To set up a custom domain for your Deploy Previews, check out
Automatic Deploy Subdomains
.
Last updated: March 7, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_manage-multiple-domains.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/manage-multiple-domains/
Scraped_At: 2025-06-02T19:57:16.907147

Contact
Forums
Contact support
Your production site or app can support more than one domain through domain aliases, redirects, subdomains, and more.
Find the domains associated with your site or app in the
Domain management
section of your site configuration.
#
Manage domains for your production site
You can find the domains for your production site at
Domain management
>
Production domains
.
#
Manage domains for your team’s sites
From your Team Overview’s domains list, you can:
review your domain’s DNS records (if applicable)
review
Netlify name servers
for your domain
transfer a domain between two team accounts you own
delete DNS zones
To find your Team Overview’s domains list:
Go to the Team Overview or dashboard and select
Domains
from the left sidebar.
Next, select a domain from the domains list for your team.
You’ll be redirected to your domain’s dashboard, where you can find your domain’s DNS records (if applicable) and
Netlify name servers
.
#
Apex domains and
www
subdomains
When you assign an apex domain (eg.
petsofnetlify.com
)
or
a
www
subdomain (eg.
www.petsofnetlify.com
) as the primary domain for your site, two entries are added to the
Production domains
panel:
one entry for the apex domain, and
one entry for the
www
subdomain.
The primary domain is the custom domain you entered. The other entry is for the alternative domain that gets redirected automatically to the primary domain.
If you set the
www
subdomain as your primary domain, Netlify will automatically redirect the apex domain to the
www
subdomain.
If you set the apex domain as your primary domain, Netlify will automatically redirect the
www
subdomain to the apex domain.
If you’re using external DNS,
we strongly recommend setting the
www
subdomain (or another subdomain) as your primary domain
. If you want to set an apex domain as your primary domain, we recommend using Netlify DNS. Our blog post
How to Set Up Netlify DNS
has more details on these recommendations.
Redirects for non-
www
subdomains
Though Netlify automatically redirects between the apex domain and
www
subdomain, we don’t do this for any other subdomains. You can configure this behavior yourself with
domain-level redirects
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_overview.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/overview/
Scraped_At: 2025-06-02T19:57:20.120418

Contact
Forums
Contact support
Manage domains that you’ve already registered or bought and customize how your domains are assigned to your site or app deploys.
You have many options for managing domains in the Netlify UI. Note that using
Netlify DNS
gives you even more options.
Learn the basics of
using the Netlify UI to manage your domains
whether or not you’re using Netlify DNS:
Assign a domain to your site or app
Add domain redirect
Manage multiple domains
Transfer a domain
Customize automated domains for deploy previews and branch deploys
Automatic deploy subdomains
Manage domains for branch deploys
Manage domains for Deploy Previews
Last updated: March 7, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_manage-domains_transfer-a-domain.txt --------
Start of file
URL: https://docs.netlify.com/domains/manage-domains/transfer-a-domain/
Scraped_At: 2025-06-02T19:57:21.010944

Contact
Forums
Contact support
Netlify offers these options for transferring a domain.
#
Transfer domains between teams
To transfer domains between teams, you must be a Team or Organization
Owner
.
If you already have a domain in your team’s
Domains
page, you can transfer the domain and all of its settings to any other team where you are an Owner or Developer. To do this, select the domain you wish to transfer, then go to
Collaboration > Transfer ownership
, near the bottom of the page.
#
Transfer domains between registrars
Netlify cannot accept inbound domain transfer requests from other registrars. However, if you have a domain registered elsewhere, you can still take advantage of Netlify DNS by
delegating your domain to Netlify
.
You can also transfer domain registrations and DNS zones between your teams on Netlify. Visit the
domain transfer
instructions for details.
If you would like to transfer a Netlify-registered domain to another registrar, please
contact support
for assistance. Note that
ICANN regulations
do not permit transfers within 60 days of registration.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_secure-domains-with-https_https-ssl.txt --------
Start of file
URL: https://docs.netlify.com/domains/secure-domains-with-https/https-ssl/
Scraped_At: 2025-06-02T19:57:21.814972

Contact
Forums
Contact support
Netlify offers free HTTPS on all sites, including automatic certificate creation and renewal. Our certificates use the modern TLS protocol, which has replaced the now deprecated SSL standard.
HTTPS brings a lot of advantages:
Content integrity.
Without HTTPS, free Wi-Fi services can inject ads into your pages.
Security.
If your site has a login or accepts form submissions, HTTPS is essential for your users’ security and privacy.
SEO.
Google search results prioritize sites with HTTPS enabled.
Referral analytics.
HTTPS-enabled sites will not send referral data to sites without HTTPS enabled.
HTTP/2.
Boost your sites’ performance —
HTTP/2
requires HTTPS.
#
Certificate service types
Netlify offers two different ways of providing a certificate for HTTPS.
Netlify-managed certificates
are offered to all Netlify sites for free. Find details for this in the section on
Netlify-managed certificates
.
Custom certificates
are a way for you to provide a certificate that matches your specifications — things like a wildcard certificate or an Extended Validation (EV) certificate. If you’d like to provide your own custom certificate, refer to
Custom certificates
below for more details.
For all certificate service types, Netlify enables HTTPS for only Netlify-hosted content. If you use Netlify to host content on an apex domain and other hosts for content on subdomains, Netlify cannot enable HTTPS for the subdomains with externally-hosted content.
#
Netlify-managed certificates
When you create a new site on Netlify, it’s instantly secured at the Netlify-generated URL (for example,
https://brave-curie-12345.netlify.app
). If you add a
custom domain
, we will automatically provision a certificate with
Let’s Encrypt
, enabling HTTPS on your domain. Certificates are generated and renewed automatically as needed.
To ensure that only Netlify can create Let’s Encrypt certificates for your custom domain, you can add a
Certificate Authority Authorization (CAA) record
to your DNS provider that specifies Netlify’s
accounturi
, which is
https://acme-v02.api.letsencrypt.org/acme/acct/54403714
.
For example, this is a CAA record for our domain
petsofnetlify.com
:
petsofnetlify.com         300	IN	CAA	0 issue "letsencrypt.org;accounturi=https://acme-v02.api.letsencrypt.org/acme/acct/54403714"
Use Netlify DNS for automatic wildcards
If your domain uses
Netlify DNS
, we’ll automatically provision a wildcard certificate, which ensures instant HTTPS for all of the Netlify sites using subdomains of that domain.
In rare circumstances, there can be problems when provisioning a certificate for some domains. You can check the status of your site’s certificates in
Domain management
>
HTTPS
.
If you’re having trouble with the automatic provisioning, visit the
troubleshooting page
for an error message guide and other tips. You can also visit our Forums for a verified Support Guide on
SSL / TLS certificate provisioning
.
#
Domain aliases
Your certificate will include all your
domain aliases
when it’s issued, but note that DNS also needs to be configured
in advance
for all aliases for us to include them on your certificate. Visit the
troubleshooting page
for more information on confirming the new configuration.
Avoid rate limiting for subdomains
If you have more than 5 aliases that are subdomains of the same domain, you might run into rate limits with our certificate provider. In that case we recommend you provide your own wildcard certificate using Netlify DNS or
contact support
for our assistance for getting them set up with our certificate provider. Please do this
before adding any aliases
!
#
Custom certificates
If you already have a certificate for your domain and prefer that to Netlify’s domain-validated certificate, you can install your own.
To install a certificate, you’ll need:
the certificate itself, in X.509 PEM format (usually a .crt file)
the unencrypted private key you used to request the certificate
a chain of intermediary certificates from your Certificate Authority (CA)
In
Domain management
>
HTTPS
, select
Set Custom Certificate
, then enter the information above. For tips on specific formatting and the contents of the certificate, visit our Forums for a verified support guide on
custom SSL certificates
.
Renewal is not automatic
When the time comes to renew your custom certificate, Netlify cannot do this automatically. You will need to renew it at your Certificate Authority, then follow the steps above to install it on your Netlify site. For automatic renewal, you can switch to a
Netlify-managed certificate
.
Netlify validates that the certificate matches the custom domain for your site and that the DNS record for the domain is pointed at Netlify, then installs your certificate. If your certificate covers several of your sites (in other words, if it’s a wildcard certificate or uses Subject Alternative Names), you can install it on one site, and it will apply to all other sites covered by the certificate.
Using automatic deploy subdomains?
If you use a custom certificate for your site’s domains, that certificate must explicitly include any new subdomains used for automatic deploy subdomains. The standard wildcard syntax, such as
*.company.com
, does not cover this new subdomain. Learn more about
custom certificates and automatic deploy subdomains
.
#
HSTS preload
Most major browsers use a list of predefined domains to automatically connect to websites using HTTPS. This list is called the HTTP Strict Transport Security (HSTS) preload list. Your site can be included in this list if you follow the requirements in
hstspreload.org
:
Your custom domain must be accessible in the www subdomain. For example:
www.petsofnetlify.com
.
You must include this header in your
_headers
file
or
Netlify configuration file
:
Loading error: Refresh the page to access this code sample
/* 
  Strict-Transport-Security: max-age=63072000; includeSubDomains; preload
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
Strict-Transport-Security
=
'''
    max-age=63072000;
    includeSubDomains;
    preload'''
When this is set, the browser assumes that your site, along with all subdomains, can be accessed using HTTPS, and it will force those connections.
This action is not easily reversible
Please make sure to only use the directive
preload
once you’re confident that the domain
and all subdomains
are ready to be served using
only
HTTPS, since this setting is hard to remove once it’s in place,
as described at hstspreload.org
.
#
HTTP/2
When HTTPS is enabled for your site, Netlify supports HTTP/2, a newer internet protocol engineered for faster web performance. This brings support for core HTTP/2 features like request multiplexing and compressed headers, but does not include server push capability.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_set-up-netlify-dns.txt --------
Start of file
URL: https://docs.netlify.com/domains/set-up-netlify-dns/
Scraped_At: 2025-06-02T19:57:22.424901

Contact
Forums
Contact support
Set up Netlify DNS for your new or existing domain.
Netlify DNS offers you advanced subdomain automation and deployment features, such as:
standalone subdomains, such as
docs.company.com
without delegating
company.com
branch deploys, such as deploying the
staging
branch of your site/app
a wildcard SSL certification for all your deploys
Netlify DNS also ensures that your site uses our CDN for the apex domain as well as subdomains like www. Learn more in
Why Netlify DNS
.
#
Enable Netlify DNS
There are several pathways to enabling Netlify DNS.
#
For a domain already added to your site
If you already assigned a production domain to your site, to set up Netlify DNS:
Go to your site’s dashboard, then select
domain management
from the left sidebar.
Next to your domain, select
Options
, then
Set up Netlify DNS
.
Follow the prompts to finish setting up Netlify DNS.
#
For a domain you already registered
If your domain is registered with another provider, you can still take advantage of Netlify’s managed DNS service by delegating your domain to Netlify.
#
Delegate to Netlify
Transfer your DNS records first!
If you have any existing records on your current DNS provider, such as MX records for email service, make sure to copy them to Netlify DNS first. This will ensure continuous service as you change providers.
Visit the
DNS records
page or the verified Support Guide in our Forums on
migrating a domain to Netlify-managed DNS
for details.
Assuming you have copied existing DNS records from your current provider, the final step to making your DNS records live is to update your domain registrar with the name servers that will be authoritative for your domain.
The process for changing your domain’s name servers varies from registrar to registrar. Check your domain registrar’s documentation for updating name servers. For your convenience, we’ve gathered links to instructions for popular registrars
GoDaddy
,
Google Domains
,
AWS
,
Name.com
, and
Hover
.
To delegate your domain to Netlify:
In the Netlify UI, go to your team’s
Domains
page.
Select your domain.
Make note of the four name servers listed in the
Name servers
panel.
Log in to the account you have with your domain registrar and find their instructions for updating name servers.
Replace the name servers with the name servers for your Netlify DNS zone. If your registrar requires name server IP addresses, visit our Forums for a verified Support Guide on
finding the IP addresses for Netlify’s name servers
.
It may take up to a day for the changes to propagate to the public internet.
Next steps
Once your name server settings have propagated across the domain name system, you’re ready to start using your domain and its subdomains.
To use the domain or a subdomain to access a Netlify site, visit the instructions for
assigning a domain to a site
.
If you want to point your domain or a subdomain to another service, like an email provider, visit the
DNS records
doc for details.
If it’s been more than 24 hours, and your domain doesn’t seem to have propagated yet, visit the
troubleshooting
page for tips and resources.
#
For a new domain you need to buy and register
Check out our instructions to
register and buy a domain
from Netlify.
Last updated: April 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_troubleshooting-tips.txt --------
Start of file
URL: https://docs.netlify.com/domains/troubleshooting-tips/
Scraped_At: 2025-06-02T19:57:23.320512

Contact
Forums
Contact support
If you’re having trouble accessing your site at your custom domain or branch subdomain, there is likely a problem with your DNS or HTTPS setup. This page includes tips and information to help get things working properly.
#
DNS configuration
The
dig
command line tool is a great tool for quickly diagnosing and understanding DNS responses. It is built into Linux and Mac, but can also be installed on Windows. Alternatively, you can use an online tool to
run
dig
in the browser
.
NS1, the DNS provider backing Netlify DNS, has a great series of articles on
using DIG
to test and troubleshoot your DNS configuration.
#
Inactive Netlify DNS zone
A common DNS configuration issue is an inactive Netlify DNS zone. This prevents our service from creating or updating the automatic Let’s Encrypt SSL certificates for your custom domain. This can cause problems for branch subdomains. For more information, visit our Forums for a verified Support Guide on
how to detect and fix inactive Netlify DNS zones
.
#
Custom certificate not working for automatic deploy subdomain
If a custom certificate is not working for your automatic deploy subdomain, ensure your certificate includes any new subdomains used for automatic deploy subdomains.
For example, for the automatic deploy subdomain
early-access.company.com
, your custom certificate should include the domains
*.company.com, *.early-access.company.com
and not just
*.company.com
.
Learn more about
custom certificates and automatic deploys subdomains
.
#
Certificates and HTTPS
There are many reasons why adding a Netlify certificate or uploading a custom certificate might not work. The common causes are listed below, but if they don’t seem to apply to you or you have additional questions, our
Support team
will be happy to help out!
Most importantly, you’ll need to
configure the DNS for the custom domain
before Netlify can issue a certificate for you. Netlify must validate the domain in order to provision the certificate, and this step cannot be completed until the DNS records for your custom domain are pointing to our servers.
All previous DNS settings must have their cache timeouts expired.
The
TTL setting
on a DNS record determines how long the record may be cached. This cache must expire before your new DNS settings can be validated for certificate provisioning.
If your site is configured to go through another service (for example, using
Cloudflare “accelerate and protect”
, or similar),
you need to disable that routing before we can provision the certificate
. Netlify must handle TLS termination to be able to provision a certificate.
It is possible that the name servers we use have some old cached values for your domain name. You can attempt to
accelerate cache expiration
for your domains using the
Flush Cache tool
provided by Google Public DNS.
It is possible that we will get a certificate for one name (for example,
petsofnetlify.com
) and not for another (for example,
www.petsofnetlify.com
or some domain alias). In this case selecting
Renew certificate
should resolve the issue. If it doesn’t, please post in the
Netlify Support Forums
so our support engineers can repair the certificate.
#
HTTPS error messages
You can check the status of your certificate in
Domain management
>
HTTPS
. If there is a problem with the certificate, you may find one of the error messages below. (We’re using
petsofnetlify.com
as an example.)
#
“petsofnetlify.com doesn’t appear to be served by Netlify”
In order to make sure that the site is served by Netlify, check the HTTP response headers.
Examine the HTTP response headers in your browser’s
dev tools
, using an
online checker
, or with the following terminal command:
curl -s -v http://your-newly-configured-hostname.com 2>&1 | grep -i server
Check for a line that says
server: Netlify
.
Repeat this for
each
domain connected to your site. If your custom domain is the apex domain or
www
subdomain (for example,
petsofnetlify.com
or
www.petsofnetlify.com
), we automatically serve your site and provision a certificate for both domains, so be sure they both have records pointing to Netlify.
The next steps depend on what you find in the HTTP response headers.
If you do find
server: Netlify
in all response headers, but still receive this error, it may be caused by incorrect A records. For information on setting a proper A record with Netlify, refer to our documentation on
external DNS configuration
.
If you don’t find
server: Netlify
in all response headers, and you’ve eliminated the
common problem sources listed above
, please
contact support
.
#
“petsofnetlify.com is not resolvable with a resolver that validates DNSSEC”
Netlify DNS doesn’t support DNSSEC. To use Netlify DNS, disable DNSSEC with your domain registrar or previous DNS host. You can use tools like
DNSViz
to figure out where DNSSEC is currently enabled. To keep DNSSEC enabled, you can stop using Netlify DNS and use
external DNS
instead.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- domains_why-netlify-dns.txt --------
Start of file
URL: https://docs.netlify.com/domains/why-netlify-dns/
Scraped_At: 2025-06-02T19:57:24.799148

Contact
Forums
Contact support
Netlify DNS offers advanced subdomain automation and deployment features and ensures that your site uses our CDN for the apex domain as well as subdomains like www.
#
Netlify DNS domain support
You can delegate many different types of domains to Netlify DNS, including
apex domains
or
subdomains
, which include stand-alone subdomains.
For example, you can delegate a subdomain to Netlify DNS without the need to bring your apex domain to Netlify DNS. So you can delegate just
docs.company.com
to Netlify without bringing over
company.com
too. Learn more about
stand-alone subdomain support
.
#
Netlify DNS key benefits
Besides the convenience of managing your domains along with your site and app hosting, Netlify DNS offers the following benefits:
Wildcard SSL certificate:
If your repo has multiple branches all serving different content, you can have a subdomain for every single branch in your repo, and a wildcard SSL certificate will cover them all. This will happen automatically, with one click.
Branch deploys:
Netlify DNS allows you to set up branch deploys for each branch in your repo, which can serve as an ongoing staging environment for each branch or alternative version of your site.
Standalone subdomains:
Netlify DNS allows you to have standalone subdomains for each branch in your repo so you can delegate
docs.company.com
to Netlify DNS and keep
company.com
delegated to another DNS provider.
Custom subdomains for preview URLs (also called Automatic deploy subdomains):
Netlify DNS allows you to customize subdomains for all Deploy Previews and/or for all branch deploys so you can unify your site's URLs across all branches and share
deploy-preview-42.company.com
instead of
deploy-preview-42--yoursitename.netlify.app
. This ensures deploys can be "trusted" and in the "allowed domain list" for any third-party scripts or services that require this. This also allows you to use third-party services the way you do for your production site, such as auth flow services that rely on a custom domain.
#
External DNS key benefits
Netlify does not allow inbound DNS zone transfers. If you have a lot of existing DNS records, it's simplest and safest to use an external DNS provider.
Last updated: February 28, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_api.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/api/
Scraped_At: 2025-06-02T19:57:25.981068

Contact
Forums
Contact support
This page provides an overview of key concepts as well as a full reference.
#
Overview
Use TypeScript or JavaScript to create an edge function file that exports a default function responsible for processing a request.
When the function is invoked, it receives two arguments:
a
standard
Request
object
representing the incoming HTTP request
a
Netlify-specific
Context
object
The expected return value is one of the following:
a
standard
Response
object
representing the HTTP response to be delivered to the client
a
standard
URL
object
if you want to rewrite the incoming request to another same-site URL with a 200 status code
undefined
if you choose to bypass the current function
#
Edge function types
For TypeScript, you can import the types for the
Context
and
Config
objects from
@netlify/edge-functions
. The types for the
Request
and
Response
objects are in the global scope.
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/"
,
}
;
#
Request handling
Edge functions can handle requests in the following ways:
return a response
directly as an endpoint
redirect
to any URL
rewrite
to a same-site URL
modify a response
as middleware
Looking for a list of available request headers?
Netlify doesn’t add specific headers to edge function requests. To find information about the client request, use the
context
object
instead.
#
Return a response
Similar to serverless functions and other endpoints, an edge function can just return a
standard
Response
object
. Once the function returns the response, the request chain ends and any redirects declared for that path do not occur.
For example, this edge function
returns the string
Hello, World!
as text/html:
export
default
async
(
)
=>
{
return
new
Response
(
"Hello, World!"
,
{
headers
:
{
"content-type"
:
"text/html"
}
}
)
;
}
;
#
Return a redirect
You can use an edge function to return
an HTTP redirect
to any URL of your choice.
To do this, use the
standard
Response.redirect
function
, as shown in the example below.
export
default
async
(
req
:
Request
,
{
cookies
,
geo
}
:
Context
)
=>
{
if
(
geo
.
city
===
"Paris"
&&
cookies
.
get
(
"promo-code"
)
===
"15-for-followers"
)
{
const
url
=
new
URL
(
"/subscriber-sale"
,
req
.
url
)
;
return
Response
.
redirect
(
url
)
;
}
}
;
#
Return a rewrite
Similar to our
static routing engine
, an edge function can also return a rewrite, which is a redirect with a 200 status code. This means that the URL in the visitor’s address bar remains the same, while Netlify’s servers fetch the new location behind the scenes.
To do this, return a
standard
URL
object
with the path you want to rewrite to.
export
default
async
(
request
:
Request
,
{
cookies
,
geo
}
:
Context
)
=>
{
if
(
geo
.
city
===
"Paris"
&&
cookies
.
get
(
"promo-code"
)
===
"15-for-followers"
)
{
return
new
URL
(
"/subscriber-sale"
,
request
.
url
)
;
}
}
;
Same-site URLs only
Edge functions can rewrite to only same-site URLs. To fetch content hosted on another Netlify site or an external site, use the
fetch
Web API
.
#
Modify a response
An edge function can act as middleware that modifies and returns the response of subsequent functions or requests. This kind of edge function calls
context.next()
to continue the request chain and waits for a response to return before finishing execution.
Any edge functions that return
undefined
or use an empty
return;
also continue the request chain.
Once all edge functions for the initial path run, Netlify evaluates any redirect rules declared for that path and then continues the request chain to eventually serve static content or return a response from a serverless function. For more details on the order of events, review our docs on the
declaration processing order
.
For example, this edge function uses
context.next()
to
transform the content
of the HTTP response to the requested path:
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
const
url
=
new
URL
(
request
.
url
)
;
// Look for the query parameter, and return if we don't find it
if
(
url
.
searchParams
.
get
(
"method"
)
!==
"transform"
)
{
return
;
}
const
response
=
await
context
.
next
(
)
;
const
text
=
await
response
.
text
(
)
;
return
new
Response
(
text
.
toUpperCase
(
)
,
response
)
;
}
;
If you want to modify and return the content of a path other than the requested one, use
fetch()
to retrieve it.
export
default
async
(
req
:
Request
)
=>
{
const
url
=
new
URL
(
"/welcome"
,
req
.
url
)
;
const
res
=
await
fetch
(
url
)
;
return
someTransformationFunction
(
res
)
;
}
;
export
const
config
=
{
path
:
"/hello"
}
;
#
Use conditional request
When using
context.next()
to transform a response, we modify the request to the downstream asset so that
conditional requests
don’t apply and you always get a full response back.
If you want full control over the client caching behavior and you’d like to use conditional requests, you should pass the
sendConditionalRequest
to the
context.next()
call.
export
default
async
(
req
:
Request
,
{
next
}
:
Context
)
=>
{
const
res
=
await
next
(
{
sendConditionalRequest
:
true
}
)
;
// If the response is a 304, it’s cached in the client and we can return it
if
(
res
.
status
===
304
)
{
return
res
;
}
// Transform the response however you need
const
text
=
await
res
.
text
(
)
;
return
new
Response
(
text
.
toUpperCase
(
)
,
res
)
;
}
;
#
Read request body
If you want to read the request body in your edge function, you need to explicitly pass on a new request with an unused body when you call
context.next()
afterwards. For example,
context.next(new Request(...))
. Without this, attempts to read the request body in subsequent edge functions will cause an error because a request body can only be read once.
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
body
=
await
req
.
json
(
)
;
if
(
!
isValid
(
body
.
access_token
)
)
{
return
new
Response
(
"forbidden"
,
{
status
:
403
}
)
;
}
return
context
.
next
(
new
Request
(
req
,
{
body
:
JSON
.
stringify
(
body
)
}
)
)
;
}
;
#
Runtime environment
Edge functions run in a
Deno
runtime environment that supports many standard Web APIs.
Edge Functions support Node.js built-in modules and Deno modules. Support for npm packages is in beta.
For Node.js built-in modules, prefix the import with
node:
, for example
import { randomBytes } from "node:crypto"
.
For Deno modules, use a URL import. You can do this directly in the edge function code, for example
import React from "https://esm.sh/react"
, or by using an
import map
.
For npm packages, install them
using
npm install
or your favorite package manager. Then import them using the package name, for example
import _ from "lodash"
. Support for npm modules is in beta, and some packages that rely on native binaries (like
Prisma
) or dynamically importing a file at runtime (like
cowsay
) might not work correctly. Please share feedback and bug reports
in the forums
.
Edge functions have access to environment variables in the runtime environment. If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to edge functions during runtime. Learn more about how to set and use
environment variables with functions
.
#
Import maps
When you import third-party modules in your edge function, it can be cumbersome to repeat the module’s full URL in every import statement.
To use module names in your import statements, use an import map file to map module URLs to names. Netlify edge functions support separate import map files instead of import maps defined in
deno.json
. You can place the import map file anywhere in the project directory. For example, this file maps
html-rewriter
to
https://ghuc.cc/worker-tools/html-rewriter/index.ts
:
{
"imports"
:
{
"html-rewriter"
:
"https://ghuc.cc/worker-tools/html-rewriter/index.ts"
}
}
To enable the import map, declare it in
netlify.toml
:
[
functions
]
deno_import_map
=
"./path/to/your/import_map.json"
You can now use
html-rewriter
as a shorthand for the module URL.
import
{
HTMLRewriter
}
from
"html-rewriter"
;
export
default
async
(
request
,
context
)
=>
{
return
new
HTMLRewriter
(
)
.
on
(
"p"
,
{
element
(
element
)
{
element
.
tagName
=
"h1"
;
}
}
)
.
transform
(
await
context
.
next
(
)
)
;
}
;
## Type definitions
For TypeScript, you can import the types for the
Context
and
Config
objects from
@netlify/edge-functions
. The types for the
Request
and
Response
objects are in the global scope.
#
Netlify-specific
Context
object
The
Context
object exposes the following properties:
#
account
An object containing Netlify team account information. The
id
property in the object holds the unique ID of the team that the site and function belong to.
#
cookies
A simplified interface for reading and storing cookies:
cookies.get(name)
:
reads a cookie with a given name from the incoming request.
cookies.set(options)
:
sets a cookie on the outgoing response, using the same format as the
options
value in
the
CookieStore.set
web standard
.
cookies.delete(name)
or
cookies.delete(options)
:
adds an instruction to the outgoing response for the client to delete a cookie. Following
the
CookieStore.delete
web standard
, accepts a string representing the name of the cookie, or an options object.
Setting cookies across subdomains requires a custom domain
Since the
netlify.app
domain is used by many customers, it is listed in the Mozilla Foundation’s
Public Suffix List
, which prevents setting cookies across subdomains.
#
deploy
An object containing Netlify deploy information with the following property:
context
:
the
context
of the deploy that the function belongs to.
id
:
unique ID of the deploy that the function belongs to.
published
:
a boolean that indicates whether or not the function belongs to the current
published deploy
.
#
geo
An object containing geolocation data for the client with the following properties:
city
:
name of the city.
country
:
code
:
ISO 3166 code for the country.
name
:
name of the country.
latitude
:
latitude of the location.
longitude
:
longitude of the location.
subdivision
:
code
:
ISO 3166 code for the country subdivision.
name
:
name of the country subdivision.
timezone
:
timezone of the location.
postalCode
:
postal (zip) code of the location. We support all regional formats, so the format will vary.
#
ip
A string containing the client IP address.
#
next(options?)
Invokes the
next item in the request chain
. The method returns a
Promise
containing the
Response
from the origin that your edge function can modify before returning.
For best performance, you should only use this method if you need access to the response body. In all other cases, you do not need to explicitly call
next
.
The method accepts an optional
options
object with the following property:
sendConditionalRequest
:
set to true if you’d like to use
conditional requests
.
#
next(request, options?)
Same method as above, except this one explicitly requires a
Request
object.
This variation allows you to read the request body in your edge function and then pass a new request object with an unread body to the next item in the request chain. Without this, the
next()
call could fail as a request body can only be read once.
#
params
An object containing the parameters set for the edge function’s
path
in the
configuration object
and the values they receive from the incoming request URL.
For example, for an edge function configured to run at
/pets/:name
, the
params
value for a request to
/pets/winter
will be
{"name":"winter"}
.
To access the query string, use
request.url
instead.
#
requestId
A string containing the Netlify request ID.
For example,
01FDWR77JMF2DA1CHF5YA6H07C
.
#
server
An object containing server metadata with the following property:
region
:
the region code where the deployment is running; for example,
us-east-1
.
#
site
An object containing Netlify site metadata with the following properties:
id
:
unique ID for the site; for example,
1d01c0c0-4554-4747-93b8-34ce3448ab95
.
name
:
name of the site, its Netlify subdomain; for example,
petsof
.
url
:
URL representing the main address to your site. It can be either a Netlify subdomain or your own custom domain if you set one; for example,
https://petsof.netlify.app
or
https://www.petsofnetlify.com
.
#
Netlify
global object
This global object exposes the following properties:
#
Netlify.context
The Netlify-specific
context
object
.
This property is available within the
scope
of the function handler. If accessed from outside the handler, it returns
null
.
#
Netlify.env
An object providing access to
environment variables
with the following properties:
delete(name)
:
in the context of the invocation, deletes an environment variable with a given name.
get(name)
:
returns the string value of an environment variable with a given name; if the environment variable is not defined,
undefined
is returned.
has(name)
:
returns a boolean value containing
true
if an environment variable with a given name exists, and
false
otherwise.
set(name, value)
:
in the context of the invocation, sets an environment variable with a given name and value.
toObject()
:
returns a plain object containing all the environment variables and their values.
#
Supported web APIs
Edge Functions support the following Web APIs:
console
. When you use
console.log
, the
Edge Functions logs
include which edge function generated the log message.
atob
btoa
Fetch API
fetch
Request
Response
URL
File
Blob
TextEncoder
TextDecoder
TextEncoderStream
TextDecoderStream
Performance
Web Crypto API
randomUUID()
getRandomValues()
SubtleCrypto
WebSocket API
Timers
setTimeout
clearTimeout
setInterval
Streams API
ReadableStream
WritableStream
TransformStream
URLPattern API
Last updated: March 27, 2025
←
Get started
Declarations
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_create-integration.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/create-integration/
Scraped_At: 2025-06-02T19:57:26.916491

Contact
Forums
Contact support
It’s possible for frameworks and other tools to dynamically create edge function files and declarations through integrations with the build process. For inspiration, you can explore the
framework-specific examples
on the Edge Functions overview. The examples highlight different use cases for developing build-generated edge functions.
Not a framework author? Create edge functions using the Netlify SDK
If you want to build a tool or integration that is unrelated to a framework, we recommend using the
Netlify SDK
instead. You can develop an extension that
injects edge functions
during the build step for a site and take advantage of the other functionality and features that come with the Netlify SDK. Learn more about
extending Netlify
.
This page will help you learn how to integrate your framework with Edge Functions by generating edge function files and declarations. If your framework’s build process uses Vite, then you can use
the Netlify Edge Functions Vite plugin
to generate a catch-all edge function file and declaration to serve all requests.
#
Generate function files
To generate edge function files, a framework emits one function file per edge function under
.netlify/edge-functions
. Build-generated edge function files go in this internal directory so as to not interfere with user-created files.
The generated function must be compatible with the
Deno
runtime. This means the following:
Imports of Node built-in modules must be prefixed with
node:
, for example
import { randomBytes } from "node:crypto"
.
All npm modules must be bundled in the function or changed to use URL imports. You can make a URL import directly in the edge function, for example
import React from "https://esm.sh/react"
, or by using an
import map
.
The generated file should use ES Modules format.
If your bundler supports build targets, it should target
browser
or
worker
.
#
Generate declarations
The framework must generate declarations either inline in the function files or in a manifest file at
.netlify/edge-functions/manifest.json
. The manifest file is a JSON object with the same structure as the
edge_functions
object from
netlify.toml
.
Avoid collisions between integrations
If you expect your integration to be used in conjunction with other integrations, avoid overwriting declarations from other integrations and be mindful about declaration order.
Declarations for build-generated edge functions support additional properties not available to user-created edge functions. Which additional properties are supported depends on whether the function is declared inline or in
manifest.json
.
Build-generated property
Supported inline
Supported in
manifest.json
generator
✓
✓
name
✓
✓
import_map
✓
version
✓
These additional properties are for the following purposes:
generator
is an optional property for noting the integration that generated the edge function. Setting this for your integration helps Netlify’s observability; this does not affect the user experience. We recommend using a value with a format of
@integration-name/plugin-name@1.2.3
, where the plugin version is included at the end.
name
is an optional property that allows you to set a display name for the function that appears in the Netlify UI.
import_map
is an optional property for specifying the path to an import map file. If this path is relative, it will be resolved in relation to the manifest file itself. The
manifest.json
declaration example below uses an import map found at
.netlify/edge-functions/import_map.json
, for example:
{
"imports"
:
{
"example"
:
"https://example.com"
,
"netlify:edge"
:
"this will be ignored, netlify: is a reserved prefix"
}
}
Note that any imports prefixed with
netlify:
are reserved, and may be overridden by built-in definitions.
version
is a required metadata property for
manifest.json
that tracks the version of the manifest format being used. Set this to
1
as demonstrated in the
manifest.json
example below.
Here are examples of build-generated declarations:
Loading error: Refresh the page to access this code sample
import
type
{
IntegrationsConfig
}
from
"@netlify/edge-functions"
;
export
default
async
(
)
=>
new
Response
(
"Hello, world!"
,
{
headers
:
{
'cache-control'
:
'public, s-maxage=3600'
}
}
)
;
export
const
config
:
IntegrationsConfig
=
{
path
:
"/hello"
,
generator
:
"@cool-framework/nice-plugin@1.0.0"
,
name
:
"greeting"
,
cache
:
"manual"
,
onError
:
"bypass"
}
;
{
"functions"
:
[
{
"path"
:
"/admin"
,
"function"
:
"auth"
,
"generator"
:
"@cool-framework/nice-plugin@1.0.0"
,
"name"
:
"/admin auth handler"
,
"onError"
:
"/unavailable"
}
,
{
"pattern"
:
"^/dashboard(?:/([^/#\\?]+?))[/#\\?]?$"
,
"function"
:
"auth"
,
"name"
:
"/dashboard/* auth handler"
}
,
{
"path"
:
"/blog/*"
,
"excludedPath"
:
"/blog/img/*"
,
"function"
:
"rewriter"
,
"cache"
:
"manual"
,
"onError"
:
"bypass"
,
}
,
{
"pattern"
:
"/products/(.*)"
,
"excludedPattern"
:
"/products/things/(.*)"
,
"function"
:
"highlight"
}
]
,
"import_map"
:
"./import_map.json"
,
"version"
:
1
}
#
Contact us
If you’d like to create an Edge Functions integration for a framework or other developer tool, we encourage you to let us know by reaching out through our
technology partner program
so we can help you.
We welcome your feedback on building integrations with this feature. Visit our
Forums
to join the conversation about Edge Functions.
Last updated: October 2, 2024
←
Limits
Usage & billing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_declarations.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/declarations/
Scraped_At: 2025-06-02T19:57:27.572295

Contact
Forums
Contact support
Unlike regular functions, edge functions aren’t automatically assigned a URL route for you to use as a function endpoint. Instead, you configure your edge functions to run on specific URL patterns.
You can configure the edge function path
inline in the function code
or
in
netlify.toml
.
#
Declare edge functions inline
To configure the edge function path in the same file as the function code, export a
config
object with the following properties:
path
:
URLPattern
expression on which paths to run the edge function. Must start with
/
, for example
path = "/*"
.
excludedPath
:
optional
URLPattern
exclusion to limit the routes matched by
path
. Must also start with
/
, for example
excludedPath = "/*.css"
. Accepts a single string or an array of strings.
pattern
:
alternative to the
path
property that allows for regex path matching.
excludedPattern
:
optional regex exclusion to limit the routes matched by
pattern
. Accepts a single regex or an array of regex.
method
:
optional HTTP methods that should run the edge function. Accepts a string or an array of strings.
onError
:
optional setting to control how this function
handles errors
.
cache
:
optional setting to opt in to
response caching
.
import
type
{
Config
}
from
"@netlify/edge-functions"
;
export
default
async
(
)
=>
new
Response
(
"Hello, world!"
)
;
export
const
config
:
Config
=
{
path
:
"/test"
,
}
;
This property can be a string if you want the edge function to run on a single path or an array of strings if you want to configure multiple paths.
In both cases, you can use
URLPattern
expressions
to match multiple paths.
import
type
{
Config
}
from
"@netlify/edge-functions"
;
export
default
async
(
)
=>
new
Response
(
"Hello, world!"
)
;
export
const
config
:
Config
=
{
path
:
[
"/"
,
"/products/*"
]
,
}
;
To limit the paths matched, use
excludedPath
.
import
type
{
Config
}
from
"@netlify/edge-functions"
export
default
async
(
)
=>
new
Response
(
"Hello, world!"
)
export
const
config
:
Config
=
{
path
:
"/*"
,
excludedPath
:
[
"/*.css"
,
"/*.js"
]
}
This example shows an edge function that runs on all requests except for requests to CSS or JS files.
Values for
path
and
excludedPath
must start with
/
, for example
path: "/*"
.
#
Declare edge functions in
netlify.toml
If you would like to declare multiple edge functions to run on the same path and customize the order they run in, configure edge function paths in
netlify.toml
instead of inline in the function file. You can use the following properties to configure
edge_functions
in
netlify.toml
:
function
:
name of the edge function you’re configuring.
path
:
URLPattern
expression on which paths to run the edge function. Must start with
/
, for example
path = "/*"
.
excludedPath
:
optional
URLPattern
exclusion to limit the routes matched by
path
. Must also start with
/
, for example
excludedPath = "/*.css"
. Accepts a single string or an array of strings.
pattern
:
alternative to the
path
property that allows for regex path matching.
excludedPattern
:
optional regex exclusion to limit the routes matched by
pattern
. Accepts a single regex or an array of regex.
cache
:
optional setting to opt in to
response caching
.
Each edge function declaration associates one or more site paths or patterns with one function to execute on requests that match the paths or patterns. A single request can execute a chain of edge functions from a series of declarations. A single edge function can be associated with multiple paths across various declarations. Edge functions run in order of declaration in the file, from top to bottom, with the exception that edge functions
configured for caching
always run after those that are not.
[
[
edge_functions
]
]
path
=
"/admin"
function
=
"auth"
[
[
edge_functions
]
]
path
=
"/admin"
function
=
"injector"
cache
=
"manual"
[
[
edge_functions
]
]
path
=
"/blog/*"
function
=
"auth"
[
[
edge_functions
]
]
path
=
"/blog/*"
function
=
"rewriter"
[
[
edge_functions
]
]
pattern
=
"/products/(.*)"
excludedPattern
=
"/products/things/(.*)"
function
=
"highlight"
[
[
edge_functions
]
]
path
=
"/*"
excludedPath
=
"/img/*"
function
=
"common"
This example shows how both paths and functions can be configured across multiple declarations.
A request for
/admin
would invoke the
auth
function first, then
common
, and finally
injector
. Because it is configured for caching, the
injector
function runs after the other functions even though it is declared between them.
The
auth
function runs for the
/admin
path and any child paths of
/blog
.
#
Declaration processing order
In general, edge functions are processed in the following order:
edge functions
declared in a configuration file
run before those
declared inline
framework-generated edge functions run before user-created edge functions
edge functions that are not configured for caching run before edge functions that are
configured for caching
This section outlines the processing order, and
any exceptions
, in more detail.
When a request is made for a path, such as
/admin
, edge functions run in the following order. Netlify loops through this order twice — the first time running edge functions that are not configured for caching and the second time running edge functions that are configured for caching.
Edge functions your framework generates and declares for the path in a configuration file.
Edge functions you declare for the path in
netlify.toml
. If you declare multiple edge functions for the same path, they run in order of declaration in the file, from top to bottom.
Note that if you declare the same edge function both in
netlify.toml
and inline, Netlify merges the configurations and treats them as inline declarations (refer to step 4). The inline configuration takes precedence for any duplicate fields.
Edge functions your framework and enabled integrations generate and declare for the path with inline configuration.
Edge functions you declare for the path with inline configuration. If you use inline configuration to declare multiple edge functions for the same path, they run in alphabetical order by function file name.
Once all edge functions for the path run, Netlify moves on to evaluate any redirect rules — unless the last
edge function returns a response
and ends the request chain. A redirect might request a new path that also requires edge functions and the above steps will repeat for that new path.
The request chain continues until it eventually serves static content or returns a request from a serverless function. Learn more about
request handling
with edge functions.
Use
netlify.toml
to be explicit about edge function order
If you want to customize the order in which multiple edge functions run on a given path, we recommend that you
add the declarations to
netlify.toml
instead of using inline declarations.
#
Processing order caveats
Keep the following caveats in mind as you write and configure your edge functions as these items can interrupt or change the expected order of events:
If the edge function for a path
returns a response
and terminates the request, redirects for that path do not occur.
If you declare an edge function for the target path of a
static routing rewrite
, the page at the target path will be served but the edge function will not execute for rewritten requests.
If the edge function uses
fetch()
for internal requests or
URL()
for internal rewrites, the command will start a new request chain and Netlify will run any edge functions that match that path first. If you want to request a specific static asset or serverless function with the same internal path, and not re-run the same edge functions, use
context.next()
instead.
If an edge function fails, what happens next depends on its
error handling
configuration.
Along with considering these caveats, we recommend you also review the
edge functions feature limitations
.
Last updated: November 5, 2024
←
API
Optional configuration
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_get-started.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/get-started/
Scraped_At: 2025-06-02T19:57:28.228555

Contact
Forums
Contact support
This page will help you get started with Edge Functions. It describes how to create, test, deploy, invoke, and monitor your edge functions.
#
Create an edge function
To create an edge function to deploy with your site, write a JavaScript or TypeScript file stored in your
edge functions directory
. The default edge functions directory is
YOUR_BASE_DIRECTORY/netlify/edge-functions
.
For example, create a function file at
netlify/edge-functions/hello.js
:
export
default
(
)
=>
new
Response
(
"Hello world"
)
;
export
const
config
=
{
path
:
"/test"
}
;
The file includes two parts:
The default export contains the handler function that runs when you make requests to the edge function. It often contains logic to modify requests and responses.
The
config
export configures the file as an edge function and provides the path on which the edge function will be invoked.
In this example, requests to
/test
will trigger the edge function and it will respond with
Hello world
.
Beyond the basics
To have nuanced control over the order in which edge functions run,
configure your edge function paths in
netlify.toml
instead of inline in the function file.
For even faster response times, you can
cache edge function responses
.
In case of an error, you can
customize error handling
.
Avoid using Edge Functions in your site to request assets from the same site using
fetch()
#
Edge functions with
.jsx
or
.tsx
You also have the option to use
.jsx
and
.tsx
files for your edge functions. This can be helpful if you want your function to handle server-side rendering (SSR) at the network edge.
For example, this
.tsx
file contains the code to stream React SSR at the edge without a meta-framework:
import
React
from
"https://esm.sh/react"
;
import
{
renderToReadableStream
}
from
"https://esm.sh/react-dom/server"
;
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
export
default
async
function
handler
(
req
:
Request
,
context
:
Context
)
{
const
stream
=
await
renderToReadableStream
(
<
html
>
<
title
>
Hello
</
title
>
<
body
>
<
h1
>
Hello
{
context
.
geo
.
country
?.
name
}
</
h1
>
</
body
>
</
html
>
)
;
return
new
Response
(
stream
,
{
status
:
200
,
headers
:
{
"Content-Type"
:
"text/html"
}
,
}
)
;
}
export
const
config
:
Config
=
{
path
:
"/hello"
,
}
;
Looking for type definitions?
For TypeScript, you can import the types for the
Context
and
Config
objects from
@netlify/edge-functions
. The types for the
Request
and
Response
objects are in the global scope.
#
Test locally
You can use
Netlify CLI
to test edge functions locally before deploying them to Netlify.
Ensure you have the latest version of Netlify CLI installed:
npm
install
netlify-cli
-g
Launch
Netlify Dev
to start a development environment that executes edge functions on local requests:
netlify dev
Visit
localhost:8888/test
to execute the
hello
edge function declared for the
/test
route.
Changes to edge functions are applied on new requests.
Edit
hello.js
to change the
Response
:
export
default
(
)
=>
new
Response
(
"Updated hello!"
)
;
export
const
config
=
{
path
:
"/test"
}
;
Save your updated function file.
Reload
localhost:8888/test
and note that the response has changed.
To debug edge functions locally, launch Netlify Dev with the
edge-inspect
or
edge-inspect-brk
flag. For details, visit the
CLI docs
.
By default, the
geo
location used is the location of your local environment. To override this to a default mock location of San Francisco, CA, USA, use the
--geo=mock
flag. To mock a specific country, use
--geo=mock --country=
with a two-letter country code. For more information about the
--geo
flag, visit the
CLI docs
.
#
Deploy
Use
continuous deployment
or
Netlify CLI manual deploys
to deploy your edge functions.
Use CLI version 12.2.8 or later for manual deploys
Manual deploys of edge functions are supported with Netlify CLI version 12.2.8 or later. Deploys made with older CLI versions will result in deployment errors.
If a project has TypeScript and JavaScript edge functions with the same name, for example,
my-function.ts
and
my-function.js
, the TypeScript function is ignored while the JavaScript function is deployed.
#
Invoke
Invoke the deployed production version of your
hello
edge function declared for the
/test
route by accessing
yoursitename.netlify.app/test
Deploys of edge functions are atomic. This means that when a new deploy includes changes to function logic or declarations, the behavior of edge functions in old deploys won’t be impacted. Updates to edge functions move to production only when you publish a new production deploy.
#
Monitor
To access logs for your production edge functions:
In the Netlify UI, for your chosen site, visit
Logs
>
Edge Functions
.
To access logs for other versions of your edge functions:
In the Netlify UI, go to your site’s
Deploys
tab.
Find the deploy of interest.
Follow the
Edge Functions
link in the deploy detail page header.
#
Log contents
Netlify provides a log of any console statements output by your edge functions. The log for each console statement includes the name of the edge function that generated the output.
#
Date filter
By default, the Edge Function log displays a live tail of the latest activity in
Real-time
. You can also filter to review data from a specific time period, including the
Last hour
,
Last day
,
Last 7 days
, or select
Custom
to input a specific date and time range.
#
Text filter
To make debugging easier, you can filter the logs by edge function name or path. If desired, you can also use
pattern matching
as part of your query.
#
Log retention
Logs are retained for at least 24 hours of edge function activity, even after a new edge function deployment. This log retention period increases to 7 days for certain
pricing plans
.
#
Log Drains
This feature is available on
Enterprise
plans.
You can connect your edge function logs to third-party monitoring services for analysis using Netlify’s Log Drains feature. Check out our
Log Drains
doc for more information.
Optional configuration for edge functions: edge functions directory
Last updated: May 13, 2025
←
Overview
API
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_limits.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/limits/
Scraped_At: 2025-06-02T19:57:29.108981

Contact
Forums
Contact support
Keep the following limitations in mind when working with Edge Functions.
#
Operation limits
Edge functions have limits for their size and the amount of memory and execution time they can use:
Code size limit:
20 MB after compression
This is the maximum edge function bundle size supported.
Memory per set of deployed edge functions:
512 MB
CPU execution time per request:
50 ms
This tracks all time spent running your scripts. Execution time does not include time spent waiting for resources or responses.
Response header timeout:
40 s
#
Invocation limits
The number of invocations allowed per month varies by team plan. Refer to the
pricing page
for details.
Cached responses from edge functions
configured for caching
do not count toward edge function invocations.
#
Feature limitations
If a site has
Netlify’s Split Testing
enabled, requests to that site will not execute edge functions.
If a site is using
Netlify’s Custom Headers
, including
basic authentication headers
, they will not apply to edge functions.
If a site has
prerendering
enabled, it will not apply to paths where the response is served from an edge function.
Unexpected collisions may occur if a site has multiple framework plugins generating edge functions as part of the build.
Edge functions can only
rewrite requests
to same-site URLs. To fetch content hosted on another Netlify site or an external site, use the
fetch
Web API
.
Edge functions
configured for caching
always shadow static files that actually exist within the site. If an edge function configured for caching is declared to run on
/*
and there’s a
cat.png
static file, a request to
/cat.png
serves the edge function rather than the static file.
There is no local caching for edge functions. Any HTTP headers for cache configuration in an edge function are ignored in local testing.
Netlify Edge Functions is not currently supported as part of our HIPAA-compliant hosting offering. For more information, visit our
Trust Center
and download our reference architecture for HIPAA-compliant composable sites on Netlify.
Learn more about the edge function processing order and caveats
Along with the above limitations, we recommend you review our docs on the
declaration processing order
and
caveats
to consider when you create edge functions.
Last updated: March 27, 2025
←
Optional configuration
Create an integration
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_optional-configuration.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/optional-configuration/
Scraped_At: 2025-06-02T19:57:30.041969

Contact
Forums
Contact support
This document describes optional configuration settings you can use for more control over how your edge functions are built and executed.
#
Edge functions directory
The default edge functions directory is
YOUR_BASE_DIRECTORY/netlify/edge-functions
.
You can specify a custom edge functions directory with the
edge_functions
key in
netlify.toml
. For example, to use the
my-custom-directory
directory, add the following to the
build
section in
netlify.toml
:
[
build
]
edge_functions
=
"my-custom-directory"
The path is an absolute path relative to the site’s
base directory
in your repository. To help keep your site secure, make sure your edge functions directory is outside of your
publish directory
so that your source files aren’t deployed as part of your site.
#
Response caching
You have the option to cache edge function responses for even faster response times. When the edge function gets a request and a cached response is available, we will serve the response directly from the edge cache. This bypasses the edge function invocation altogether and serves the response from as close to the user as possible for fast response times.
#
When to use caching
If an edge function is
used as an endpoint
to return a response directly and that response can be reused for different requests from multiple clients, we recommend that you configure the edge function for caching to further optimize performance.
If, however, the edge function is
used as middleware
to inform routing or transform requests / responses, we recommend that you do not configure the edge function for caching. This guarantees that the edge function will be invoked for every single request and can generate unique responses for different requests.
Here are some example use cases and recommendations:
Server-side rendering should use caching.
Imagine an edge function tasked with server-side-rendering a page and producing the HTML output. Since the output is the same for all requests, the initial response can be reused for future requests.
Personalization should not use caching.
Imagine an edge function that rearranges the order of items on a products page based on a set of preferences captured in a cookie. Since the outcome is unique to the specific client that is making the request, the logic for reading the cookie and rearranging the items needs to be invoked for every single request.
#
Configure an edge function for caching
There are two parts to configuring an edge function for caching:
Opt in to caching
by setting the
cache
property to
manual
Customize cache behavior
by specifying HTTP headers
If you do one part but not the other, your edge function responses will not be cached. They will use the default behavior and every request to the edge function will invoke the function for a fresh response.
Keep the
Edge Functions feature limitations
in mind when configuring caching.
#
Opt in to caching
You can set the
cache
property to
manual
inline in the function code, or in
netlify.toml
.
For inline configuration, use the
config
object in your edge function file.
import
type
{
Config
}
from
"@netlify/edge-functions"
export
default
async
(
)
=>
new
Response
(
"Hello, world!"
)
export
const
config
:
Config
=
{
cache
:
"manual"
,
path
:
"/hello"
}
For file-based configuration, use the
edge_functions
property in
netlify.toml
.
[
[
edge_functions
]
]
cache
=
"manual"
path
=
"/hello"
function
=
"hello-world"
#
Customize cache behavior
You must specify caching headers inline in the function code.
import
type
{
Context
,
Config
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
return
new
Response
(
"Hello world"
,
{
headers
:
{
'cache-control'
:
'public, s-maxage=3600'
}
}
)
;
}
#
Supported headers
We support the following HTTP headers for edge functions configured for caching:
Cache-Control
,
CDN-Cache-Control
, and
Netlify-CDN-Cache-Control
:
visit our
caching
doc to learn more about how Netlify handles these headers, including their order of precedence and supported directives.
Expires
:
store and reuse the cached response until this date/time. Overridden by
max-age
and
s-maxage
.
Vary
and
Netlify-Vary
:
visit our
caching
doc to learn more about how Netlify handles these headers, including supported instructions and guidance on when to use which option.
By default,
cached responses respect atomic deploys
. This means that
s-maxage
,
max-age
, and
Expires
are voided by a new deploy in an identical
deploy context
(such as the same Deploy Preview number, or the same branch deploy).
For example, imagine an edge function in published production deploy
A
that is configured for caching with
"cache-control": "public, s-maxage=3600"
. If deploy
B
becomes the new published production deploy five minutes later, we discard any responses previously cached. Even though the previously cached responses are configured to be stored and reused for one hour, they are discarded since they belong to a different deploy.
#
Error handling
Because edge function failures can have different consequences in different contexts, you can customize what happens after an edge function errors. By default, when an edge function errors, we stop the request chain and serve a
generic error page
.
Alternatively, you can choose to serve a rewrite to a specific custom path or have the request chain continue.
#
When to customize error handling
If an edge function is responsible for critical business logic, errors should block access (
fail closed
). Depending on your audience and content, the default error page may suffice or you may want to rewrite to a custom path.
If, however, the edge function is used for progressive enhancement, errors should allow access (
fail open
). In these cases letting the request proceed to serve baseline essential content is a better user experience than stopping the request and serving an error page.
Here are some example use cases for edge functions and recommendations for error handling:
Authentication on an internal site should serve the default generic error page.
If the edge function errors and the user cannot be authenticated, stopping the request chain and serving an error page protects your gated content. In the case of an internal site, the default error page is helpful to your engineering team because it provides a link to the edge function logs for troubleshooting.
Authentication on a customer-facing site should rewrite to a custom path.
If the edge function errors and the user cannot be authenticated, stopping the request chain and serving a custom error page protects your gated content. In the case of a customer-facing site, rewriting to a custom path allows you to provide a branded error message with more specific guidance to your site visitors to keep them engaged and get them unblocked.
Localization that is nice to have but not business-critical should be bypassed.
If the edge function errors and content can’t be translated based on the user’s location, it’s okay to let the request proceed and serve untranslated content. In this case, though the user experience isn’t ideal, the user can still engage with your content by using an external translation tool to read unlocalized text.
#
Configure error handling for an edge function
To customize error handling, use the
onError
property inline in the function code. Supported values are:
fail
:
serve a generic error page. This is the default if
onError
is not specified.
/YOUR_CUSTOM_PATH
:
rewrite to the specified same-site path. Must start with
/
. The path is served without invoking any edge functions that may be declared for that path.
bypass
:
skip the erroring edge function and continue the request chain.
Loading error: Refresh the page to access this code sample
import
{
Config
}
from
"@netlify/edge-functions"
export
default
async
(
)
=>
{
throw
new
Error
(
"error"
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/hello"
,
onError
:
"fail"
}
import
{
Config
}
from
"@netlify/edge-functions"
export
default
async
(
)
=>
{
throw
new
Error
(
"error"
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/hello"
,
onError
:
"/unavailable"
}
import
{
Config
}
from
"@netlify/edge-functions"
export
default
async
(
)
=>
{
throw
new
Error
(
"error"
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/hello"
,
onError
:
"bypass"
}
Last updated: January 16, 2024
←
Declarations
Limits
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_overview.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/overview/
Scraped_At: 2025-06-02T19:57:30.823691

Contact
Forums
Contact support
Edge Functions connect the Netlify platform and workflow with an open runtime standard at the network edge. This enables you to build fast, personalized web experiences with an ecosystem of development tools.
Using TypeScript and JavaScript, you can modify network requests to localize content, serve relevant ads, authenticate users, personalize content, redirect visitors, and much more. Edge Functions also support a new generation of edge-first web frameworks allowing your entire app to run at the edge, dramatically increasing performance in many cases.
All this dynamic processing happens in a secure runtime based on
Deno
directly from the worldwide network edge location closest to each user for fast response times. Plus, you have the option to cache edge function responses for even faster response times. With Netlify, your edge functions are version-controlled, built, and deployed along with the rest of your Netlify site. This eliminates overhead and brings the power of Deploy Previews and rollbacks to your edge functions.
#
Use cases
To learn more about what’s possible with Edge Functions, explore the following.
Reference examples of common patterns:
Transform responses with content includes
Set custom HTTP request headers
Localize content with geolocation
Rewrite responses from another URL
A/B tests using cookies
Calculate responses with WebAssembly
Framework-specific examples:
Astro
Eleventy
Hydrogen
Next.js:
React Server Components
,
Edge Middleware
Nuxt 3
Remix
SvelteKit
Qwik
#
Documentation
To learn how to create your own edge functions, check out the documentation.
Get started
:
basic hello world example that covers testing and debugging locally, deploying, invoking, and monitoring an edge function.
Edge Functions API
:
introduction to key concepts and a full endpoint reference.
Declarations
:
configuration details and processing order.
Optional configuration
:
options for more control over how your edge functions are built and executed, such as configuring edge functions for caching.
Limits
:
operation limits for the runtime environment and feature limitations.
Create an integration
:
guidance for framework authors making integrations for developers to use.
Usage and billing
:
how to monitor your invocation usage.
#
More Edge Functions resources
Full library of reference examples
Netlify blog: Edge Functions posts
Environment variables and functions
Use the Netlify Blobs API in an edge function
#
Feedback
We welcome your feedback on this feature. Visit our
Forums
to join the conversation about Edge Functions.
Last updated: September 11, 2024
Get started
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- edge-functions_usage-and-billing.txt --------
Start of file
URL: https://docs.netlify.com/edge-functions/usage-and-billing/
Scraped_At: 2025-06-02T19:57:31.547186

Contact
Forums
Contact support
You can check your team’s Edge Functions service usage under
Billing
>
Current services
>
Plan details
. This shows your current usage level and tracks the following metric:
Invocations:
metric that counts each time an edge function is invoked on a site owned by your team during the current billing period. If a
cached response
is available and served, no edge function invocation is made and no usage is incurred against your Edge Functions allotment.
For paid plans,
Edge Functions pricing
is metered on a team basis and scales with usage. When usage reaches the plan limit, the team will automatically add an extra usage package. Free tier accounts are also metered based on usage and
have a limit
.
#
More usage and billing resources
Billing FAQ
Billing
Last updated: December 2, 2024
←
Create an integration
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- environment-variables_get-started.txt --------
Start of file
URL: https://docs.netlify.com/environment-variables/get-started/
Scraped_At: 2025-06-02T19:57:32.468137

Contact
Forums
Contact support
Netlify offers multiple ways to securely create, update, and use environment variables for your sites.
This page outlines how to
create and manage
site environment variables and shared environment variables, how to
use environment variables
once they are declared, how to work with
.env
files
on Netlify, and how to configure your site’s
sensitive variable policy
.
#
Create environment variables
You can create environment variables with the Netlify UI, CLI, or API, or with a Netlify configuration file. Once you create environment variables, build and deploy your site for the additions to take effect.
#
Create variables with the Netlify UI, CLI, or API
When you create environment variables using the Netlify UI, CLI, or API, they are set and securely stored on Netlify. This means you can avoid committing any sensitive values to your repository. The Netlify UI reflects any changes made using the CLI or API and vice versa.
You can create
site environment variables
and
shared environment variables
.
Be aware that variables set in a Netlify
configuration file
override variables set with the Netlify UI, CLI, or API.
#
Site environment variables
There are three ways to create site environment variables:
In the Netlify UI, create site variables under
Project configuration
>
Environment variables
. You can create variables individually or import variables from a
.env
file.
With the Netlify CLI, use
env:set
to create a site environment variable, and
env:import
to import from a
.env
file. Review our
Get Started with Netlify CLI guide
to learn more.
With the Netlify API, use
createEnvVars
to create a new site environment variable. Review our
Get Started with Netlify API guide
to learn more.
If a shared environment variable and a site environment variable exist with the same key name and scope, the site environment variable’s contextual values take precedence in each deploy context. In addition, variables set in the
netlify.toml
will override those with the same key set in the Netlify UI. Review the
overrides
section to learn more.
#
Shared environment variables
This feature is available on
Pro
and
Enterprise
plans.
There are two ways to create shared environment variables:
In the Netlify UI, create shared variables under
Team settings
>
Environment variables
.
With the Netlify API, use
createEnvVars
to create a new shared environment variable. Review our
Get Started with Netlify API guide
to learn more.
Variables set at the team level are shared by all sites owned by the team. Only Team Owners can read and access shared variables through the Netlify UI, CLI, and API.
If a shared environment variable and a site environment variable exist with the same key name and scope, the site environment variable’s contextual values take precedence in each deploy context. Review the
overrides
section to learn more.
#
Create variables with a Netlify configuration file
You can create site environment variables with a Netlify
configuration file
stored in your repository. This file-based configuration method allows you to set different environment variables for different
deploy contexts
.
Note that you can’t set scopes for variables declared using the configuration file. All variables declared using this method have the
Builds
and
Post processing
scope.
Since
netlify.toml
is stored in your repository, we recommend setting sensitive values with the
Netlify UI, CLI, or API
instead, where possible.
Here is an example of how to declare variables in
netlify.toml
:
# Production context: all deploys from the Production branch
# set in your site’s Branches settings in the UI will inherit
# these settings. You can define environment variables
# here but we recommend using the Netlify UI for sensitive
# values to keep them out of your source repository.
[
context.production
]
publish
=
"output/"
command
=
"make publish"
environment
=
{
NODE_VERSION
=
"14.15.3"
}
# Here is an example of how to define context-specific
# environment variables. Be mindful when using this
# option and avoid committing sensitive values to public
# source repositories.
[
context.deploy-preview.environment
]
NOT_PRIVATE_ITEM
=
"not so secret"
# Branch Deploy context: all deploys that are not from
# a pull/merge request or from the Production branch
# will inherit these settings.
[
context.branch-deploy.environment
]
NODE_ENV
=
"development"
# Dev context: environment variables set here
# are available for local development environments
# run using Netlify Dev. These values can be
# overwritten on branches that have a more specific
# branch context configured.
[
context.dev.environment
]
NODE_ENV
=
"development"
# Specific branch context: all deploys from
# this specific branch will inherit these settings.
[
context.staging.environment
]
# “staging” is a branch name
NODE_ENV
=
"development"
Variables set in a configuration file override variables set with the Netlify UI, CLI, or API.
#
Modify and delete environment variables
There are multiple ways to edit or delete environment variables that you set using the Netlify UI, CLI, or API. Note that only Team Owners can read and modify shared variables.
Need to export your variables? Review the
export variables for your
.env
section below.
To apply environment variable changes, build and deploy.
Environment variable changes require a build and deploy to take effect.
#
Update variables with the Netlify UI
To edit or delete site environment variables:
Navigate to
Project configuration
>
Environment variables
for site environment variables or to
Team settings
>
Environment variables
for shared environment variables.
Filter the list of variables by key name to find the variable you want to modify. Then, select the variable from the list to expand the variable details.
Select
Options
>
Edit
or
Options
>
Delete
and then follow the prompts to complete your change.
#
Update variables with the Netlify CLI or API
You can use the Netlify CLI to update site environment variables and the Netlify API to update both site and shared environment variables.
With the Netlify CLI, use
env:set
to update a site environment variable,
env:import
to import from an updated
.env
file, and
env:unset
to delete a site environment variable and all of its contextual values.
With the Netlify API, use
updateEnvVar
to update all values for an environment variable,
setEnvVarValue
to update or create a single value for an existing variable,
deleteEnvVar
to delete a variable and all of its values, or
deleteEnvVarValue
to delete a specific value.
Review our
Get Started with Netlify CLI guide
and our
Get Started with Netlify API guide
to learn more.
#
Use environment variables
Once you’ve created environment variables, there are many different ways you can use them:
Use environment variables
during the build process
— such as in the
netlify.toml
, to install private npm modules, in Node.js script files, and in build plugins.
Use a custom script or framework-specific variables to
copy values into the site
code during the build process, for use while your site runs.
Use a
function
to access values during runtime.
Use variables for spam prevention with
forms
or to specify
signed proxy redirects
.
Use
snippet injection
to access values during post-processing.
If you inject values into the site using a build script or snippet injection, make sure to only include non-sensitive values.
#
Work with
.env
files
When you build on Netlify, the build system does not read
.env
files. Instead, you can
import the variables
from your
.env
file into Netlify before you build. This way your environment variables remain secure and out of your shared repository.
For local builds, the Netlify CLI will read the
.env
files you have stored in your local environment. These variables will therefore be available to your site for use.
Using Netlify configuration variables in
.env
files for your framework
If your framework references your
.env
file during the build step and you need to use Netlify’s configuration or read-only variables, review our docs on
how to add Netlify variable values to your
.env
.
#
Import variables from
.env
files
We recommend that you import the variables from your
.env
file into Netlify so that they are available during the build step. You can import environment variables using the
Netlify UI
or the
Netlify CLI
.
Environment variables in a
.env
file are formatted as key-value pairs. That is, a list of variables where each variable is on a new line and is formatted with the key name, followed by an equals sign, and then the value.
A single
.env
file represents the variables for a specific environment. Here is an example of a production
.env
file:
YOUR_API_KEY=a production secret
NODE_VERSION=16
NODE_ENV=production
To learn more about the parsing rules the Netlify UI and CLI follow for
.env
imports, review the
dotenv docs
.
#
Import variables with the Netlify UI
With the Netlify UI, you can import a
.env
file to your site environment variables or shared environment variables.
Imported variables are merged with existing environment variables. If existing variables have any of the key names in the
.env
file you’re importing, you can specify how Netlify should handle those conflicts.
Navigate to
Project configuration
>
Environment variables
for site environment variables or to
Team settings
>
Environment variables
for shared environment variables.
Select
Add a variable
>
Import from a .env file
.
Copy the contents of your
.env
file into the form.
Set the
Scopes
and
Deploy contexts
to use for these variables and values. All variables imported through this form submission will have the same scope and deploy context settings.
If the variables to import include keys that conflict with existing variables, a
Merge strategy
section will appear in the form. You can choose to either
Skip conflicts
and ignore any new values, or
Update conflicts
and set new
contextual values
for the existing variables.
Select
Import variables
to add the variables.
Scope changes may be ignored for environment variable conflicts
Scope changes only apply to existing variables when you select
All deploy contexts
to apply the same value for use across all deploy contexts. If an environment variable already exists with the same key name and you’re adding specific contextual values with this import, changes to the scope will be ignored.
#
Import variables with the Netlify CLI
Use the Netlify CLI command
env:import
to import environment variables from a
.env
file.
As the CLI works on a site level, you can only use it to import site environment variables. The imported variables are set to all scopes and with the same value for all deploy contexts.
By default, environment variables you import are merged with any existing ones on Netlify. If you would rather remove all existing variables and replace them with what is in the imported file, use the
--replace-existing
flag. For example:
# Warning: using the --replace-existing flag will delete all
# existing variables and keep only those imported from the .env
netlify env:import .env --replace-existing
#
Export variables for
.env
files
If you would like to export variables set and stored on Netlify, you can export them in
.env
format using the
Netlify UI
or the
Netlify CLI
.
#
Export variables with the Netlify UI
As
.env
files include variables for a specific environment, you can export environment variables from the Netlify UI for each deploy context.
Navigate to
Project configuration
>
Environment variables
for site environment variables or to
Team settings
>
Environment variables
for shared environment variables.
Select a deploy context in the
Context
filter.
Select the clipboard icon to copy the filtered list in
.env
format to your clipboard.
Paste the results in your local
.env
file or
import the variables
into another Netlify site.
#
Export variables with the Netlify CLI
You can export environment variables for each deploy context using the Netlify CLI command
env:list --plain
. With the
--plain
flag, the CLI outputs the results in plain text format that you can copy into your
.env
file locally.
By default, only those values set for the
Local development (Netlify CLI)
deploy context are output. To export the values from another deploy context, use the
--context
flag.
For example, to export all of the
production
deploy context values in
.env
format, use this command:
# list the production deploy context values in .env format
netlify env:list
--plain
--context
production
# list the production deploy context values in .env format
# and pipe results into a .env file
netlify env:list
--plain
--context
production
>
.env
#
Sensitive variable policy
Some environment variables you may want to keep private. This can pose a challenge for sites connected to public repositories, where anyone can trigger a Deploy Preview by making a pull/merge request from a fork. Deploys from people, automated services, or bots from outside your Netlify team (
unrecognized authors
) are always treated as untrusted deploys.
Site members’ deploys are trusted
Git provider accounts connected to a site member can trigger deploys without restrictions, even from forks. If a site member’s deploys are being treated as untrusted, make sure they
connect their Git provider account
to their Netlify user.
Netlify allows you to control whether untrusted deploys can access sensitive environment variables by choosing a sensitive variable policy. The policy is only available for sites connected to public repositories, and it includes the following options:
Require approval
(default)
:
policy that requires all untrusted deploys to be approved by a
site member
before the build can start. Deploys awaiting approval can be found at the top of the deploy list on the site
Deploys
tab. Accepting or rejecting a deploy request does not affect the status of the originating pull/merge request.
Deploy without sensitive variables:
policy that lets untrusted deploys build automatically, but variables identified as sensitive will not be passed to the deploy environment. You can adjust your site code to accommodate builds without sensitive variables present, or you can declare “public” variable values for the
deploy-preview
context.
Deploy without restrictions:
policy that treats untrusted deploys like any other Deploy Preview, building automatically with all variables present. Use this option only if you are not concerned about the potential exposure of any of your site’s environment variables.
By default, when Netlify detects potentially sensitive environment variables in your site configuration, we automatically apply the default setting above, requiring approval for all untrusted deploys. For customers using Netlify’s
Secrets Controller
feature, all environment variables marked as
Contains secret values
are included in the sensitive variable policy enforcement.
You can change this policy at any time in
Project configuration
>
Environment variables
>
Site policies
.
Sensitive variable policy for GitHub Enterprise Server or GitLab self-managed
Because
GitHub Enterprise Server and GitLab self-managed instances
enable a higher degree of access control, we treat all repositories from these instances as private. This means you won’t be able to set a sensitive variable policy for a site linked to a GitHub Enterprise Server or GitLab self-managed repository.
#
Deploy request notifications
When your sensitive variable policy is set to require approval for all untrusted deploys, you can add deploy notifications to trigger when a deploy request is
pending
,
approved
, or
rejected
. Visit the
deploy notifications doc
to learn more about the types of notifications available and how to configure them.
Last updated: May 13, 2025
←
Overview
Secrets Controller
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- environment-variables_overview.txt --------
Start of file
URL: https://docs.netlify.com/environment-variables/overview/
Scraped_At: 2025-06-02T19:57:33.171178

Contact
Forums
Contact support
Netlify environment variables allow you to configure your site’s build and functionality based on different parameters and deploy contexts.
This page describes the different environment variable options at Netlify, their override rules, limitations, and how to get started.
#
Environment variables at Netlify
Netlify offers a few different options for how you can
configure
and
use
environment variables:
There are two types of environment variables: shared environment variables that are available to all sites in your team and site environment variables set for specific sites. Site environment variables can override shared environment variables.
Environment variables have a key name,
scope
, and one or more
contextual values
. At Netlify, an environment variable’s contextual value is the value set for a specific
deploy context
. By default, environment variables are available to all scopes and have the same value for all deploy contexts.
You can mark environment variables as
Contains secret values
for additional access restrictions and security features with our
Secrets Controller
feature.
Netlify provides a set of
configuration variables
and
read-only variables
for use during the build process.
There is a
sensitive variable policy
that you can configure to control access to sensitive variables for sites connected to public repositories.
You can use the Netlify
CLI
and the Netlify
API
to access and modify environment variables stored on Netlify. Any updates made using the CLI or API will be reflected in the Netlify UI.
The Netlify UI offers the ability to review environment variables at a glance and to filter variables by key name, scope, and deploy context. Once you add a deploy context filter, you can use the Netlify UI to
copy the filtered data in
.env
format
.
All environment variable changes made in the Netlify UI, CLI, and API are captured in the
team audit log
so you can keep track of any variables that you and other team members create, modify, or delete.
For example, you can use the Netlify UI, CLI, or API to configure an environment variable that only functions can use and that has one value for use with production and another value for Deploy Previews:
Key:
API_KEY
Scope:
Functions
Values:
Production:
a production secret
Deploy Previews:
a non-production secret
#
Configuration options and limitations
Netlify supports two ways of setting and storing environment variables — with the Netlify UI, CLI, or API, or with a Netlify configuration file. Depending on which method you use, there are different environment variable options available.
We recommend using the Netlify UI, CLI, or API, where possible, to avoid storing sensitive values in your repository.
Netlify UI, CLI, or API
Netlify configuration file
Stored on Netlify
✓
Stored in your repository
✓
Set site environment variables
✓
✓
Set shared environment variables
✓
Set a single value that is available to all deploy contexts
✓
✓
Set a different value for each deploy context
✓
✓
Set specific scopes for variables
✓
Available to
builds
✓
✓
Available to
Functions
,
Edge Functions
, and
On-demand Builders
✓
Available to
snippet injection
✓
✓
Available to
forms
✓
Available to
signed proxy redirects
✓
Changes captured in
team audit log
✓
#
Value per deploy context
By default, environment variables have one value that is available to all
deploy contexts
. Alternatively, you can choose to set a different value for each of the following deploy contexts:
Production
: for the main site’s deployment.
Deploy Previews
: for previews we build for your pull/merge requests.
Branch deploys
: for all branch deploys. You can override this value on individual branches using a
Branch
value, outlined below.
Preview server
: for any
Preview Servers
running for that site. By default, this context inherits all values defined for
Local development
. Note that
Local development
environment variables cannot be marked as secret but you can mark environment variables as
secret
with the Preview Server.
Local development
: for local development using the Netlify CLI.
You also have the option to set a
Branch
value for use on a specific branch, such as
staging
or
docs
. Optionally, you can target all branches matching a prefix, by adding a wildcard at the end of the branch name, for example
release/*
will match
release/1.0
,
release/alpha-0.1
, and so on. The
Branch
value will be used for deploy permalinks, Deploy Previews, and branch deploys for the specified branch.
At Netlify, the value set for a specific deploy context is sometimes referred to as the environment variable’s contextual value.
The ability to set contextual values opens up more possibilities for how you can leverage environment variables on Netlify. For example:
Analytics or experiments you wish to run only on the live site in production
Modifying which CMS environment to use for production versus Deploy Previews
Adding new functionality that requires a specific token and testing the change in a Deploy Preview before it goes live
#
Scopes
This feature is available on
Pro
and
Enterprise
plans.
By default, environment variables apply to all scopes. Alternatively, you can limit variables to one or more of the following scopes:
Builds
: includes
site builds
. You can use environment variables with this scope during the build step to configure your site, framework, and function builds. Learn more about
build environment variables
.
Functions
: includes
Functions
,
Edge Functions
, and
On-demand Builders
. You can use environment variables with this scope to securely provide sensitive values for your functions to use while they run – values such as API keys and tokens. Learn more about
environment variables and functions
.
Runtime
: includes
forms
and
signed proxy redirects
. You can use environment variables with this scope to provide security tokens for your forms and redirects to use while your site runs in the browser.
Post processing
: includes
snippet injection
. You can use environment variables with this scope as Netlify serves your site in the browser – for example, you may add
data for the analytics script
that you inject for split testing.
By making variables available only to the scopes that need them, such as builds only or functions only, you can more tightly control where Netlify uses your sensitive data and avoid hitting any value
limits
for certain scopes.
#
Overrides
There are a few overrides to be aware of:
Environment variables set in
netlify.toml
override environment variables set with the same key name using the Netlify UI, CLI, and API.
If a site environment variable and a shared environment variable exist with the same key name, the site environment variable takes precedence for each of its scopes and for each deploy context it has a value for.
If you set environment variable values for different deploy contexts, the
deploy context precedence rules
apply.
For example, if you use the Netlify UI to declare the following environment variables:
Variable type
Key
Scope
Contextual values
Shared
GREETING
all
Production:
hello
Deploy Previews:
konnichiwa
Branch:staging:
bonjour
Site
GREETING
builds
Production:
aloha
Branch deploys:
guten tag
The following values will be used for
GREETING
:
Scope
Deploy context
Contextual value
Builds
Production
aloha
Functions
Production
hello
Builds
Deploy Previews
konnichiwa
Builds
Branch deploy for branch
staging
bonjour
Builds
Branch deploys for all other branches except for
staging
guten tag
Functions
Local development (Netlify CLI)
undefined
#
Limitations
The following limitations apply for environment variables:
Reserved variable names
. Netlify offers some read-only environment variables for
builds
and
functions
. The keys used by these read-only variables are reserved by Netlify. You can’t override these variables or their values.
Accepted characters
. Keys can only include alphanumeric characters and underscores, and the first character must be a letter. For example,
KEY1
is valid but
1KEY
and
_KEY1
are not valid.
Character and value limits
. Keys can contain up to 255 characters, and values can contain up to 5,000 characters. Values used by functions should fall within AWS’s
environment property limits
.
Shared variable access limitations
. Only Team Owners can read and edit shared environment variable values.
#
Get started
We recommend you start using environment variables at Netlify by taking the following steps:
Add and set
site environment variables
or
shared environment variables
with the Netlify UI.
Once you add a few variables, try to access or update your variables with the
Netlify CLI
or the
API endpoints
.
Update your site code or configuration to
use environment variables
during the build process, in functions, and more.
If your site is connected to a public repository, review your
sensitive variable policy settings
to control whether untrusted deploys can access sensitive environment variables.
Check the
team audit log
to review changes as you work with environment variables.
#
More environment variables resources
Build environment variables
Environment variables and functions
Verified Support Guide on
how to use build environment variables
Get started guide - use environment variables with functions
Injecting environment variable values in your
netlify.toml
file
Environment variables for different deploy contexts
Configure your deploy environment
Deploy to Netlify button - require or set environment variables
Environment variables for signed proxy redirects
Gatsby environment variables
Hugo version environment variable
Node.js functions runtime settings
Create environment variables
Create environment variables with the Netlify UI, CLI, or API
Site environment variables
Shared environment variables
Create environment variables with a Netlify configuration file
Sensitive variable policy
Use environment variables
Last updated: March 31, 2025
Get started
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- environment-variables_secrets-controller.txt --------
Start of file
URL: https://docs.netlify.com/environment-variables/secrets-controller/
Scraped_At: 2025-06-02T19:57:34.053014

Contact
Forums
Contact support
With Secrets Controller, your team can protect and manage environment variable values that require additional layers of security. Flag which environment variables are secrets, and Netlify will apply stricter requirements to them. While Netlify handles all environment variables securely, including encrypted storage, Secrets Controller protects environment variable secrets with an opinionated policy and additional security features.
This page outlines the environment variable
secrets policy
, how to
manage
environment variable secrets on Netlify, and how
secrets scanning
proactively finds embedded secrets before they’re exposed.
#
Environment variable secrets policy
Not all environment variables are created equal. Environment variable secrets are sensitive values that would have a detrimental impact on your organization or end users if they were accessed by the wrong party. When you flag environment variables as secret, Netlify’s opinionated policy enforces how these values are accessed and which scopes and features you can use with them.
This policy’s design removes options that could allow your team to inadvertently expose secrets and drives your team to be explicit about where secret values should be accessible.
Environment variable secrets have the following policy applied to them:
Secret values are write-only. After setting a value using the UI, CLI, or API, you will no longer have access to a human-readable version of the value.
Secret values must be set to explicit
deploy contexts
and
scopes
to avoid unexpected exposure.
After an environment variable is flagged as a secret, you cannot remove the flag to reveal the secret’s value.
Environment variable secrets cannot have the
post processing
scope
to avoid inadvertently exposing the value through features like
snippet injection
.
Only code running on Netlify’s systems can read the original, unmasked values. Your code running on edge functions, serverless functions, build process, etc. will have the original unmasked values of the environment variables. Code running
outside
of Netlify’s hosted systems will have masked versions of the environment variable values.
A value set in the environment variable’s
dev
deploy context
will
not
have this policy applied to it. As such, only the value for the
dev
deploy context will be unmasked from the UI, CLI, and API. This will allow developers to continue developing with non-secret values that are explicitly for development.
None of these policy enforcements can be changed or customized using any form of configuration.
Values are masked except in dev context
Our UI, CLI, and API won’t return unmasked values of environment variable secrets for any
deploy context
besides
dev
. Using the CLI to do a production build with
netlify build
won’t include the raw, unmasked values. Per the policy, only code running on our systems have access to the unmasked value.
#
Manage secret values
Environment variables that are marked as secret use the same underlying systems for configuring and managing values as other environment variables do. As such, you can use the same flows for
creating
and
modifying
environment variables. During those flows you can flag variables as secret if the values contain secrets.
#
Configure environment variable secrets
Environment variables are configured through Netlify’s UI, CLI, or API. For each method, you can specify values as secrets:
In the Netlify UI, create and modify variables under
Project configuration
>
Environment variables
or under
Team settings
>
Environment variables
. For new or existing variables, select
Contains secret values
to flag that an environment variable contains a secret.
If importing from an
.env
file in the Netlify UI, import all variables first, then select
Options
>
Edit
and select
Contains secret values
to flag specific environment variables as secrets.
With the Netlify CLI, use
env:set
with the
--secret
flag to create or modify a site environment variable to be an environment variable secret. Review our
Get Started with Netlify CLI
guide to learn more.
With the Netlify API, use
createEnvVars
and
updateEnvVar
to create or modify a site environment variable with the
is_secret
field set to
true
. Review our
Get Started with Netlify API
guide to learn more.
Environment variable secret values can be created and modified, but they’re not human-readable from the UI, CLI, or API after they’re flagged as secret. To avoid allowing access to secret values, once you flag an environment variable as a secret, this flag cannot be removed.
#
Use secret values
Environment variable secrets are environment variables that have restricted access. Per the secrets policy, only code running on Netlify will receive the raw, unmasked values. Within your code, you
use environment variable secrets
the same way as you use traditional environment variables.
Only values that are configured for the
dev
deploy context
are human readable from the UI, CLI, and API. This allows developers to use development context environment variables locally. All other contexts have restricted access based on our
environment variables secrets policy
.
#
Secrets scanning overview
When you explicitly mark which environment variables have secret values, Netlify proactively protects your team with secrets scanning. This process scans your repository code and build output files for the existence of secret values. If the scanning process finds secret values, it fails the build and adds the location of the secret values to the deploy log. Secrets scanning happens before publish and deploy steps to ensure secret values aren’t exposed publicly or stored in files that are downloadable by members of your Netlify team.
It’s easy to inadvertently add code that injects secrets into server and client code. When this happens, it can go undetected a long time after the initial leak. Secrets exposure can cost your company a lot of time, money, and customer trust. Secrets scanning is an essential security layer to protect your teams and end users.
Do I need Netlify secrets scanning if I’m scanning secrets on my repo?
We recommend using all security tools available to keep your team and users safe. While repository-specific secret scanning is a helpful tool for scanning secrets that your repository is aware of, there are secret values on Netlify that your code repo is unlikely to discover. For example, database passwords or server secret keys provided at runtime are unlikely to be in your code repository’s list of secrets.
#
Secrets scanning process
Secrets scanning searches all files that are in your site’s build, including code pulled from the repo and files generated during the build.
To reduce the chances of false positives, secrets scanning only searches for environment variable secret values that have more than four characters and are not booleans.
In the common build steps that inject data into files or bundles, you don’t always use the plaintext version of those values. Given this, Netlify’s secret scanning will search for different permutations of values in the following formats:
plaintext
base64-encoded
URI-encoded
In addition to the different encodings, any values that appear to be a multi-line string will also have their full value searched as a single line string and in multi-line form.
For example, with an environment variable secret such as
SECRET_ALPHABET="abc\ndef\nghi"
the scanner will find four matches in the following file.
abc\ndef\nghi <- plaintext

YWJjCmRlZgpnaGk= <- base64 encoded

abc%0Adef%0Aghi <- uri encoded

 abc
def
ghi <- the multi line value
#
Configure secrets scanning
When using environment variable secrets, secrets scanning is enabled automatically. Netlify will begin scanning on the next build after an environment variable is marked as secret. You may configure how the scanning works by setting any of the following environment variables at the site or team level.
Set these environment variables to some or all deploy contexts to customize secrets scanning for your site or team needs:
SECRETS_SCAN_ENABLED
:
default is
true
. Set to
false
to entirely disable secrets scanning protections for the site/team.
SECRETS_SCAN_OMIT_KEYS
:
default is
empty
. Set to a comma separated list of key names that should
not
be scanned for within this site or team.
SECRETS_SCAN_OMIT_PATHS
:
default is
empty
. Set to a comma separated list of file paths (relative to the repository root) that should
not
be scanned within this site or team. Values can be substrings of paths or use a glob pattern format.
When you set the values at the team level, you may use site-specific environment variable values to override the team level settings. Review the environment variable
overrides
section to understand how to apply these settings to meet your team’s needs.
#
Enhancing the sensitive variable policy
Netlify provides all customers who are using public repositories the ability to keep sensitive variables private and away from untrusted deploys through the
sensitive variable policy
. This feature provides you with the ability to protect sensitive variables on sites that use
public
repositories. To provide the sensitive variable policy capabilities, Netlify attempts to detect sensitive values based on heuristics such as the key name and the shape of the value.
Secrets Controller is designed to offer advanced security around explicitly flagged secrets.
When using Secrets Controller with a public repository, the sensitive variable policy applies to these environment variables:
any variables that Netlify automatically detects as sensitive, even if they are not specifically flagged with
Contains secret values
any variables explicitly flagged as sensitive by selecting
Contains secret values
With the sensitive variable policy, you can choose how to manage access to sensitive values for deploys from your public repo. Explicitly marked secret values are included in this policy.
Last updated: May 13, 2025
←
Get started with environment variables
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_notifications.txt --------
Start of file
URL: https://docs.netlify.com/forms/notifications/
Scraped_At: 2025-06-02T19:57:34.724160

Contact
Forums
Contact support
Stay updated on the latest form submissions and trigger your own custom workflows with form notifications. Send form notifications to email, webhooks, or a Slack workspace.
Set up notifications for verified submissions to a specific form or for all verified submissions to any form on your site.
To send form notifications to email or webhooks:
Go to
Project configuration
>
Notifications
>
Emails and webhooks
>
Form submission notifications
.
To send form notifications to a Slack workspace:
Check out our docs on setting up the
Netlify App for Slack
.
#
Slack notifications
Surface form submissions in Slack with just a few clicks. Learn more in the
Netlify App for Slack docs
.
#
Email notifications
By default, form notification emails are sent from formresponses@netlify.com, and any replies to a notification go to that address. To respond to a form submitter, you need to enter their address manually.
We recommend that you add an
<input>
with
name="email"
to your form. This sets the
Reply-to
value on the form notification email, allowing you to reply directly to the form submitter without manually entering their email.
#
Customize the email subject line
You can completely customize the email subject line in the email notifications that Netlify sends when someone submits a form from your site.
If you don’t customize the email subject line in the Netlify UI or in your Netlify HTML form, then your form will automatically apply a default email subject line.
You can customize the email subject line from the Netlify UI or in the HTML markup for your form.
We recommend that you choose one way to customize your email subject line since whatever you set in the HTML form overrides the settings in the Netlify UI.
As an overview of these options, consider the following:
To reference anything programmatically in the email subject line and keep the subject line version controlled, set the email subject line in your HTML form. Check out
the example HTML forms
.
To manage your form’s email subject line in the Netlify UI, set the email subject line at
Project configuration
>
Notifications
>
Emails and webhooks
>
Form submission notifications
. To change the email subject line, additionally select
Options > Edit notifications
. You many need to remove any email subject line specified in your forms’ HTML to keep the email subject line you specify in the Netlify UI.
You can also apply predefined variables to your email subject line, such as
%{formName}
,
%{siteName}
, or
%{submissionId}
.
For example, your email subject line can be
New lead from %{formName} (%{submissionId})
. Use these variables in the HTML form or in the Netlify UI.
#
Example HTML forms
This example sets the email subject line for your form notification to
Sales inquiry from mysitename.netlify.app
:
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify
=
"
true
"
>
<
input
type
=
"
hidden
"
name
=
"
subject
"
value
=
"
Sales inquiry from mysitename.netlify.app
"
/>
<
p
>
<
label
>
Your Name:
<
input
type
=
"
text
"
name
=
"
name
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Email:
<
input
type
=
"
email
"
name
=
"
email
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
The
Reply-to
email is whatever value the form submitter entered in the
Your Email:
field.
This example uses
predefined variables
to dynamically set your email subject line to
New lead from %{formName} (%{submissionId})
:
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify
=
"
true
"
>
<
input
type
=
"
hidden
"
name
=
"
subject
"
value
=
"
New lead from %{formName} (%{submissionId})
"
/>
<
p
>
<
label
>
Your Name:
<
input
type
=
"
text
"
name
=
"
name
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Email:
<
input
type
=
"
email
"
name
=
"
email
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
Older form or want to remove [Netlify] from subject line?
The example above assumes your form was created after May 5, 2023. Forms created before this date will have an automated
[Netlify]
prefix in your email subject line.
To remove
[Netlify]
from the subject line of your form submission email notification, check out our
[Netlify]
prefix removal docs
.
For greater control of form-triggered emails, or to connect other services, you can use the Netlify app on
Zapier
or
n8n
.
#
Remove
[Netlify]
prefix from your email subject line
Forms created before May 5, 2023 included
[Netlify]
as a default and automated prefix in the email subject line.
Now you can remove the
[Netlify]
prefix from your email subject line and completely customize your email subject line.
To remove
[Netlify]
from the email subject line of your form submission notification email:
If you have an email subject line specified in your HTML form, decide whether to
modify your existing email subject line in the HTML form
or opt to
use the Netlify UI
instead.
If you do not have an email subject line specified in your HTML form, you can just
edit the form notification settings in the Netlify UI
. All new forms will not include
[Netlify]
.
#
Remove
[Netlify]
prefix in the HTML form
To remove the
[Netlify]
prefix from your subject line and keep using the HTML form to specify the subject line, add the
data-remove-prefix
attribute to your HTML form’s email subject input field:
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify
=
"
true
"
>
<
input
type
=
"
hidden
"
name
=
"
subject
"
data-remove-prefix
value
=
"
Sales inquiry from mysitename.netlify.app
"
/>
<!-- Add other form fields here -->
</
form
>
In this example, your email subject line is
Sales inquiry from mysitename.netlify.app
. This removes
[Netlify]
from your new form notification emails. Learn more about this update in this
support Forums post
.
Note that if you have an HTML form with a different email subject specified, that subject will take precedence over any updates you make to the email subject line in the Netlify UI.
#
Zapier integrations
Netlify is available on Zapier, where you can connect Netlify with over 1,000 other applications. You can set up a “Zap” action to be triggered when there is a verified form submission on your website. You can
find out more on our blog
, or use one of the templates below to get started:
Start a deploy of your Netlify site after new Netlify form submissions
Netlify
Use this zap
Send Gmail emails for new Netlify form submissions
Gmail + Netlify
Use this zap
Save new Netlify form submissions to rows in Google Sheets
Google Sheets + Netlify
Use this zap
Create Salesforce leads from new Netlify form submissions
Netlify + Salesforce
Use this zap
Create Mailchimp subscribers from new Netlify form submissions
Mailchimp + Netlify
Use this zap
Create Zendesk tickets for new Netlify form submissions
Netlify + Zendesk
Use this zap
#
n8n integrations
Netlify is available on
n8n
, an open source tool that allows you to connect Netlify with other applications. By using one of n8n’s Netlify nodes, you can create your own automated workflow. To get started, you can use the
Netlify node
,
Netlify Trigger node
, or you can use the existing workflow below:
Add Netlify Form submissions to Airtable
Netlify Trigger node
Use workflow
Last updated: May 13, 2025
←
Submissions
Troubleshooting tips
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_setup.txt --------
Start of file
URL: https://docs.netlify.com/forms/setup/
Scraped_At: 2025-06-02T19:57:35.756683

Contact
Forums
Contact support
Netlify’s serverless form handling allows you to manage forms without extra API calls or additional JavaScript. Once enabled, the built-in form detection feature allows our build system to automatically parse your HTML at deploy time, so there’s no need for you to make an API call or include extra JavaScript on your site.
To get started, enable
automatic form detection
and then add a
netlify
attribute to your
HTML form
.
Wondering how Netlify handles form submissions?
Visit our
form submissions
doc to learn more about the form submissions UI, API endpoints, and more.
#
Automatic form detection
If you would like Netlify to automatically manage your form submissions, you need to enable form detection.
#
Enable form detection
To enable form detection for your site:
In the Netlify UI, go to
Forms
.
Select
Enable form detection
.
Starting with your next site deploy, Netlify will automatically scan your deploys for forms that require submission handling.
If you previously used Netlify Forms and disabled automatic form detection, follow the steps to
re-enable form detection
and start accepting submissions again.
#
Disable form detection
You may want to disable form detection if your site doesn’t have forms anymore or if you decide not to use Netlify to manage your forms. Disabling form detection will reduce post processing and may speed up deploys.
To disable form detection for your site:
In the Netlify UI, go to
Forms
>
Usage and configuration
>
Form detection
.
Select
Disable form detection
.
A confirmation prompt will appear. To continue, enter the name of your site and select
Disable form detection
.
Starting with your next site deploy, Netlify will no longer scan your deploys for forms and will disable
form submission
handling for any new or updated forms.
Warning
Disabling form detection is intended only for sites that don’t use Netlify Forms. If your site does use Netlify Forms, we recommend removing forms from your site code or altering your code to handle submissions by other means before disabling form detection.
#
Re-enable form detection
If you previously used Netlify Forms and disabled automatic form detection, follow these steps to re-enable form detection:
In the Netlify UI, go to
Forms
>
Usage and configuration
>
Form detection
.
Select
Enable form detection
.
Redeploy your site.
Once you redeploy your site, Netlify will automatically scan your deploys for forms and start accepting submissions again.
#
HTML forms
Once you
enable form detection
, add an HTML form to your site with a
data-netlify="true"
or a
netlify
attribute in the
<form>
tag. Deploy your site with that form included and you can start receiving
submissions
in your Netlify site admin panel.
Your form’s
name
attribute determines what we call the form in the Netlify UI. If you have more than one form on a site, each form should have a different
name
attribute.
Here’s an example of how to use the
data-netlify="true"
attribute or the
netlify
attribute in your form:
Loading error: Refresh the page to access this code sample
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify
=
"
true
"
>
<
p
>
<
label
>
Your Name:
<
input
type
=
"
text
"
name
=
"
name
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Email:
<
input
type
=
"
email
"
name
=
"
email
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Role:
<
select
name
=
"
role[]
"
multiple
>
<
option
value
=
"
leader
"
>
Leader
</
option
>
<
option
value
=
"
follower
"
>
Follower
</
option
>
</
select
>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
<
form
name
=
"
contact
"
method
=
"
POST
"
netlify
>
<
p
>
<
label
>
Your Name:
<
input
type
=
"
text
"
name
=
"
name
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Email:
<
input
type
=
"
email
"
name
=
"
email
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Your Role:
<
select
name
=
"
role[]
"
multiple
>
<
option
value
=
"
leader
"
>
Leader
</
option
>
<
option
value
=
"
follower
"
>
Follower
</
option
>
</
select
>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
When Netlify parses the static HTML for a form you’ve added, the build system automatically strips the
data-netlify="true"
or
netlify
attribute from the
<form>
tag and injects a hidden input named
form-name
. In the resulting HTML that’s deployed, the
data-netlify="true"
or
netlify
attribute is gone, and the hidden
form-name
input’s
value
matches the
name
attribute of
<form>
like this:
<
input
type
=
"
hidden
"
name
=
"
form-name
"
value
=
"
contact
"
/>
#
Submit HTML forms with AJAX
You don’t have to, but you can submit static HTML forms using AJAX.
A static HTML form submitted this way must have
data-netlify=true
or a
netlify
attribute inside its
<form>
tag. For an example of how to set these attributes, review the
HTML forms
section.
Here’s an AJAX form submission example using the
fetch
API for a static HTML form:
const
handleSubmit
=
event
=>
{
event
.
preventDefault
(
)
;
const
myForm
=
event
.
target
;
const
formData
=
new
FormData
(
myForm
)
;
fetch
(
"/"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/x-www-form-urlencoded"
}
,
body
:
new
URLSearchParams
(
formData
)
.
toString
(
)
}
)
.
then
(
(
)
=>
console
.
log
(
"Form successfully submitted"
)
)
.
catch
(
error
=>
alert
(
error
)
)
;
}
;
document
.
querySelector
(
"form"
)
.
addEventListener
(
"submit"
,
handleSubmit
)
;
Requirements for the request:
The body of the request must be URL-encoded. In the above example, the form is passed to a
FormData
constructor. That object is then encoded using the
URLSearchParams
constructor and converted to a string. Note that Netlify Forms does not support JSON form data at this time.
If the form accepts alphanumeric data only, the request should include the header
"Content-Type": "application/x-www-form-urlencoded"
. If the form accepts
file uploads
, including a
Content-Type
header is not recommended.
#
JavaScript forms
You don’t need to include extra JavaScript on your site to use Netlify Forms. But, if you want to, you can use JavaScript to render a form client-side. You can also submit JavaScript-rendered forms over AJAX.
#
Forms for Next.js or SSR frameworks
If you’re using a pure JavaScript form or SSR (Server Side Rendering), you must include an HTML form that meets this
HTML form criteria
, including all the input tags with the same names as the JavaScript form.
For instructions and examples specific to Next.js 13.5 and above, visit
breaking changes for the Next.js runtime
.
#
Work with JavaScript-rendered forms
The Netlify build system finds your forms by parsing the HTML of your site when the build completes. This means that if you’re using JavaScript to render a form client-side, our build system won’t find it in the pre-built files. You can work around this:
Create a hidden HTML form with the
data-netlify="true"
attribute or a
netlify
attribute and input fields with
name
attributes to match the inputs of your JavaScript-rendered form. You need to apply the same work around if you want to use our
reCAPTCHA 2 integration
, and create a
div
element in the hidden HTML with the
data-netlify-recaptcha="true"
attribute.
Add a hidden input to the JavaScript-rendered form or JSX form:
<
input type
=
"hidden"
name
=
"form-name"
value
=
"name_of_my_form"
/
>
You can also find related tutorials on our blog:
How to Integrate Netlify’s Form Handling in a React App
How to Integrate Netlify forms in a Vue App
While the two articles are fairly framework-specific, the code demonstrates how to prerender forms when working with them in a web application.
#
Submit JavaScript-rendered forms with AJAX
To submit a JavaScript-rendered form built with a framework like Gatsby or Nuxt, you can send an AJAX POST request to any path on your site. Requirements for the request:
You need to URL-encode your form data in the body of the request.
If you haven’t added a hidden
form-name
input to your JavaScript-rendered form, you need to send a
form-name
attribute in the AJAX POST request body.
If the form accepts alphanumeric data only, the request should include the header
"Content-Type": "application/x-www-form-urlencoded"
. If the form accepts
file uploads
, including a
Content-Type
header is not recommended.
Here’s an AJAX form submission code sample using the
fetch
API for a JavaScript-rendered form. It uses Gatsby’s
navigate
function to redirect to a custom page on form submission success.
const
handleSubmit
=
event
=>
{
event
.
preventDefault
(
)
;
const
myForm
=
event
.
target
;
const
formData
=
new
FormData
(
myForm
)
;
fetch
(
"/"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/x-www-form-urlencoded"
}
,
body
:
new
URLSearchParams
(
formData
)
.
toString
(
)
}
)
.
then
(
(
)
=>
navigate
(
"/thank-you/"
)
)
.
catch
(
error
=>
alert
(
error
)
)
;
}
;
For a JavaScript-rendered form, you need to add a hidden
input
with
name="form-name"
to the returned form elements. Here’s an example:
return
(
<
form
data-netlify
=
"
true
"
name
=
"
pizzaOrder
"
method
=
"
post
"
onSubmit
=
{
handleSubmit
}
>
<
input
type
=
"
hidden
"
name
=
"
form-name
"
value
=
"
pizzaOrder
"
/>
<
label
>
What order did the pizza give to the pineapple?
<
input
name
=
"
order
"
type
=
"
text
"
onChange
=
{
handleChange
}
/>
</
label
>
<
input
type
=
"
submit
"
/>
</
form
>
)
;
In the code sample above, a
handleChange
function updates the form’s state, which ultimately gets sent in a POST request to Netlify.
#
Success messages
By default, when visitors complete a form, they are redirected to a page with a generically styled success message with a link back to the form page.
#
Custom success page
You can replace the default success page with a custom page you create by adding an
action
attribute to the
<form>
tag, entering the path of your custom page (like
"/pages/success"
) as the value. The path must be relative to the site root, starting with a
/
. Here’s an example:
<
form
name
=
"
contact
"
action
=
"
/pages/success
"
method
=
"
POST
"
data-netlify
=
"
true
"
>
</
form
>
If you submit your form using AJAX, reference this
Gatsby-specific example
of how to set a custom success page.
#
Custom success alert
If you use AJAX to submit the form, you can substitute an alert instead of redirecting to a generic or custom page. Here’s an example for an HTML form:
const
handleSubmit
=
event
=>
{
event
.
preventDefault
(
)
;
const
myForm
=
event
.
target
;
const
formData
=
new
FormData
(
myForm
)
;
fetch
(
"/"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/x-www-form-urlencoded"
}
,
body
:
new
URLSearchParams
(
formData
)
.
toString
(
)
}
)
.
then
(
(
)
=>
alert
(
"Thank you for your submission"
)
)
.
catch
(
error
=>
alert
(
error
)
)
;
}
;
document
.
querySelector
(
"form"
)
.
addEventListener
(
"submit"
,
handleSubmit
)
;
#
File uploads
For information about interacting with uploaded files, visit the
submissions page
.
Netlify Forms can receive files uploaded with form submissions. To do this, add an input with
type="file"
to any form. Although most browsers will detect the encoding automatically, you can optionally include
enctype="multipart/form-data"
in the
<form>
tag,
Here’s a sample HTML form with a file upload field:
<
form
name
=
"
fileForm
"
enctype
=
"
multipart/form-data
"
data-netlify
=
"
true
"
>
<
p
>
<
label
>
<
span
>
Name:
</
span
>
<
input
name
=
"
name
"
type
=
"
text
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
<
span
>
Add file:
</
span
>
<
input
name
=
"
file
"
type
=
"
file
"
/>
</
label
>
</
p
>
<
button
>
Submit
</
button
>
</
form
>
<
p
class
=
"
result
"
>
</
p
>
#
File upload security
Forms that accept file uploads that contain personally identifiable information (PII) require additional security configuration. We recommend using the
Very Good Security
integration for this type of secure form upload.
#
Limitations
Keep the following considerations in mind when working with file uploads in forms.
Only one file upload per field is supported. For multiple file uploads, use multiple fields.
The form request has a maximum size limit of 8 MB.
File uploads time out after 30 seconds.
#
Submit file uploads with AJAX
When submitting a form with a file upload, including a
Content-Type
header is not recommended. The browser should detect and set the
Content-Type
automatically.
Here’s an AJAX form submission code sample using the
fetch
API for the above HTML form with file upload:
document
.
forms
.
fileForm
.
addEventListener
(
"submit"
,
event
=>
{
event
.
preventDefault
(
)
;
const
result
=
document
.
querySelector
(
".result"
)
;
fetch
(
"/"
,
{
body
:
new
FormData
(
event
.
target
)
,
method
:
"POST"
}
)
.
then
(
(
)
=>
{
result
.
innerText
=
"Success"
;
}
)
.
catch
(
error
=>
{
result
.
innerText
=
`
Failed:
${
error
}
`
;
}
)
;
}
)
;
#
Set up notifications
To monitor the content of your form submissions, you can set up notifications to send the content of the form submissions to an email address or to an external service with an HTTP POST request.
Learn more about
forms notifications
.
To set up notifications for your site’s form submissions:
For your site go to
Configuration
>
Notifications
>
Form submission notifications
, and select
Add notification
.
#
Review forms usage
For the last month (or billing period), you can review how many verified form submissions were made and the total storage size of all files uploaded.
For your site, go to
Forms
>
Usage and configuration
>
Usage
.
Learn more about
reviewing and managing forms usage
.
#
More Forms resources
Spam filters
Form submissions
Form submission notifications
Form-triggered functions
Troubleshooting tips
Forms usage and billing
Last updated: May 13, 2025
Spam filters
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_spam-filters.txt --------
Start of file
URL: https://docs.netlify.com/forms/spam-filters/
Scraped_At: 2025-06-02T19:57:36.854930

Contact
Forums
Contact support
All form submissions are filtered for spam
using Akismet
, an industry leader in spam detection. Only submissions that pass the filter are included in your form’s
Verified submissions
list in the
form submissions UI
. Submissions flagged as spam by Akismet can be found by switching to your form’s
Spam submissions
list.
Tip
You can
change the state of a submission
from spam to verified or vice versa.
#
Extra spam prevention
For additional protection to help prevent abuse of your forms, you can add a
honeypot field
, a
reCAPTCHA 2
, or both. We automatically reject submissions that do not pass these challenges. Junk submissions caught by a honeypot field or reCAPTCHA 2 won’t even be included in your form’s spam submissions. The
Submissions
page for a form will indicate if it has any extra spam prevention enabled.
#
Honeypot field
“Honeypot” fields are hidden form fields that lure bot users into completing a field that human users can’t detect. A form submitted with a completed honeypot field can be safely rejected because only a bot would detect and complete the field. You can alert Netlify to a hidden honeypot field by adding a
netlify-honeypot
attribute to your
<form>
with the name of your hidden field. Then make sure that field is present in the form, but hidden via CSS or JavaScript.
Here’s an example:
<
form
name
=
"
contact
"
method
=
"
POST
"
netlify-honeypot
=
"
bot-field
"
data-netlify
=
"
true
"
>
<
p
class
=
"
hidden
"
>
<
label
>
Don’t fill this out if you’re human:
<
input
name
=
"
bot-field
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Email:
<
input
type
=
"
text
"
name
=
"
email
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
When Netlify parses the static HTML during post-processing, the build system automatically strips the
netlify-honeypot
attribute from the
<form>
tag, leaving the honeypot input field in place. In the example above, if a spambot enters any value in
bot-field
, Netlify will quietly reject the form submission.
If you
submit your form with AJAX
, make sure that the honeypot field name is included in the body of the POST request. This happens automatically if you use
FormData()
to encode the body of the request.
#
reCAPTCHA 2 challenge
If you would like to add a
reCAPTCHA 2 challenge
to a form, Netlify can include one for you, or you can
add your own
.
#
Netlify-provided reCAPTCHA 2
To have Netlify provide the CAPTCHA:
Add a
data-netlify-recaptcha="true"
attribute to your
<form>
tag.
In the place where you’d like the CAPTCHA to appear, add an empty
<div>
element inside your form with the same
data-netlify-recaptcha="true"
attribute.
When your site is published, the form will include the necessary HTML to render the CAPTCHA.
Here’s an example:
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify-recaptcha
=
"
true
"
data-netlify
=
"
true
"
>
<
p
>
<
label
>
Email:
<
input
type
=
"
text
"
name
=
"
name
"
/>
</
label
>
</
p
>
<
p
>
<
label
>
Message:
<
textarea
name
=
"
message
"
>
</
textarea
>
</
label
>
</
p
>
<
div
data-netlify-recaptcha
=
"
true
"
>
</
div
>
<
p
>
<
button
type
=
"
submit
"
>
Send
</
button
>
</
p
>
</
form
>
When a visitor submits the form, our servers will validate the CAPTCHA server-side. If the validation fails, we’ll redirect the visitor back to the same page and reject the form submission.
You can include one Netlify-provided reCAPTCHA 2 challenge per page. To use multiple challenges on one page, add
custom reCAPTCHA 2
.
#
Custom reCAPTCHA 2
You can also add your own reCAPTCHA 2 code in your site and let Netlify validate that form submissions come from a human. This is useful if you want to have more control over your validations, if you use a JavaScript library to inject a CAPTCHA in your forms, or if you need more than one CAPTCHA on a page.
In this case, Netlify needs your reCAPTCHA 2 site key and secret for validating that the captcha response is correct. You can provide these values with
environment variables
in your site configuration. Use
SITE_RECAPTCHA_KEY
to set your site key, and use
SITE_RECAPTCHA_SECRET
to set the secret provided by reCAPTCHA 2.
To set up a custom reCAPTCHA:
Sign up for a reCAPTCHA API key pair
and follow the instructions for adding reCAPTCHA to your site. This typically involves adding a script before the closing
</head>
of your HTML template, and a snippet at the end of the
<form>
where you want the reCAPTCHA widget to appear.
Create the following environment variables for your site
using the Netlify UI, CLI, or API
:
A variable with the key name of
SITE_RECAPTCHA_KEY
and a value set to your reCAPTCHA API site key. If you have the option to set specific
scopes
for your environment variables, the scope must include both
Builds
and
Runtime
.
A variable with the key name of
SITE_RECAPTCHA_SECRET
and a value set to your reCAPTCHA API secret key. If you have the option to set specific
scopes
for your environment variables, the scope must include
Runtime
.
Add a
data-netlify-recaptcha="true"
attribute to the HTML form that has the custom reCAPTCHA widget.
<
form
name
=
"
contact
"
method
=
"
POST
"
data-netlify-recaptcha
=
"
true
"
data-netlify
=
"
true
"
>
<!-- input fields and custom reCAPTCHA snippet -->
</
form
>
The Netlify servers will check the submissions from that form, and accept them only if they include a valid
g-recaptcha-response
value.
If you
submit your form with AJAX
, make sure the
g-recaptcha-response
field is included in the body of the POST request.  This happens automatically if you use
FormData()
to encode the body of the request.
Last updated: June 26, 2023
←
Setup
Submissions
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_submissions.txt --------
Start of file
URL: https://docs.netlify.com/forms/submissions/
Scraped_At: 2025-06-02T19:57:37.679806

Contact
Forums
Contact support
This document covers features you can use to manage your form submissions and recommendations for sensitive data. To learn how you can be made aware of new form submissions, visit our
form notifications
page.
#
Form submissions UI
You can find all submissions to your Netlify forms in your site’s
Forms
tab. Select a form name from the
Active forms
list to access the submissions for that form. By default, only verified submissions are listed. You can switch to
spam submissions
using a menu above the list.
Note
If you’ve
disabled form detection
, Netlify will not process any new or changed forms in your HTML files during deploys. You can still access form submissions for any preexisting and unchanged forms, but any newly deployed or updated forms won’t support new submissions while form detection is disabled.
#
Export form submissions to CSV
You can export verified form submissions to a CSV file. From the
Forms
tab, select the form you want to export, then select
Download as CSV
near the top of the form detail page.
#
Change a form submission’s state
You can change the state of a submission from spam to verified or vice versa. To do so, check the box next to each submission title to select one or multiple submissions and then use the
Mark as spam
or
Mark as verified
button.
#
Delete a form submission
You can delete both verified submissions and spam submissions. To do so, check the box next to each submission title to select one or multiple submissions. After you select the submissions, a red
Delete submission
button will become available. When you select
Delete submission
, you’ll be prompted to confirm the deleting action. Once you confirm, your selected submissions will be deleted permanently.
#
Delete a form
You can delete a form and all of its submissions by selecting
Delete form
. You’ll be prompted to confirm the deleting action. Once you confirm, future submissions to the form will result in a
404
error and previous submissions will no longer be available. You may want to
export form submissions to CSV
before you delete your form.
#
API endpoints
You can use the
API
to get verified/spam submissions, delete submissions, delete forms, and more.
#
File uploads
When a form is submitted with one or more
file uploads
, a link to each uploaded file will be included in the form submission details. These are accessible in the Netlify app, in email notifications, in CSV exports, and from our API.
After you delete a form, the file uploads are still available by their direct URL for 24 hours because of the way caching works for forms by default.
#
Manage sensitive form data
Form submission data is securely stored in our user database. If your form collects personally identifiable information (PII), we recommend that you actively manage the data by exporting form submissions and deleting them regularly.
Forms that include file uploads with personally identifiable information should use the
Very Good Security
integration to protect this data.
#
Automatic sanitization
Our form handling automatically sanitizes form submissions to keep your site and business secure. Any code that gets submitted through Netlify Forms, such as
<script>
tags or anything else that could be harmful, is neutralized.
Take for example the following code:
<
script
>
alert
(
'Surprise!'
)
;
</
script
>
If someone tries to submit this through your form, we transform the code into the following to make it harmless:
&lt;script&gt;alert('Surprise!')&lt;/script&gt;
#
Form-triggered functions
You can integrate your forms with Netlify Functions by triggering a serverless function when a form submission is verified. Find out more in the
Functions
docs.
Last updated: May 13, 2025
←
Spam filters
Notifications
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_troubleshooting-tips.txt --------
Start of file
URL: https://docs.netlify.com/forms/troubleshooting-tips/
Scraped_At: 2025-06-02T19:57:38.473604

Contact
Forums
Contact support
This document provides troubleshooting tips for setting up a form. If you have questions that aren’t answered here, visit our Support Forums to get more advice about
how to debug your form
.
#
Custom success page
If you’re having trouble using the form
action
to customize the
success page
, try linking to your custom success page from somewhere on the same page as the form. Use the same exact path in your test link as you’re trying to use for the
action
attribute, and make sure the link works there before digging further into your form.
#
Extra spam prevention
If you’re adding a
honeypot field
or
reCAPTCHA 2 challenge
, you can check the form detail page to confirm whether or not the
Extra spam prevention
has been successfully enabled.
#
Missing submissions
Here are some common causes and solutions for missing form submissions.
#
Test submissions flagged as spam
If you’re sending test
submissions of your form
and not finding them in your
Verified submissions
list, it’s possible they’re getting
flagged as spam by Akismet
. Use the menu above the list to switch to
Spam submissions
and then recheck for your tests.
To avoid having your tests flagged as spam in the first place, we recommend you
enter a real email address instead of a fake one such as test@test.com.
write some full sentences in any textareas rather than a few nonsense characters.
spread out the rate of submissions from a single IP address.
#
Form detection disabled
If you’re not finding new form submissions in your
Verified submissions
list for updated or newly added forms, ensure that
form detection
is enabled for your site.
If this is your first time enabling form detection, go to
Forms
to turn on the setting. If you previously enabled form detection, go to
Forms
>
Usage and configuration
>
Form detection
to review the setting.
Once you
enable
or
re-enable form detection
, make sure you redeploy your site. Once you redeploy, Netlify will automatically scan your deploys for forms and will accept form submissions.
#
Missing data from old submissions
If you recently changed the name or type of a form field, data for that field from old submissions will no longer appear in the Netlify UI. This is because the Netlify UI only shows the form fields and data that correspond to the last deployed version of your form.
Fortunately, all of your previous submission data are still available through the Netlify API. You can request form data with the
listFormSubmissions endpoint
.
If you would like to review the data from both the old and current form fields in the Netlify UI, we recommend that you mark old form fields as “hidden” instead of removing or replacing them entirely.
#
Next.js Runtime v5 support
If you’re using Netlify Forms with Next.js Runtime v5, you need to extract your form definitions to a dedicated static HTML file and make sure that the form submission uses AJAX rather than full-page navigation. Refer to
the Next.js v5 breaking changes
for more information.
Last updated: May 13, 2025
←
Notifications
Usage & billing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- forms_usage-and-billing.txt --------
Start of file
URL: https://docs.netlify.com/forms/usage-and-billing/
Scraped_At: 2025-06-02T19:57:39.236218

Contact
Forums
Contact support
You can check your Forms service usage under
Forms
>
Usage and configuration
>
Usage
. This shows your current usage level and tracks your usage of the following services:
Submissions
: This counts the total number of verified
form submissions
across all forms on your site during this billing period.
File uploads
: This tracks the total storage size of all
files uploaded
through verified form submissions to your site during the current billing period.
For paid plans,
Forms pricing
is metered on a per-site basis and scales with usage. When usage reaches a level limit, the site will automatically upgrade to the next level or package. Free tier accounts are also metered based on usage and
have a limit
.
#
Change levels
Any team member with the ability to change the configuration for your site can also change levels for services on that site.
To do this, go to
Forms
>
Usage and configuration
>
Usage
, and select
Change level
. Level fees will be prorated and charged at the end of the billing cycle, to the team’s payment method.
#
More usage and billing resources
Billing FAQ
Billing
Last updated: May 13, 2025
←
Troubleshooting tips
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks-api.txt --------
Start of file
URL: https://docs.netlify.com/frameworks-api/
Scraped_At: 2025-06-02T19:57:40.321242

Contact
Forums
Contact support
Web development frameworks can use the Frameworks API to define how to deploy a site to Netlify. Use the API to provision and configure platform primitives so that developers don’t have to, allowing for a seamless integration with the framework and a zero-config setup.
The API is file-based: as part of the build command, the framework should write files to specific directories, with a well-defined format. Netlify then reads and further processes these files to create a deployment.
This page is for authors and collaborators of web frameworks who are building framework adapters for Netlify. It contains the full reference of the Frameworks API.
#
Features
#
.netlify/v1/config.json
Use the
config.json
file to configure how Netlify builds and deploys a site. It’s a subset of the
user-facing file-based configuration
(using JSON instead of TOML) and it supports the following properties.
edge_functions
functions
headers
images
redirects
#
edge_functions
Accepts edge function declarations with the
same properties as the user-facing configuration
. While edge functions can be
configured in the same file as the function code
, this property is useful if you would like to declare multiple edge functions to run on the same path and customize the order they run in.
{
"edge_functions"
:
[
{
"function"
:
"auth"
,
"path"
:
"/admin"
}
,
{
"cache"
:
"manual"
,
"function"
:
"injector"
,
"path"
:
"/admin"
}
,
{
"function"
:
"auth"
,
"path"
:
"/blog/*"
}
,
{
"function"
:
"rewriter"
,
"path"
:
"/blog/*"
}
,
{
"excludedPattern"
:
"/products/things/(.*)"
,
"function"
:
"highlight"
,
"pattern"
:
"/products/(.*)"
}
,
{
"excludedPath"
:
"/img/*"
,
"function"
:
"common"
,
"path"
:
"/*"
}
]
}
Entries of the
edge_functions
array in the
config.json
file only take a single path per edge function. This means that if you want to configure the edge function to run on
/path1
and
/path2
, you need to create two separate entries. This has the advantage of letting you configure the exact order of precedence of each edge function for a given path.
{
"edge_functions"
:
[
{
"function"
:
"my-framework-edge-function-1"
,
"path"
:
"/path1"
}
,
{
"function"
:
"my-framework-edge-function-2"
,
"path"
:
"/path1"
}
,
{
"function"
:
"my-framework-edge-function-2"
,
"path"
:
"/path2"
}
,
{
"function"
:
"my-framework-edge-function-1"
,
"path"
:
"/path2"
}
]
}
#
functions
Accepts function configuration options, including any property from
the inline configuration options
. When you define the properties, we prefer snake case — for example, use
included_files
instead of
includedFiles
.
{
"functions"
:
{
"directory"
:
"myfunctions/"
,
"included_files"
:
[
"files/*.md"
]
}
}
Optionally, you can apply these settings to only a subset of a site’s functions. For example, if a framework prefixes the functions it generates with
my_framework_
, it can target them within the
functions
object.
{
"functions"
:
{
"my_framework_*"
:
{
"included_files"
:
[
"files/*.md"
]
}
}
}
#
headers
Specifies
custom headers
that Netlify serves with the site when a client makes a request. It follows the same capabilities as the
headers
array of the
user-facing file-based configuration.
{
"headers"
:
[
{
"for"
:
"/*"
,
"values"
:
{
"Basic-Auth"
:
"someuser:somepassword anotheruser:anotherpassword"
,
"X-Frame-Options"
:
"DENY"
,
"cache-control"
:
"max-age=0,no-cache,no-store,must-revalidate"
}
}
]
}
#
images
Configures the
Netlify Image CDN
. You can specify
allowed domains for remote image transformations
.
The
remote_images
property accepts an array of
regular expressions
, which can represent specific subdomains or directories.
Note that slashes need to be double escaped (once due to the regular expression syntax, and a second time due to the JSON syntax). For example, here’s how you could configure the Image CDN to allow any images under
https://example.com/
.
{
"images"
:
{
"remote_images"
:
[
"https:\\/\\/example.com\\/.*"
]
}
}
#
redirects
Specifies
redirect and rewrite rules
that Netlify evaluates when a client makes a request. It follows the same syntax as the
redirects
array of the
user-facing file-based configuration.
{
"redirects"
:
[
{
"force"
:
false
,
"from"
:
"/old-path"
,
"status"
:
301
,
"to"
:
"/new-path"
,
"conditions"
:
{
"Country"
:
[
"US"
]
,
"Language"
:
[
"en"
,
"es"
]
}
,
"query"
:
{
"path"
:
":path"
}
}
,
{
"from"
:
"/news"
,
"to"
:
"/blog"
}
]
}
These rules are appended to any rules defined by the user in
the
_redirects
file
or
the
netlify.toml
file
. Since Netlify reads rules from top to bottom and processes the first matching rule it finds, this means that the user-defined rules take precedence over rules defined in the Frameworks API.
If you want to change this behavior and ensure that the rules defined by the framework are evaluated first, you can use the
redirects!
property instead (with an exclamation mark). Please note that this takes precedence over any redirect rules defined by framework users, so use it sparingly and make sure to communicate to your framework users how this might affect their workflows.
{
"redirects!"
:
[
{
"from"
:
"/some-path"
,
"to"
:
"/new-path"
}
]
}
#
.netlify/v1/blobs
Upload
blobs
to the
deploy-specific store
. This is useful if you want the ability to generate files at build time and then modify them at runtime throughout the lifecycle of the deploy.
Our build system traverses the
.netlify/v1/blobs/deploy
directory and generates a blob for each
blob
file it finds. The blob key is the path of the file relative to the
.netlify/v1/blobs/deploy
directory (without a leading slash).
.netlify/
└── v1/
    └── blobs/
        └── deploy/
            ├── example.com/
            │   └── blob
            └── netlify.com/
                ├── blob
                └── blob.meta.json
For example, the directory tree above would generate two blobs:
a blob with the key
example.com
, holding the contents of the file at
.netlify/v1/blobs/deploy/example.com/blob
a blob with the key
netlify.com
, holding the contents of the file at
.netlify/v1/blobs/deploy/netlify.com/blob
Optionally, you can include a
blob.meta.json
file that contains an object with arbitrary metadata, encoded as JSON, which you can then retrieve with the
getMetadata
and
getWithMetadata
client methods.
Root key
You can’t place a
blob
file directly under the
.netlify/v1/blobs/deploy
directory, because that would lead to an empty string as the relative path, which isn’t a valid blob key. If the concept of a root key exists in your specific use case (for example, naming keys after URL paths), you can place all entries under another sub-directory, like
my-cache
, and treat
my-cache
as
/
and
my-cache/child
as
/child
.
Let’s imagine that your framework implements a cache for HTTP requests. You could use Netlify Blobs to store cached responses, and make your generated
functions
and
edge functions
check whether there’s a blob for a given URL before making an HTTP call.
// .netlify/v1/functions/my-framework-cache.ts
import
{
getDeployStore
}
from
"@netlify/blobs"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
{
domain
}
=
context
.
params
;
const
cache
=
getDeployStore
(
)
;
const
cachedResponse
=
await
cache
.
get
(
domain
,
{
type
:
"stream"
}
)
;
if
(
cachedResponse
!==
null
)
{
return
new
Response
(
cachedResponse
)
;
}
const
response
=
await
fetch
(
`
https://
${
domain
}
`
)
;
const
body
=
await
response
.
blob
(
)
;
await
cache
.
set
(
domain
,
body
)
;
return
response
;
}
export
const
config
:
Config
=
{
// Accepts requests on paths like "/cache/example.com".
path
:
"/cache/:domain"
}
To pre-warm the cache with a response for
https://example.com
, you could fetch it at build time and write the response to a file at
.netlify/v1/blobs/deploy/example.com/blob
.
Additionally, you could modify the example above to also persist the headers of cached responses. To write a metadata object for the same
example.com
key, write a JSON object to
.netlify/v1/blobs/deploy/example.com/blob.meta.json
with a payload like:
{
"headers"
:
{
"Content-Type"
:
"text/html; charset=UTF-8"
,
"Date"
:
"Wed, 12 Jun 2024 09:14:11 GMT"
}
}
#
.netlify/v1/edge-functions
Generate
edge functions
for a site and configure the URL paths on which they run.
Edge Functions let you intercept requests at the very beginning of the request chain, and intercept responses just before they are delivered to the client. In both cases, you have the option to modify the payloads in any way you like.
For example, you could generate an edge function that intercepts requests for JSON (by inspecting
the
Accept
header
) and
rewrite them
to a path that implements your framework’s API route. If a client requests
https://example.com/products/123
and asks for a JSON response, the edge function would serve the contents of the
https://example.com/api/products/123
path.
To create this edge function, your framework would write the code below to a file at
.netlify/v1/edge-functions/my-framework-api-route-handler.ts
.
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
if
(
req
.
headers
.
get
(
"accept"
)
===
"application/json"
)
{
const
{
pathname
}
=
new
URL
(
req
.
url
)
return
new
URL
(
`
/api
${
pathname
}
`
,
req
.
url
)
}
}
export
const
config
:
Config
=
{
// Configures the paths on which the edge function runs.
// The value below lets you intercept requests for any path.
path
:
"/*"
,
// Sometimes it's useful to exclude certain paths.
// This example will ignore requests that are
// already targeting an `/api/` path.
excludedPath
:
[
"/api/*"
]
}
;
#
Configuration options
To configure generated edge functions from within the function file, export a
config
object. It accepts the following properties:
path
(
string
or
string[]
): The URL path or set of paths for which the edge function is invoked. It accepts a string for a single path, or an array of strings for multiple paths. It supports wildcards and named parameters using
the
URLPattern
web standard syntax
.
excludedPath
(
string
or
string[]
): A URL path or set of paths for which the edge function is never invoked. It accepts a string for a single path, or an array of strings for multiple paths. It supports wildcards and named parameters using
the
URLPattern
web standard syntax
.
method
(
string
or
string[]
): A method or set of methods for which the edge function is invoked. Supported HTTP methods are GET, POST, PUT, PATCH, DELETE, and OPTIONS. If not specified, the edge function is invoked for all methods.
cache
(
string
): Opts in to
response caching
.
name
(
string
): A human-friendly name for the edge function. It is shown instead of the filename in build logs and in the UI.
generator
(
string
): Lets you tag an edge function with the name and the version of your framework. While this has no direct effect on any user-facing areas, it lets us internally correlate requests for this edge function with a specific framework version to identify and troubleshoot possible issues with a release.
onError
(
string
): Defines the behavior for
when the edge function terminates unexpectedly
. You can choose to serve a generic error page (
fail
, the default value), skip the erroring edge function and continue the request chain (
bypass
), or provide a URL path that requests are rewritten to in the event of an error (for example,
/my-framework-error-page
).
rateLimit
(
object
): Sets
custom rate limiting rules
for the edge function.
Static values only
The
config
object must be defined in
the edge function’s main file
and it must not be renamed or re-exported. It can only use static values, which means that using constants or variables is not allowed.
#
Bundling
When an edge function is created, either directly by a user or by a framework using the Frameworks API, Netlify automatically handles the bundling process. This involves collecting all the edge function’s dependencies, including local imports and
third-party modules
, into a single file.
Optionally, you can choose to handle this process yourself, using tools like
esbuild
or
Vite
to generate a self-contained bundle with all the dependencies inlined. When you do this, the Netlify bundling process is essentially a no-op, and we use your generated bundle as is.
There are some things to consider if you choose to do this:
It’s important to note that
edge functions run on Deno
, not Node.js. This has the following implications:
You shouldn’t rely on Node.js built-ins.
You should always generate ESM code (not CommonJS) with the latest syntax.
If you’re bundling your code using esbuild, set
the
platform
property
to
neutral
and set
target
to
esnext
.
For Vite, set
target
to
webworker
and
mark all Node.js built-ins as external
.
#
Import maps
You can customize the resolution of module specifiers in edge functions using
import maps
. To do this, place a file following
the import map syntax
at
.netlify/v1/edge-functions/import_map.json
.
For example, the file below would let you rewrite the bare specifier
html-rewriter
to a specific remote URL, and point
utils
to a local directory so you can import
utils/ab-test.ts
instead of
./nested/directory/utils/ab-test.ts
.
{
"imports"
:
{
"html-rewriter"
:
"https://ghuc.cc/worker-tools/html-rewriter/index.ts"
,
"utils/"
:
"./nested/directory/utils"
}
}
#
.netlify/v1/functions
Generate serverless functions for a site and configure the URL paths on which they run. It accepts the same naming conventions and uses the same syntax as
user-defined functions
.
Functions are a way to dynamically render parts of your application, like API routes. You can also use them to power your framework’s
server-side rendering
capabilities.
For example, you could generate an SSR function by writing the following code to
.netlify/v1/functions/my-framework-ssr.ts
.
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
import
{
renderPage
}
from
"./your-framework-code.ts"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
html
=
await
renderPage
(
req
)
;
return
new
Response
(
html
,
{
headers
:
{
"content-type"
:
"text/html"
}
}
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/*"
// Sometimes it's useful to exclude certain paths.
// This example will ignore requests that are
// already targeting an `/api/` path.
excludedPath
:
[
"/api/*"
]
}
;
#
Configuration options
Generated functions can be configured from within the function file using an exported
config
object. It accepts the following properties:
path
(
string
or
string[]
): The URL path or set of paths for which the function is invoked. It supports wildcards and named parameters using
the
URLPattern
web standard syntax
.
excludedPath
(
string
or
string[]
): A URL path or set of paths for which the function is never invoked. It accepts a string for a single path, or an array of strings for multiple paths. It supports wildcards and named parameters using
the
URLPattern
web standard syntax
.
preferStatic
(
boolean
): By default, functions run for any requests to the configured paths, regardless of whether or not they also match static files. To prevent the function from shadowing files on the CDN, set
preferStatic: true
.
displayName
(
string
): A human-friendly name for the function. It is shown instead of the filename in build logs and in the UI.
generator
(
string
): Lets you tag a function with the name and the version of your framework. While this has no direct effect on any user-facing areas, it lets us internally correlate requests for this function with a specific framework version to identify and troubleshoot possible issues with a release.
includedFiles
(
string[]
): List of additional paths to include in the function bundle. Although Netlify includes statically referenced files (like
require("./some-file.js")
) by default, you can specify additional files or directories and reference them dynamically in function code. You can use
*
to match any character or prefix an entry with
!
to exclude files. Paths are absolute paths relative to the base directory.
nodeBundler
(
string
): Changes the default bundling mechanism used to collect all function dependencies (including local files and third-party modules) into a deployable package. You can set it to
esbuild
if you want to use
esbuild
to bundle everything into a single file, which usually leads to a smaller payload; you can set it to
none
if you want to use
your own bundling process
.
externalNodeModules
(
string[]
): When setting
nodeBundler
to
esbuild
, this property lets you provide a list of npm packages that are marked as
external
, which means their original structure is kept in a
node_modules
directory as opposed to being inlined with the function code.
ignoredNodeModules
(
string[]
): When setting
nodeBundler
to
esbuild
, this property lets you provide a list of npm packages that are marked as
external
but whose source is not preserved in the
node_modules
directory. This should only be used for packages that you know for a fact are not used at runtime, otherwise it can lead to an error when the function is invoked.
nodeVersion
(
string
): Sets the major version of Node.js to run the function with. It takes values like
20
to use Node.js 20.x, for example.
schedule
(
string
): When defined, turns the function into a
scheduled function
and defines the schedule on which it runs.
rateLimit
(
object
): Sets
custom rate limiting rules
for the function.
Static values only
The
config
object must be defined in
the function’s main file
and it must not be renamed or re-exported. It can only use static values, which means that using constants or variables is not allowed.
#
Bundling
When a function is created, either directly by a user or by a framework using the Frameworks API, Netlify automatically handles the bundling process by default. This means collecting all the function’s dependencies, including local files and third-party modules, into a deployable package.
Optionally, you can choose to take control over this process. This may be useful if your framework already includes its own bundling pipeline. To opt out of the default bundling mechanism, you must set two configuration properties (
nodeBundler
and
includedFiles
) in the function’s
config
object.
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
return
new
Response
(
"Hello world"
)
;
}
export
const
config
:
Config
=
{
// Setting `nodeBundler` to `none` lets you opt out of the
// automatic bundling process.
nodeBundler
:
"none"
,
// When using a custom bundling process, you must provide the
// full list of files to include in the deployable package.
// You can use the `includedFiles` property, which supports globs.
includedFiles
:
[
"my-framework-bundle-output/**"
]
}
;
#
Merging configurations
All Netlify platform primitives can be provisioned and configured directly by developers — for example, a developer can create a redirect rule by
writing a
_redirects
file
or deploy a function by
writing a file to the functions directory
.
The Frameworks API was designed to extend these configuration options, not override them. This means that any user-defined configurations are respected, and the following rules apply when those configurations are merged with the Frameworks API:
For properties that are “additive” (like the
allowed domains for the Netlify Image CDN
or
the list of serverless functions
), any entries from the Frameworks API are appended to the ones defined by the user; if order is relevant, user-defined configuration takes precedence
For properties that are mutually-exclusive (like the
functions directory
), any user-defined configuration takes precedence
Avoid collisions with user-defined functions
To help make sure your framework-defined functions aren’t overridden by user-defined functions, we recommend that you include your framework’s name in your function names. For example,
my-framework-ssr.ts
.
#
Versioning
The filesystem is the only interface to the Frameworks API; there are no client libraries for programmatic access. This lowers the barrier of entry to the absolute minimum, allowing any framework, of any technology stack, to take advantage of the Netlify platform by writing files to disk.
But even without pulling in a library, there is still an intrinsic dependency between the Frameworks API and any framework that uses it. As we update the API surface with new features or changes to existing ones, we will always do so in a backward-compatible way, to ensure that all framework versions continue to operate without any disruption.
To this end, all features have a version identifier in their file paths (for example,
.netlify/v1/config.json
). A breaking change to that feature would be released as
.netlify/v2/config.json
, with no changes to the previous path, giving framework authors the choice to update their implementation at their own schedule.
Last updated: November 25, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/
Scraped_At: 2025-06-02T19:57:41.032218

Contact
Forums
Contact support
Netlify automatically detects and configures your project based on the framework you’re using. This page describes commonly used
build settings
and other configuration tips for popular build tools and project architectures. Your particular settings may be different. For projects that require more advanced setup, check out common configurations for:
Monorepos
SPA (Single page applications
Ignoring builds
If you're a framework author, the
frameworks API
is available to integrate your framework with Netlify.
#
Definitions
The following sections outline the typical
build command
and
publish directory
settings for popular frameworks.
Build command:
the command to run to build your site if you are using a static site generator or other build tool. For example,
npm run build
. The build command runs in the Bash shell, allowing you to add Bash-⁠compatible syntax to the command.
Publish directory:
directory that contains the deploy-ready HTML files and assets generated by the build. The directory is relative to the base directory, which is root by default (
/
).
Only files in the publish directory are deployed
Files and assets located outside of the publish directory won’t be included in site deploys.
#
Angular
Our docs provide an overview for using
Angular on Netlify
, while our blog post
First steps using Netlify & Angular
includes task-based setup instructions. The typical build settings are as follows. They differ depending on how you’ve set up your project and whether you’re using
Scully
, the static site generator for Angular.
For a standard Angular project:
Build command:
ng build --prod
Publish directory:
dist/YOUR_PROJECT_NAME
Using Angular Universal for prerendering:
Build command:
npm run prerender
Publish directory:
dist/YOUR_PROJECT_NAME/browser
Using Scully:
Build command:
ng build —prod && npm run scully
Publish directory:
dist/static
#
Astro
Our docs provide an overview for using
Astro on Netlify
. You can also check out our introductory
blog post about Astro and SSR
. The default build settings are as follows:
Build command:
astro build
Publish directory:
dist
#
Create React App
Check out our docs overview for using
Create React App on Netlify
or read the instructions for
deploying to Netlify
in the Create React App docs. The typical build settings are as follows:
Build command:
react-scripts build
Publish directory:
build
#
Eleventy
Our docs provide an overview for using
Eleventy on Netlify
, and we have a
Let’s Learn Eleventy
blog post with instructions to get started with the framework. The default build settings are as follows:
Build command:
eleventy
Publish directory:
_site
#
Express
Express apps can be deployed to Netlify using Netlify Functions. Our docs provide an overview for using
Express on Netlify
. If paired with a frontend, Express apps on Netlify do not need any specific build settings. Netlify packages and bundles your functions automatically during the build process.
#
Gatsby
Our docs provide an overview for using
Gatsby on Netlify
, while the Gatsby docs include task-based instructions for
deploying Gatsby sites to Netlify
. For apps that use Gatsby Functions or can benefit from build caching, we provide the
Essential Gatsby build plugin
.
The typical build settings are as follows:
Build command:
gatsby build
Publish directory:
public
#
Gridsome
The Gridsome docs include instructions for
deploying Gridsome to Netlify
. The typical build settings are as follows:
Build command:
gridsome build
Publish directory:
dist
#
Grunt
We automatically provide Grunt for you in the build environment in case your build command references it. We’ll run
npm install grunt-cli
for you before running your build command, in case your build command contains the string
grunt
. The typical build settings are as follows:
Build command:
grunt build
Publish directory:
dist
#
Hexo
The Hexo docs include instructions for
deploying Hexo to Netlify
. The typical build settings are as follows:
Build command:
hexo generate
Publish directory:
public
#
Hugo
Our docs provide an overview of
Hugo on Netlify
, while the Hugo docs include task-based instructions for
deploying Hugo to Netlify
. The typical build settings are as follows:
Build command:
hugo
Publish directory:
public
#
Hydrogen
Our docs provide an overview of how
Hydrogen works on Netlify
. The typical build settings are:
Build command:
remix vite:build
Publish directory:
dist/client
#
Jekyll
If your site is built with Jekyll, make sure you have a
Gemfile and a Gemfile.lock
checked into your repository, specifying the Jekyll version you want to use. The typical build settings are as follows:
Build command:
jekyll build
Publish directory:
_site
#
Middleman
If your site is built with Middleman, make sure you have a
Gemfile and a Gemfile.lock
checked into your repository, specifying the Middleman version you want to use. The typical build settings are as follows:
Build command:
middleman build
Publish directory:
build
#
MkDocs
If you’re using MkDocs, make sure to
include the dependency
in a
Pipfile
or
requirements.txt
file, specifying version 0.9.0 or above. You may also need to set your
Python version
. The typical build settings are as follows:
Build command:
mkdocs build
Publish directory:
site
#
Next.js
Netlify supports
all major Next.js features
—including App Router, SSR, ISR, middleware, image optimization, and more—with zero configuration.
Typical build settings (SSR or hybrid sites):
Build command:
next build
Publish directory:
.next
For static-only sites (using next export):
Build command:
next build && next export
Publish directory:
out
Env var:
NETLIFY_NEXT_PLUGIN_SKIP=true
Learn more about
Next.js on Netlify
.
#
Nuxt
You can get an overview in our
Nuxt on Netlify
doc or read the Nuxt docs for instructions on how to deploy
Nuxt 2
and
Nuxt 3
on Netlify. The typical build settings are as follows:
Nuxt 3
Build command:
nuxt build
Publish directory:
dist
Nuxt 2
Build command:
nuxt generate
Publish directory:
dist
#
React
Check out our docs for building on Netlify using these popular React-based frameworks:
Gatsby
,
Next.js
,
React Router
,
Remix
.
You can also get started with our docs about
Create React App on Netlify
.
#
React Router
Our docs provide all the information you need to deploy a
React Router application on Netlify
. The typical build settings are as follows.
Build command:
react-router build
Publish directory:
build/client
#
Remix
Our docs provide all the information you need to deploy a
Remix application on Netlify
. The typical build settings are as follows.
For projects built with Remix Vite:
Build command:
remix vite:build
Publish directory:
build/client
For projects built with the Remix Classic Compiler:
Build command:
remix build
Publish directory:
public
#
RedwoodJS
The fastest way to deploy a RedwoodJS project on Netlify is to run
yarn rw setup deploy netlify
in your terminal at your project’s root directory. This will create a
netlify.toml
file that contains all the configuration you need.
For more details, check out the RedwoodJS docs for
deploying to Netlify
.
#
SvelteKit and Svelte
Check out our docs overview for using
SvelteKit on Netlify
or learn more in the
SvelteKit Netlify adapter README
. Typical build settings are as follows.
For projects built with SvelteKit:
Build command:
vite build
Publish directory:
build
For projects built with Svelte:
Build command:
npm run build
,
pnpm build
, or
yarn build
Publish directory:
public
#
TanStack Start
Our docs share a TanStack Start app template and a special command for generating an app in your terminal. Learn more in our
TanStack Start docs
. Typical build settings are as follows:
Build command:
vinxi build
Publish directory:
dist
#
Vite
Check out our docs overview for using
Vite on Netlify
or learn more in the
Vite docs
. Typical build settings are as follows:
Build command:
vite build
Publish directory:
dist
#
Vue CLI
Our docs provide an overview for using the
Vue CLI with Netlify
, and you can also learn more in the
Vue CLI docs
. The typical build settings are as follows:
Build command:
vue-cli-service build
Publish directory:
dist
#
VuePress
The VuePress docs include instructions for
deploying VuePress to Netlify
. The typical build settings are as follows:
Build command:
npm run docs:build
or
yarn docs:build
Publish directory:
docs/.vuepress/dist
Last updated: April 16, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_angular.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/angular/
Scraped_At: 2025-06-02T19:57:41.741589

Contact
Forums
Contact support
Angular is a component-based open source framework for building enterprise-grade single-page applications (SPAs) with client-side routing, server-side rendering, and prerendering. Scully, an open source static site generator, is built specifically for Angular apps.
#
Key features
These features provide important benefits for Angular projects, including ones built and deployed with Netlify.
Robust integrated tooling.
Using declarative templates, you can extend Angular’s template language for more customization. You can also get immediate Angular-specific help and feedback with popular IDEs and editors.
Helpfully opinionated.
As a framework, Angular predetermines certain project decisions, but this reduces the number of choices a team has to make. Using features like the
ng generate
command and without relying on third-party libraries, your team can focus on building an app, not the setup.
Image optimization
. The
NgOptimizedImage
directive
, backed by
Netlify Image CDN
, makes it easier to adopt performance best practices for loading images.
Supported by Google.
Angular is Google’s largest application and has the reliability of being backed and maintained by the company. The team also adheres to Long-Term Support (LTS) and has a
public roadmap
.
Built with TypeScript.
When building out Angular applications, you can take advantage of type safety and tooling using TypeScript.
Strict mode
can help you avoid type errors before hitting production.
In addition to the Angular-specific items above, Netlify gives you control over
branch and deploy
settings. This allows you to set up continuous deployment according to your project needs, such as only deploying particular branches or creating Deploy Previews on
git push
.
#
Netlify integration
Angular applications on Netlify can benefit from integrations such as automatic framework detection and built-in redirects functionality.
#
Automatic framework detection
When you
link a repository
for a project, Netlify tries to detect the framework your site is using. If your site is built with Angular, Netlify provides a suggested build command:
ng build --prod
. Based on your
angular.json
, Netlify automatically configures the publish directory. If your site has server-side rendering enabled, this is automatically configured using an Edge Function.
If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
ng serve
and
4200
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up an Angular app on Netlify.
#
Netlify Image CDN
When deploying your Angular applications to Netlify,
NgOptimizedImage
automatically uses
Netlify Image CDN
to optimize and transform images on demand without impacting build times. Netlify Image CDN also handles content negotiation to use the most efficient image format for the requesting client.
To transform a source image hosted on another domain, you must first configure allowed domains in your
netlify.toml
file:
[
images
]
remote_images
=
[
"https://my-images.com/.*"
,
"https://animals.more-images.com/[bcr]at/.*"
]
The
remote_images
property accepts an array of regex. If your images are in specific subdomains or directories, you can use regex to allow just those subdomains or directories.
Visit the
Angular docs
to learn more.
#
Redirects
Although we recommend
prerendering your Angular app
or using Scully to produce static files, you may need to use
redirects
to enable Angular routing and page refresh functionality for pages with client-side rendering. You can use a
_redirects
file or a
Netlify configuration file
to configure these.
In
_redirects
:
/* /index.html 200
Make sure you include the
_redirects
file in your
angular.json
assets array so that Angular will include a copy of the file when building your project:
"assets": [
  "src/_redirects"
]
In
netlify.toml
:
[
[
redirects
]
]
from
=
"/*"
to
=
"/index.html"
status
=
200
Redirects on SSR
Pages utilizing
Server-Side Rendering (SSR)
are not subject to redirects placed in
_redirects
or
netlify.toml
.
This is because SSR uses Edge Functions, which run before redirects are evaluated.
Instead, use Angular's built-in redirects feature:
Setting up redirects
#
Accessing
Request
and
Context
during Server-Side Rendering (SSR)
During server-side rendering, you can access the incoming
Request
object and the Netlify-specific
Context
object via the
netlify.request
and
netlify.context
providers:
import
type
{
Context
}
from
"@netlify/edge-functions"
export
class
FooComponent
{
constructor
(
// ...
@
Inject
(
'netlify.request'
)
@
Optional
(
)
request
?
:
Request
,
@
Inject
(
'netlify.context'
)
@
Optional
(
)
context
?
:
Context
,
)
{
console
.
log
(
`
Rendering Foo for path
${
request
?.
url
}
from location
${
context
?.
geo
?.
city
}
`
)
// ...
}
}
The
Request
and
Context
objects will not be available on the client-side or during
prerendering
. To test this in local development, run your Angular project using
netlify serve
.
#
More resources
Video: Angular in the Jamstack
Netlify Blog: Angular posts
Netlify redirect rules for Angular apps
Angular documentation
Scully documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_astro.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/astro/
Scraped_At: 2025-06-02T19:57:42.363465

Explore an Astro site
Deploy to Netlify
Prefer to explore working examples first? Return to this guide to understand key features and for extra setup help.
Demo repo
Demo site
Edge Functions example
Image CDN example
Blobs example
Revalidation example
###End of file##

-------- frameworks_eleventy.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/eleventy/
Scraped_At: 2025-06-02T19:57:43.007897

Contact
Forums
Contact support
Eleventy (11ty) is a flexible and configurable open source static site generator. Although it’s written in JavaScript, it doesn’t depend on a specific framework for generating or serving content.
#
Key features
These features provide important benefits for Eleventy projects, including ones built and deployed with Netlify.
JavaScript-friendly.
Eleventy was developed as a JavaScript alternative to Jekyll. It’s not dependent on a client-side JavaScript framework or library, which means it doesn’t predetermine your frontend stack.
Flexible config.
By default, Eleventy requires no configuration, but it has flexible options for custom setup. It is intentionally decoupled from frameworks, build pipelines, and other tools in order to support your preferences.
Adaptable project structure.
Eleventy works with your project’s existing directory structure and generates HTML based on the templates, content, and data you provide.
Choice of templating.
By default, Eleventy uses the template language
Liquid
. However, it supports many
template languages
and allows them to be mixed and combined. This allows a project to migrate to or adopt Eleventy gradually over time.
#
Netlify integration
When you
link a repository
for a project, Netlify tries to detect the framework your site is using. If your site is built with Eleventy, Netlify provides a suggested build command and output directory:
eleventy
and
_site
. If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
eleventy --serve
and
8080
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up an Eleventy site on Netlify.
For manual configuration, check out the
typical build settings
for Eleventy.
#
Edge Functions
Edge Functions connect the Netlify platform and workflow with an open runtime standard at the network edge. This enables you to build fast, personalized web experiences with an ecosystem of development tools.
You can browse a
full library of reference examples
for different ways to use Edge Functions. For more details, check out the
Edge Functions documentation
.
Eleventy has
a dedicated plugin
to take advantage of Edge Functions on Netlify, allowing you to use dynamic template languages on the edge to dynamically render templates and modify build-time generated content. This unlocks
many new use cases
in a performance-focused way with zero client-side JavaScript: forms, cookies, user personalization, A/B testing, and more.
#
Requirement for Build Plugins
To use a Netlify build plugin with your Eleventy site, you must update your site’s
.gitignore
file. Without this change, installed Netlify build plugins and all current versions of Eleventy will both attempt to use
.netlify/plugins/node_modules/
, resulting in build errors. As a workaround, we recommend you change
node_modules
to
**/node_modules/**
in the
.gitignore
file.
#
More resources
Typical Eleventy build settings
Netlify Blog: Eleventy posts
Learn Jamstack video course
with corresponding
Eleventy example site
Eleventy documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_environment-variables.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/environment-variables/
Scraped_At: 2025-06-02T19:57:44.011403

Contact
Forums
Contact support
Projects on Netlify can use
environment variables
at two different stages: during the build process or once the site is built and running in the browser.
#
Use variables during the build
Our docs cover how to
create environment variables
and how to use environment variables
during the build process
.
Depending on the framework you use, there are specific
configuration variables
you may want to set to change an aspect of your build - such as the
HUGO_VERSION
or
NEXTAUTH_SECRET
. Visit the Netlify doc for your
framework
to find out more.
Note that if you have the option to set specific
scopes
for your environment variables, the scope must include
Builds
to be available during the build process.
#
Use variables after the build is complete
If you want to use environment variable values after the site is built, you have a few options:
Use a function
, including serverless functions and edge functions, to access values during runtime. This is the best option to avoid revealing sensitive values.
Embed variable values
in the site code during the build process.
Leverage snippet injection
to access values during post-processing.
#
Embed variable values in the site build
You can embed environment variables into your site while it’s building, for use within your site after the build is complete. You should not copy sensitive values into your build as these values are accessible to anyone inspecting your app files in the browser.
Along with your framework’s built-in environment variables, you may want to use custom variables or Netlify variables in your site.
#
Custom variables
To set custom variables in the Netlify UI or the
netlify.toml
and then use them within your site, most frameworks require the use of a framework-specific prefix in the name of each
variable you declare
.
Here are a few examples of frameworks and the prefix to use for each:
Create React App:
REACT_APP_
Gatsby:
GATSBY_
Next:
NEXT_PUBLIC_
Nuxt:
NUXT_ENV_
Vue CLI:
VUE_APP_
For example, here is a non-sensitive custom variable
GREETING
set in
netlify.toml
for the production context. To make it work with React, use the name
REACT_APP_GREETING
:
[
context.production.environment
]
REACT_APP_GREETING
=
"Hello"
You can then use the custom environment variable in your React site code in production:
<
section
>
<
p
>
This is my greeting
:
{
process
.
env
.
REACT_APP_GREETING
}
<
/
p
>
<
/
section
>
Check the docs for your framework to confirm if a prefix is necessary.
#
Setting variables for use with server-side rendering
If your project uses server-side rendering (SSR) or deferred static generation (DSG), Netlify automatically handles these pages using Netlify
Functions
or Netlify
Edge Functions
.
As the
netlify.toml
file is only read during the build process and not accessible by functions, you need to set custom variables in the Netlify
UI, CLI, or API
if you want your SSR or DSG pages to access them during runtime. If you have the option to set specific
scopes
for your custom environment variables, the scope must include both
Functions
and
Builds
to support both server-side and client-side rendering.
To access Netlify configuration or
read-only variables
in SSR or DSG pages, create variables with these values in the build command as outlined in the following section.
#
Netlify variables
To use Netlify’s build environment variables in your site, create variables in your project code (where applicable, these should be framework-prefixed variables) and assign the Netlify variables as their values.
The recommended way to do this is to create the variables in-line before your project’s build command. For example, to access Netlify’s
CONTEXT
variable in your Create React App site, update the build command in the
netlify.toml
to set
REACT_APP_CONTEXT=$CONTEXT
before running the build:
[
build
]
command
=
"REACT_APP_CONTEXT=$CONTEXT npm run build"
You can do the same update to the
build command
in the Netlify UI.
Note that it’s not possible to use Netlify variables as values in the environment variables sections of the Netlify UI or
netlify.toml
. Depending on your framework, however, it might be possible to use variables as values in
a
.env
file
.
As the framework builds your site, it retrieves the environment variable
CONTEXT
from the build environment and uses the variable’s value when it injects the framework-prefixed variable, such as
REACT_APP_CONTEXT
, into your site.
You can then access the variable in your JavaScript files using the format
process.env.VARIABLE_NAME
, such as
process.env.REACT_APP_CONTEXT
:
if
(
process
.
env
.
REACT_APP_CONTEXT
===
`
deploy-preview
`
)
{
console
.
log
(
`
This is a preview version of our site.
`
)
;
}
#
.env
files and Netlify variables
While Netlify may not read your
.env
files, depending on where you
build your project
, your framework may read the files during the framework’s build step.
If you would like to use Netlify environment variables as values in a
.env
file for your framework to access, such as
REACT_APP_CONTEXT=$CONTEXT
, your project needs to support variable expansion.
Framework support for variable expansion, the term for retrieving variables from the build environment for use as values in
.env
files, varies.
Some frameworks, such as
Create React App
and
Vue
, have built-in variable expansion support. Some frameworks support similar functionality in their unique configuration files, such as Nuxt with
nuxt.config.js
. Other frameworks will require the use of a separate library, such as
dotenv-expand
, to make this work.
We recommend searching your framework’s docs for “expand variables” or “variable expansion” to confirm what’s possible.
Last updated: March 12, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_express.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/express/
Scraped_At: 2025-06-02T19:57:44.701205

Contact
Forums
Contact support
Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.
#
Key features
These features provide important benefits for Express apps, including ones built and deployed with Netlify.
Routing
. Express provides a robust routing API that allows you to perform complex routing tasks. With this API, you can split code on a per-route basis and not be strictly limited by Netlify’s file-based routing for Functions.
Middleware
. Express provides a comprehensive set of HTTP utility methods and middleware that you can use to develop a robust API for your application.
#
Netlify integration
Express apps on Netlify work because of
Netlify Functions
.
When you deploy an Express app on Netlify as serverless functions, you get to leverage all of the benefits of running on-demand, server-side code without having to run a dedicated server.
#
Deploy an Express app on Netlify
This section demonstrates how to deploy an Express project on Netlify — either alongside a frontend app that uses another framework, or as a standalone Express app.
#
Use Express with a frontend app
Before you begin, make sure you have
Node.js
version 18.14.0 or later installed on your machine. Then, you can start a new project using Express.
Install the following dependencies. If your Express project uses JavaScript, you can exclude
@netlify/functions
and
@types/express
.
npm
i express serverless-http @netlify/functions @types/express
Create a Netlify Function file
for either TypeScript or JavaScript. For example, you might create a function file called
api.ts
.
In the newly created file, write the function that will import Express and create a router object to handle routing. Here is an example:
// YOUR_BASE_DIRECTORY/netlify/functions/api.ts
import
express
,
{
Router
}
from
"express"
;
import
serverless
from
"serverless-http"
;
const
api
=
express
(
)
;
const
router
=
Router
(
)
;
router
.
get
(
"/hello"
,
(
req
,
res
)
=>
res
.
send
(
"Hello World!"
)
)
;
api
.
use
(
"/api/"
,
router
)
;
export
const
handler
=
serverless
(
api
)
;
Add the following configuration in your
netlify.toml
:
[
functions
]
external_node_modules
=
[
"express"
]
node_bundler
=
"esbuild"
[
[
redirects
]
]
force
=
true
from
=
"/api/*"
status
=
200
to
=
"/.netlify/functions/api/:splat"
In the
redirects
section is a rewrite that enables Express to parse the URLs configured in your function file. In this example, Express can now successfully parse
/api
, which we configured above with
api.use('/api/', router);
.
If you don’t wish to add the rewrite, you might have to change the configuration in your function to specify the functions path, such as
api.use('/.netlify/functions/', router);
.
You can now use these routes in your frontend code. In the above example, you can access the
/hello
route at
/api/hello
and any other route that you might add at
/api/<slug>
.
Follow the steps below to
deploy your Express app
.
#
Use Express without a frontend
It’s possible to deploy Express apps on Netlify without a frontend. If you do this, you can access the routes from other frontend apps deployed separately, just as you would with any other API endpoints. In this case, you might have to configure CORS to allow access to the routes from other domains.
To deploy an Express app without a frontend:
Follow the steps
documented above
to install Express, create a Netlify Function with your routing code, and create a
netlify.toml
file to register the function and redirects required.
In the
netlify.toml
or the Netlify UI, set a placeholder
build command
to ensure Netlify builds your functions. For example, the command could be
echo Building Functions
.
Follow the steps below to
deploy your Express app
.
#
Deploy your Express app with Netlify CLI
Whether you use Express with a frontend or not, the steps to deploy are the same.
You can
deploy your project from the command line
using
Netlify CLI
.
To ensure you have the latest version of Netlify CLI installed, run this command from any directory in your terminal:
npm
install
netlify-cli
-g
In the directory for your project, run the following command to create a new Netlify site:
netlify init
Didn’t initialize a Git repository?
When you run
netlify init
without initializing a Git repository first, the CLI prompts you to connect your local directory to GitHub. Follow the steps in your terminal to link your local directory with a remote repo in order to use continuous deployment for your site.
Follow the prompts to create your site, select a team if necessary, and optionally create a site name. If you already initialized a Git repository, you can authorize your Git provider and set your build command and directory.
If you used continuous deployment, your site is now published! To learn how to manually deploy a site, check out the
manual deploy docs
.
#
Limitations
Since Express apps are deployed as Netlify Functions, all of the
function limitations
apply. This includes execution and memory limits.
It is not recommended to deploy Express apps as background or scheduled functions.
#
More resources
Netlify Functions
Express documentation
Last updated: July 19, 2024
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_gatsby.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/gatsby/?gatsby-version=adapters
Scraped_At: 2025-06-02T19:57:46.038706

Contact
Forums
Contact support
Gatsby is a React-based, open source static site generator that pulls in data using a GraphQL API layer that can connect to a wide array of content sources.
#
Key features
These Gatsby features provide key benefits for sites and apps, including ones built and deployed with Netlify.
Content aggregation.
Gatsby provides a diverse ecosystem of data plugins that allow developers to use a centralized GraphQL API to pull in content from files, APIs, and SaaS platforms. This makes development feel familiar, even if content sources are completely different.
Performance optimizations.
By default, Gatsby optimizes JavaScript bundles, adds preloading and browser optimizations, and includes other performance enhancements. In general, Gatsby sites are performant and fast.
Image optimization.
Gatsby ships an image component that works with the GraphQL data layer to generate highly optimized images. The images are lazy-loaded and configured for different viewport sizes. This cuts down on page load times and bandwidth usage. You can also use
Netlify Image CDN with Gatsby
for deferred image resizing instead of processing images at build time.
Serverless functions.
Gatsby includes an integrated
Functions
feature to help create an API for a site or application.
Server-side rendering (SSR) and deferred static generation (DSG).
You can choose between several rendering modes, including SSR and DSG. This means you can pick the rendering mode that makes sense for your site.
#
Netlify integration
Choose your Gatsby version:
5.12.0 or later
Earlier than 5.12.0
5.12.0 or later
Earlier than 5.12.0
When you trigger a build on Netlify for a site that uses Gatsby version 5.12.0 or later, Gatsby detects that you are using Netlify and automatically installs
gatsby-adapter-netlify
. This is a Gatsby adapter that enables
zero-configuration deployments
, making it easier to build and deploy your Gatsby sites. The same automatic detection and installation occurs when you trigger a build using the Netlify CLI.
You can also choose to
install the adapter yourself
.
Note that if your site already uses the
Gatsby adapter for Netlify
, you don’t have to use the
Essential Gatsby build plugin
.
Gatsby 5 requires updated Node.js version
Gatsby 5
requires Node.js 18. If your build is using another Node.js version,
follow our Node.js docs
to manually set the Node.js version to 18.
#
Gatsby adapter for Netlify
The official Gatsby adapter for Netlify,
gatsby-adapter-netlify
, enables
zero-configuration deployments
for your site. When you trigger a build on Netlify for a site that uses Gatsby version 5.12.0 or later, Gatsby automatically installs the adapter. The adapter prepares your site for deployment on Netlify in a number of ways, including:
Applying HTTP headers to assets
Applying redirects and rewrites
Applying trailing slash behavior to URLs
Setting up user-defined API functions to be used on Netlify
Setting up Deferred Static Generation (DSG) and Server-Side Rendering (SSR)
Storing Gatsby cache after build is complete and restoring it on subsequent builds to decrease build time between builds
For more information on adapters, including information on how to create your own, visit
Gatsby’s documentation on adapters
.
#
Install the Gatsby adapter for Netlify
Gatsby will automatically install
gatsby-adapter-netlify
for new Gatsby sites on Netlify. If you want to install the adapter manually, you can use the use the following command:
npm
install
gatsby-adapter-netlify
If you want to further configure the adapter, you can add
gatsby-adapter-netlify
to your
gatsby-config.js
file and configure the
adapter
option. For example:
const
adapter
=
require
(
"gatsby-adapter-netlify"
)
;
module
.
exports
=
{
adapter
:
adapter
(
{
excludeDatastoreFromEngineFunction
:
false
}
)
}
;
For more information, visit the
gatsby-adapter-netlify
docs
.
#
Limitations
StaticImage
and
gatsby-transformer-sharp
don’t work properly for SSR or DSG pages. Instead, you can host your images on a CDN such as
Cloudinary
or
imgix
.
#
Auto-generated Netlify Functions
To support Gatsby Functions and SSR/DSG render modes, the Gatsby adapter automatically generates Netlify Functions called
SSR
and
DSG
. If your site doesn’t have Gatsby Functions or SSR/DSG pages, then the Netlify Functions won’t be generated.
#
Optional loading of the Gatsby datastore from the CDN
By default, Netlify includes the Gatsby datastore in the Netlify Function bundle, which is a deployment package that’s zipped for direct upload to AWS. If you have a larger site, the site’s datastore may exceed the
maximum function deploy size
, preventing you from successfully deploying your website.
GATSBY_EXCLUDE_DATASTORE_FROM_BUNDLE
is an environment variable that loads the Gatsby datastore from the CDN rather than bundling it with the function, bypassing the size limitation.
Note that enabling loading the datastore from the CDN results in different page load behavior. On the first load of  functions that handle SSR and DSG pages, the datastore is downloaded, which can result in a slower initial page load.
During the build process, pre-warm requests are sent to the SSR and DSG function endpoints to reduce the user-facing impact of the datastore download.
#
Local development
When developing Gatsby Functions, you can use the built-in
gatsby develop
functions server. However, if you want to run the Netlify Functions that are generated during the build step, you can use
netlify dev
. Make sure to run
netlify build
first to generate the Netlify Functions from your Gatsby Functions.
#
Suggested configuration values
When you link a repository for a Gatsby project, Netlify provides a suggested build command and publish directory:
gatsby build
and
public
.
If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify suggests a dev command and port:
gatsby develop
and
8000
.
You can override suggested values or set them in a configuration file instead, but suggested values from automatic framework detection may help simplify the process of setting up a Gatsby site on Netlify.
For manual configuration, check out the
typical build settings
for Gatsby.
#
Environment variables
Environment variables prefixed with
GATSBY_
are processed by Gatsby and made available in the browser for client-side JavaScript access. For more information on how to use environment variables in Gatsby, including with SSR or DSG pages, check out the
Environment variables and frameworks doc
.
#
Netlify Image CDN
Not supported for Gatsby 5.12
If your site uses Gatsby version 5.12.x with a Gatsby adapter, deferred image resizing with a CDN is not supported. Upgrade to Gatsby 5.13.0 or later to use this feature.
Gatsby supports deferred image resizing with
Netlify Image CDN
.
To enable the image CDN, you need to do the following:
Set the environment variable
NETLIFY_IMAGE_CDN
to
true
Use the Contentful, Drupal, or WordPress source plugins
For more information, including how to allow remote images, visit the
Gatsby adapter for Netlify README
.
When you
link a repository
for a project, Netlify detects the framework your site is using. If you are using Gatsby version 5.11.0 or earlier, Netlify will automatically install the
Essential Gatsby build plugin
and provides
suggested configuration values
. For existing sites already linked to Netlify, you can choose to
install
the plugin yourself.
Gatsby 5 requires updated Node.js version
Gatsby 5
requires Node.js 18. If your build is using another Node.js version,
follow our Node.js docs
to manually set the Node.js version to 18.
#
Essential Gatsby build plugin
The
Essential Gatsby
build plugin enables key functionality on sites that use Gatsby versions earlier than 5.12.0. It speeds up Netlify builds by preserving a site’s
public
and
.cache
directories between builds. The plugin supports
Gatsby Functions
and SSR and DSG rendering. If you don’t need those, you can
remove the plugin
from your site.
Gatsby sites on Netlify need two plugins to support all features:
The Essential Gatsby build plugin
(
@netlify/plugin-gatsby
).
This plugin installs automatically for all Gatsby sites deployed on Netlify.
The Gatsby plugin for Netlify
(
gatsby-plugin-netlify
).
This needs to be installed manually and is required for SSR rendering, Gatsby redirects, and asset caching rules.
#
Install the Essential Gatsby build plugin
New Gatsby sites on Netlify automatically install the Essential Gatsby build plugin. You can confirm this in the build logs. If you want to install it manually, you can use
file-based plugin installation
and add the plugin as
@netlify/plugin-gatsby
in your
netlify.toml
file.
[
[
plugins
]
]
package
=
"@netlify/plugin-gatsby"
#
Install the Gatsby plugin for Netlify
To enable SSR rendering, Gatsby redirects, and asset caching rules, you must also install the Gatsby plugin
gatsby-plugin-netlify
.
To install the Gatsby plugin for Netlify, follow the Gatsby plugin process:
Add the package as a dependency.
npm
install
-D
gatsby-plugin-netlify
Add
gatsby-plugin-netlify
to your
gatsby-config.js
file’s plugins array.
module
.
exports
=
{
plugins
:
[
"gatsby-plugin-netlify"
]
}
;
For more information, including optional plugin configuration, check out the
gatsby-plugin-netlify
docs
.
#
Limitations
StaticImage
and
gatsby-transformer-sharp
don’t work properly for SSR or DSG pages. Instead, you can host your images on a CDN such as
Cloudinary
or
imgix
.
#
Auto-generated Netlify Functions
To support Gatsby Functions and SSR/DSG render modes, the Essential Gatsby build plugin automatically generates Netlify Functions called
__api
,
__ssr
,
__dsg
, and
__ipx
. If your site doesn’t have Gatsby Functions or SSR/DSG pages, then the Netlify Functions won’t be generated.
You can use one or more of the following build environment variables to directly control generation of these functions.
NETLIFY_SKIP_GATSBY_FUNCTIONS
:
skips generation of all functions (
__api
,
__ssr
,
__dsg
, and
__ipx
). Takes precedence over the following function skip environment variables.
NETLIFY_SKIP_API_FUNCTION
:
skips generation of the
__api
function.
NETLIFY_SKIP_SSR_FUNCTION
:
skips generation of the
__ssr
function.
NETLIFY_SKIP_DSG_FUNCTION
:
skips generation of the
__dsg
function.
#
Optional loading of the Gatsby datastore from the CDN
By default, Netlify includes the Gatsby datastore in the Netlify Function bundle, which is a deployment package that’s zipped for direct upload to AWS. If you have a larger site, the site’s datastore may exceed the
maximum function deploy size
, preventing you from successfully deploying your website.
GATSBY_EXCLUDE_DATASTORE_FROM_BUNDLE
is an environment variable that loads the Gatsby datastore from the CDN rather than bundling it with the function, bypassing the size limitation.
Note that enabling loading the datastore from the CDN results in different page load behavior. On the first load of  functions that handle SSR and DSG pages, the datastore is downloaded, which can result in a slower initial page load.
During the build process, pre-warm requests are sent to the SSR and DSG function endpoints to reduce the user-facing impact of the datastore download.
#
Local development
When developing Gatsby Functions, you can use the built-in
gatsby develop
functions server. However, if you want to run the Netlify Functions that are generated during the build step, you can use
netlify dev
. Make sure to run
netlify build
first to generate the Netlify Functions from your Gatsby Functions.
#
Suggested configuration values
When you link a repository for a Gatsby project, Netlify provides a suggested build command and publish directory:
gatsby build
and
public
.
If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify suggests a dev command and port:
gatsby develop
and
8000
.
You can override suggested values or set them in a configuration file instead, but suggested values from automatic framework detection may help simplify the process of setting up a Gatsby site on Netlify.
For manual configuration, check out the
typical build settings
for Gatsby.
#
Environment variables
Environment variables prefixed with
GATSBY_
are processed by Gatsby and made available in the browser for client-side JavaScript access. For more information on how to use environment variables in Gatsby, including with SSR or DSG pages, check out the
Environment variables and frameworks doc
.
#
Netlify Image CDN
Gatsby supports deferred image resizing with
Netlify Image CDN
.
To enable the image CDN, you need to do the following:
Set the environment variable
NETLIFY_IMAGE_CDN
to
true
Use the Contentful, Drupal, or WordPress source plugins
For more information, including how to allow remote images, visit the
Essential Gatsby build plugin’s documentation
.
#
More resources
Typical Gatsby build settings
Gatsby Adapters: Realize the Full Potential of Gatsby on Your Platform
Essential Gatsby build plugin documentation
Five Optimizations for Faster Gatsby Builds
Gatsby 101: Features, Benefits, and Trade-Offs
Improve Gatsby Build Speeds With Parallel Image Processing
Netlify Blog: Gatsby posts
Deploying to Netlify
Gatsby documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_hugo.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/hugo/
Scraped_At: 2025-06-02T19:57:46.811445

Contact
Forums
Contact support
Hugo is a fast and flexible open source static site generator written in Go.
#
Key features
These features provide important benefits for Hugo sites, including ones built and deployed with Netlify.
Build speed.
Hugo boasts near-instant build times of less than one millisecond per page. For large sites with a lot of pages, this can translate into significant time savings during site development and Netlify build and deploy processes.
Choice of themes.
The Hugo ecosystem includes a wide range of premade
themes
for styling static content.
Robust templating.
Hugo uses Go templates with
html/template
and
text/template
libraries to control templating.
Instant previews.
The
LiveReload
tool is integrated into Hugo for a hot reloading experience during development.
URL management.
Hugo has built-in support for
URL manipulations
and
redirects
.
Functions and variables.
When building out templates, you can use Go functions, built-in
Hugo-specific functions
, and a variety of
variables
.
#
Netlify integration
Hugo sites on Netlify can benefit from automatic framework detection and control over Hugo version selection. They also require theme setup considerations.
#
Automatic framework detection
When you
link a repository
for a project, Netlify tries to detect the framework your site is using. If your site is built with Hugo, Netlify provides a suggested build command and publish directory:
hugo
and
public
. If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
hugo server -w
and
1313
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up a site on Netlify.
For manual configuration, check out the
typical build settings
for Hugo.
#
Hugo version
In order to install Hugo on the
build image
, you will need to set a
HUGO_VERSION
environment variable. You can set the variable to the version string for any released version after 0.19, for example,
0.80.0
.
First, confirm your local Hugo version with
hugo version
.
Then add an
environment variable
in the Netlify UI as you set up your site or in a
Netlify configuration file
stored in your repository.
Follow the steps to
import from an existing repository
and on the
Configure site and deploy
step, select
Add environment variables
. Select
New variable
and then enter the key and value.
Alternatively, add the following to
netlify.toml
in your site’s
base directory
, where
YOUR_HUGO_VERSION
is a version string such as
0.80.0
.
[
build
]
command
=
"hugo"
publish
=
"public"
[
build.environment
]
HUGO_VERSION
=
"YOUR_HUGO_VERSION"
Failed build?
If you get an error with
exit code: 255
when building a Hugo site on Netlify, remember to set
HUGO_VERSION
to the version you are using locally.
#
Hugo themes
Hugo themes work by default on Netlify. Like any continuous integration system, however, Netlify can’t use a theme installed by the
git clone
method. Instead, you should install a Hugo theme for your site as a
git submodule
.
Here’s an example:
cd
YOUR_PROJECT_DIRECTORY
git
init
git
submodule
add
https://github.com/THEME_CREATOR/THEME_NAME
#
More resources
Typical Hugo build settings
Host Hugo on Netlify
Hugo documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_hydrogen.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/hydrogen/
Scraped_At: 2025-06-02T19:57:47.770899

Explore a Hydrogen site
Deploy to Netlify
Get started with a new Hydrogen site on your Netlify account or view the demo.
Demo repo
Demo site
###End of file##

-------- frameworks_next-js_overview.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/overview/
Scraped_At: 2025-06-02T19:57:49.050403

Contact
Forums
Contact support
Netlify supports all major Next.js features with zero configuration.
Under the hood, this is powered by our OpenNext adapter, which we maintain in the open and test alongside every stable release of Next.js.
For earlier Next.js versions
The information on this page is applies to Next.js version 13.5 and above. For earlier Next.js versions, visit the
legacy runtime
page.
#
Get started
If you have an existing Next.js app you’d like to deploy, push your code to a Git provider and connect it through the Netlify Dashboard.
When starting from scratch, the fastest way is to deploy our
Next.js platform starter template
to your Netlify account.
#
Key features
App Router:
Netlify fully supports the Next.js App Router, which supports more powerful nested layouts and React’s latest features, such as Server Components and Streaming.
Automatic fine-grained caching:
the adapter uses our
fine-grained caching primitives
to support the Next.js Full Route Cache and Data Cache. This means that static page responses are automatically cached at the edge and can be revalidated by path or by tag.
On-demand and time-based revalidation:
both the App Router and Pages Router support on-demand and time-based revalidation, allowing you to revalidate and regenerate content at any time after a deploy.
Image optimization:
the
next/image
component uses
Netlify Image CDN
by default, to ensure your images are optimized and served in the most efficient format.
#
Next.js support on Netlify
The following tables show you a comprehensive mapping of critical Next.js features and how Netlify supports them. Netlify supports new Next.js features as early as possible, but experimental features may not be fully stable yet.
Next.js Feature
Support
Notes
App Router
✓
Full Support
Server-Side Rendering (SSR)
✓
Full Support
Incremental Static Regeneration (ISR)
✓
Full Support
Static Site Generation (SSG)
✓
Full Support.
Pre-rendered pages are stored in Next.js route cache, and fetched from the route cache by a function invocation when first accessed after a deploy.
React Server Components
✓
Full Support
Server Actions
✓
Full Support
Response Streaming
✓
Full Support
asynchronous work with
next/after
✓
Full Support.
Learn more in the
API reference.
Middleware
✓
Full support.
Implemented automatically via
Edge Functions
. Learn about
limitations.
Route Handlers
✓
Full Support
Image Optimization
✓
Full Support
Redirects and rewrites
✓
Full Support
Internationalization
✓
Full Support
Draft Mode
✓
Full Support
Experimental framework features
Partial Support
Partial Prerendering (PPR): supported.
Use cache: supported.
Node.js in Middleware: not supported yet.
#
How Netlify runs your Next.js app
Netlify automatically configures your site to support modern Next.js features out of the box. This is powered by our OpenNext adapter, an open source project that provisions the correct infrastructure for each part of your Next.js application without custom configuration.
We recommend that you don’t pin the adapter version. We actively maintain the adapter to support all Next.js versions starting from version 13.5 and, if you don’t pin the version, we will automatically update the adapter to the latest version on each site build for you.
#
What the adapter does
When you deploy a Next.js project on Netlify, the adapter automatically:
Provisions Netlify Functions for:
Server-Side Rendering (SSR)
Incremental Static Regeneration (ISR)
Partial Prerendering (PPR)
API routes
Server Actions
Provisions Netlify Edge Functions for:
Next.js Middleware
Geolocation- and routing-based personalization
Fast execution at the network edge
Configures caching and revalidation with:
Next.js Full Route Cache and Data Cache
Tag-based or path-based revalidation
Enables image optimization with the Netlify Image CDN and
next/image
#
Compatibility and testing
We verify compatibility with every new stable version of Next.js. Each release of the adapter is tested using:
•	Our official end-to-end test suite
•	Additional integration tests with Netlify’s platform
•	Real-world deploys using a public starter template
#
Reverting to an older adapter version
Not recommended
We recommend that you don’t pin the adapter version. We actively maintain the adapter to support all Next.js versions starting from version 13.5 and, if you don’t pin the version, we will automatically use the latest version on each site build for you.
To pin a specific version of the adapter:
Install the version you want in
package.json
:
npm
install
@netlify/plugin-nextjs@
<
version
>
Add the plugin to your
netlify.toml
:
[
[
plugins
]
]
package
=
"@netlify/plugin-nextjs"
You'll be opting out of automatic updates and newer architecture improvements maintained through OpenNext. To opt back in, remove
@netlify/plugin-nextjs
from your
package.json
.
#
Limitations
Open issues are documented in the
end-to-end test report page
.
Edge Runtime Location:
SSR pages using the edge runtime run in your functions region rather than true edge locations
Rewrite Limitations:
Rewrites in Next.js configuration can’t point to static files in the public directory.
Middleware Execution Order:
Headers and redirects are evaluated after middleware, differing from stand-alone Next.js behavior.
Forms Integration:
Netlify Forms requires a specific workaround when used with Next.js applications.
Learn more.
#
More resources
OpenNext adapter docs
Next.js framework documentation
Netlify Connect JavaScript client
Posts about Next.js in our blog
Last updated: May 8, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_adapter-upgrade.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/adapter-upgrade/
Scraped_At: 2025-06-02T19:57:49.688576

Contact
Forums
Contact support
Netlify’s current adapter for Next.js is built as part of the
OpenNext initiative
and supports all Next.js versions starting from v13.5 and above. The adapter is automatically applied at build time unless you have explicitly pinned a version in your configuration. We strongly recommend using the latest adapter version to benefit from ongoing improvements and fixes.
#
When to upgrade
The latest adapter version is automatically applied during your build unless you've explicitly pinned an older version. You should consider upgrading when:
You are moving to a newer version of Next.js (v13.5+)
You want access to new features (App Router, Server Actions, etc.)
You are resolving known issues addressed in newer versions
#
Upgrade to the latest adapter
Before upgrading, consider the following:
Netlify forms:
If your site uses Netlify Forms, changes may be required. See the
Forms compatibility guide
.
Advanced API routes:
Sites using background or scheduled functions via Next.js API routes must convert these to regular Netlify Functions. See examples in the
docs
.
To upgrade to the latest adapter:
Update Next.js and Node versions:
Next.js: v13.5 or later
Node.js: v18 or later
Remove legacy plugin references (if any) in your
package.json
file by finding
@netlify/plugin-nextjs
:
{
"devDependencies"
:
{
"@netlify/plugin-nextjs"
:
"remove this"
}
}
Remove any plugin configuration for @netlify/plugin-nextjs in your
netlify.toml
:
[
[
plugins
]
]
package
=
"@netlify/plugin-nextjs"
To finalize the updates, trigger a new deploy. The latest version of the adapter will be applied automatically. You can confirm this in the build logs.
#
Reverting to an older adapter version
To pin a specific version of the adapter:
Install the version you want in
package.json
:
npm install @netlify/plugin-nextjs@<version>
Add the plugin to your
netlify.toml
:
[
[
plugins
]
]
package
=
"@netlify/plugin-nextjs"
Note this approach reverts your site to the legacy plugin system. You'll be opting out of automatic updates and newer architecture improvements maintained through OpenNext.
Last updated: May 6, 2025
←
Legacy Next.js on Netlify
Next.js redirects and rewrites
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_advanced-api-routes.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/advanced-api-routes/
Scraped_At: 2025-06-02T19:57:50.571811

Contact
Forums
Contact support
Legacy Next.js Runtime
The information on this page applies to Next.js version 10-13.4 and Netlify Next.js Runtime v4, which is currently in maintenance support.
Visit our Next.js adapter docs
for info on newer versions of Next.js.
Next.js sites on Netlify can take advantage of advanced API route capabilities in addition to support for basic and dynamic
API routes
. These enhancements include running a process in the background for a long-running task and scheduling a process to run at a regular interval. They are available for Next.js 12.2 and later.
#
Background API routes
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
With background API routes, you can invoke an API route and instead of instantly returning the data, the function can return a
HTTP 202 Accepted
response, allowing it to process the request in the background for up to 15 minutes. You can read more about this functionality in the
Netlify Background Functions
documentation.
The background function can be called on the following endpoint for Next.js sites:
/api/function-name
.
To enable a background API route in your Next.js project, add a TypeScript or JavaScript file inside the folder
pages/api
and export the following
config
object:
export
default
async
(
req
,
res
)
=>
{
// Do something slow
}
;
export
const
config
=
{
type
:
"experimental-background"
,
}
;
Check out a more extensive
background API route code example
for details.
#
Scheduled API routes
This feature is in
Beta
.
Scheduled API routes are triggered on a schedule rather than in response to an HTTP request. This functionality is powered by
Netlify Scheduled Functions
.
To enable a scheduled API route in your Next.js project, add a TypeScript or JavaScript file inside the folder
pages/api
and export the following
config
object:
export
default
(
req
,
res
)
=>
{
// Do something scheduled
}
;
export
const
config
=
{
type
:
"experimental-scheduled"
,
schedule
:
"@hourly"
,
}
;
Scheduled functions use the
“cron expression” format used by tools like crontab
and are executed according to the UTC timezone.
For example, the cron expression
0 0 * * *
will run a scheduled function every day at midnight UTC. We also support the
extensions
in the RFC, except for the
@reboot
and
@annually
specifications.
With extensions, the expression
0 0 * * *
can be written as
@daily
.
#
Test locally
Follow these steps to test a background API route or scheduled API route during development. A scheduled API route will only run on a schedule once deployed to production.
Run your Next.js project locally in development mode with
next dev
.
Trigger the route by invoking the URL path.
Testing with Netlify Dev isn’t supported
Netlify Dev
doesn’t currently support serving background and schedule API routes for local testing. Instead, we recommend that you test with
next dev
.
Last updated: October 23, 2024
←
Legacy Next.js on Netlify
Troubleshooting Next.js
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_middleware.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/middleware/
Scraped_At: 2025-06-02T19:57:51.322343

Contact
Forums
Contact support
Legacy Next.js Runtime
The information on this page applies to Next.js version 10-13.4 and Netlify Next.js Runtime v4, which is currently in maintenance support.
Visit our Next.js adapter docs
for info on newer versions of Next.js.
Netlify has expanded on Next.js Middleware to give you more options during development. With
@netlify/next
, you get access to enhanced request and response features through an intuitive API.
Netlify’s Next.js Advanced Middleware, available in the
@netlify/next
library
, gives improved access to requests and responses. This is similar to Netlify Edge Functions, but with some additional Next.js-specific helpers.
@netlify/next
is separate from
Next.js Runtime
and you need to
install it
in your project to use it.
#
Next.js Middleware
Next.js 12 introduced Middleware and enabled changing headers, rewriting the request path, or returning a different response entirely. Netlify fully supports Next.js Middleware and runs it either in an Edge Function or at the origin. Edge Functions are highly recommended for Next.js 12.2 or later, as ISR will not work with earlier versions.
#
Deploy Next.js Middleware on Netlify
Next.js Middleware works out of the box with Netlify, and most functions will work unchanged. Visit
the Middleware docs
for details of how to create Middleware functions.
#
Netlify Edge Functions and Middleware
By default, Next.js Middleware on Netlify uses
Edge Functions
to connect the Netlify platform and workflow with an open runtime standard at the network edge. If you don’t want to use Edge Functions for your Middleware, you can
opt out
.
Note that the
@netlify/next
library that enables Next.js Advanced Middleware on Netlify requires Edge Functions and is subject to the
limitations
of Edge Functions.
#
Opt out of Netlify Edge Functions
If you opt out of using Netlify Edge Functions for Middleware, regular serverless functions will handle your requests and responses.
Opting out of Edge Functions exposes you to the limitations of regular serverless functions:
You can’t use Netlify’s Next.js Advanced Middleware library
@netlify/next
.
Regular Netlify Functions don’t have access to
request.geo
.
When the Middleware runs at the origin, it is run
after
Netlify rewrites and redirects
. If a static file is served by the Netlify CDN, then the Middleware is never run, as Middleware only runs when a page is served by Next.js. This means that any pages that match Middleware routes are served from the origin rather than the CDN.
To opt out,
create an environment variable
named
NEXT_DISABLE_NETLIFY_EDGE
and set it to
true
. If you have the option to set specific
scopes
for your environment variables, the scope must include
Builds
to be available during the build process.
#
Next.js Advanced Middleware with the
@netlify/next
library
Regular Next.js Middleware doesn’t provide access to the actual response. Instead, it allows you to return a
NextResponse
object, which is used by the handler to modify the response headers when they are eventually returned.
Calling
NextResponse.next()
doesn’t actually send a request to the origin. It’s a placeholder for setting response headers that are applied later. It also doesn’t let you modify the request, but instead can return a
rewrite()
. The wrapper uses the returned
rewrite()
to modify the request.
To provide improved access to requests and responses, Netlify created a
library called
@netlify/next
. This library works with requests and responses in much the same way that
Netlify Edge Functions
do, but with some additional Next.js-specific helpers.
@netlify/next
requires Edge Functions
@netlify/next
requires Netlify’s
Edge Functions
and is subject to the
limitations
of Edge Functions. If you
opt out of Edge Functions
, then you can’t use
@netlify/next
.
Improved access to requests and responses enables excellent features, and
@netlify/next
has several ready to go:
HTML rewrites
Page data transforms
Request headers
Access to response body
#
HTML rewrites
This feature enables rewriting the HTML of Next.js pages. It includes a simple
replaceText
function but also support for more powerful transforms using the
HTMLRewriter
stream transformer. This enables personalization of pages at the edge, with no need for SSR. It works with ISR and static pages too.
#
Page data transforms
Next.js passes
getStaticProps
and
getServerSideProps
data to a page component and transfers it either as a JSON data file (for internal navigation with
next/link
) or embedded in the page’s  HTML in a script tag for server-rendered pages.
This feature allows users to modify those props on the fly, in a similar way to the HTML rewrites. This means you can be sure that the hydrated page matches the SSR HTML, avoiding hydration errors. It works with both the data in HTML pages and JSON data requests.
#
Request headers
Next.js Middleware allows response headers to be modified. This extends that ability to request headers that are sent to the origin. This is particularly helpful for rewrites to external sites. For example, it allows authentication headers to be added to proxied requests, allowing you to proxy a single page from a password-protected site without sharing credentials with the user.
#
Access to response body
The other features make it easier to modify responses. But if you need more powerful changes, you can also get full read and write access to the response body as a stream.
#
Install
@netlify/next
@netlify/next
is not part of the default Next.js Runtime, so you need to install this library in your project. To do so, enter the following in a terminal at the root of your project.
npm
install
@netlify/next
#
@netlify/next
API
You can use
@netlify/next
in your Next.js projects through its API, which includes the
MiddlewareRequest
and
MiddlewareResponse
endpoints.
#
MiddlewareRequest
object
The
MiddlewareRequest
object is a more powerful version of the standard
NextRequest
object. You create it by passing
NextRequest
to the constructor:
import
{
MiddlewareRequest
,
type
NextRequest
}
from
'@netlify/next'
;
export
async
function
middleware
(
nextRequest
:
NextRequest
)
{
const
request
=
new
MiddlewareRequest
(
nextRequest
)
;
// ...
}
You can then make changes to the request, such as adding or modifying headers. Or, you can use it to get a
MiddlewareResponse
object that you can then process.
MiddlewareRequest
has several useful methods you can use to handle your requests.
#
next()
method
Passes the request on to the origin and returns the response.
#
rewrite()
method
Rewrites the request URL and passes it on to the origin. Can be either an internal or external URL.
#
headers
object
A normal request
headers
object, except it is mutable and any changes are used when the request is sent to the origin.
#
MiddlewareResponse
object
This object is returned by
middlewareRequest.next()
or
middlewareRequest.rewrite()
and gives access to the full response. This may either be a static HTML file or SSR HTML.
The following object and methods in this section can help you transform the response. You can change the response headers similarly to a regular
NextResponse
. However, you can also
read
the response headers coming from the origin.
#
originResponse
object
The
Response
object
returned from the origin. You should not normally need to access this directly, but should instead use the helper methods below.
#
setPageProp()
method
Sets the value of a single page prop.
#
Syntax
setPageProp
(
key
:
string
,
value
:
any
)
;
#
Parameters
key: string
value: any
. While this parameter’s type is
any
, you should follow the
guidance for
props
in the Next.js documentation.
#
Example
const
request
=
new
MiddlewareRequest
(
req
)
;
const
response
=
await
request
.
next
(
)
;
const
message
=
`
This was static but has been transformed in
${
request
.
geo
.
city
}
`
;
response
.
setPageProp
(
"message"
,
message
)
;
#
replaceText()
method
Replaces the text content of an element. It can either take a string or a function that is passed the current value and returns the new value. This should be text that was generated from props, and you should use
setPageProp
to change the prop as well.
#
Syntax
replaceText
(
selector
:
string
,
valueOrReplacer
:
string
|
(
(
input
:
string
)
=>
string
)
)
;
#
Parameters
selector: string
valueOrReplacer: string | ((input: string) => string))
#
Example
const
request
=
new
MiddlewareRequest
(
req
)
;
const
response
=
await
request
.
next
(
)
;
const
message
=
`
This was static but has been transformed in
${
request
.
geo
.
city
}
`
;
response
.
replaceText
(
"#message"
,
message
)
;
#
transformData()
method
Modifies the returned page data. This is like
setPageProp
except you can change the whole page data object.
#
Syntax
transformData
(
transform
:
(
props
:
any
)
=>
any
)
;
#
Parameters
transform: (props: any) => any
#
Example
const
request
=
new
MiddlewareRequest
(
req
)
;
const
response
=
await
request
.
next
(
)
;
const
message
=
`
This was static but has been transformed in
${
request
.
geo
?.
city
}
`
;
// Transform the response page data
response
.
transformData
(
(
data
)
=>
{
data
.
pageProps
.
message
=
message
;
data
.
pageProps
.
showAd
=
true
;
return
data
;
}
)
#
rewriteHTML()
method
Allows the returned HTML to be written using
HTMLRewriter
.
#
Syntax
rewriteHTML
(
selector
:
string
,
handlers
:
ElementHandlers
)
;
#
Parameters
selector: string
handlers: ElementHandlers
#
Example
const
request
=
new
MiddlewareRequest
(
req
)
;
const
res
=
await
request
.
next
(
)
;
const
message
=
`
This was static but has been transformed in
${
request
.
geo
?.
city
}
`
;
// Transform the response HTML
res
.
rewriteHTML
(
"p[id=message]"
,
{
text
(
textChunk
)
{
if
(
textChunk
.
lastInTextNode
)
{
textChunk
.
replace
(
message
)
;
}
else
{
textChunk
.
remove
(
)
;
}
}
,
}
)
;
#
Response caveats
Modifying the response can cause React hydration errors if the hydrated page content doesn’t match the HTML returned from the server. There are two ways around this.
Ideally, you can change both the text content and the prop. That would mean the value will still match.
If that’s not possible (for example, if the displayed HTML is too complex to generate), then you can use two-pass rendering for the element. This is when you don’t render the element in SSR, but instead update the state in
useEffect
and then display it at that point. The logic for this can be encapsulated in a custom hook.
For example:
import
*
as
React
from
"react"
;
const
useHydrated
=
(
)
=>
{
const
[
hydrated
,
setHydrated
]
=
React
.
useState
(
false
)
;
React
.
useEffect
(
(
)
=>
{
setHydrated
(
true
)
}
,
[
]
)
;
return
hydrated
;
}
const
Page
=
(
{
message
,
showAd
}
)
=>
{
const
hydrated
=
useHydrated
(
)
;
return
(
<
div
>
{
hydrated
&&
showAd
?
(
<
div
>
<
p
>
This
is
an ad that isn't shown by
default
<
/
p
>
<
img src
=
"http://placekitten.com/400/300"
/
>
<
/
div
>
)
:
(
<
p
>
No ads
for
me
<
/
p
>
)
}
<
/
div
>
)
;
}
export
async
function
getStaticProps
(
)
{
return
{
props
:
{
showAd
:
false
,
}
,
}
}
export
default
Page
;
#
Modify request headers
Headers on the
MiddlewareRequest
object can be added or modified, and the changed headers will then be passed along to the origin if you call
middlewareRequest.next()
or
middlewareRequest.rewrite()
.
You can also modify headers on the original
NextRequest
object, and they will be passed along in the same way. This can be used for many things. For example, to add authentication headers to an externally proxied request or attach a bucket name header for A/B testing.
const
{
pathname
}
=
req
.
nextUrl
;
const
request
=
new
MiddlewareRequest
(
req
)
;
if
(
pathname
.
startsWith
(
"/api/hello"
)
)
{
// Add a header to the request
request
.
headers
.
set
(
"x-hello"
,
"world"
)
;
return
request
.
next
(
)
;
}
if
(
pathname
.
startsWith
(
"/headers"
)
)
{
// Add a header to the rewritten request
request
.
headers
.
set
(
"x-hello"
,
"world"
)
;
return
request
.
rewrite
(
"/api/hello"
)
;
}
Last updated: October 23, 2024
←
Legacy Next.js on Netlify
Next.js redirects and rewrites
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_overview.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/overview/
Scraped_At: 2025-06-02T19:57:51.970004

Contact
Forums
Contact support
Legacy Next.js Runtime
The information on this page applies to Next.js version 10-13.4 and Netlify Next.js Runtime v4, which is currently in maintenance support.
Visit our Next.js adapter docs
for info on newer versions of Next.js.
#
Key features of the legacy runtime
Here are notable features of the v4 runtime and the main differences compared to the current adapter:
#
Supported router types
Next.js Runtime v4 supports Next.js
Pages Router
. For full support of
App Router
, upgrade to the
latest adapter.
#
Incremental Static Regeneration (ISR)
On Runtime v4, ISR on Netlify works with
On-demand Builders
to revalidate pages as needed without rebuilding your entire site. Runtime v4 does not support tag or path based revalidation.
Upgrade to the current adapter
to use that functionality.
You can enable ISR for a page by returning a value for
revalidate
from the
getStaticProps
function. The minimum value for
revalidate
is 60 seconds. Any value less than that will default to 60 seconds.
ISR uses a “stale while revalidate” strategy, meaning that the visitor still receives the stale content, but it is regenerated in the background and becomes ready for the next request.
#
Static site export
You can use
next export
to generate a completely static site, if you have no need for any of the dynamic features that Next.js offers.
#
Image optimization
The
next/image
component allows you to automatically optimize images for your site on-demand, as they’re requested by users. On Runtime v4,
next/image
uses
ipx
and
On-demand Builders
by default. With the current adapter,
Netlify Image CDN
is used instead to simplify the setup of your site.
#
Edge middleware
Next.js middleware is supported via an automatically-installed
Edge Function
.
#
Redirects and rewrites
Next.js Runtime supports Next.js
rewrites
and
redirects
. These are defined in your
next.config.js
file and support some features that are not included in Netlify redirects and rewrites.
For redirects, we recommend using Netlify redirects when possible because they are faster to evaluate. Learn more about
Next.js redirects and rewrites on Netlify.
#
Suggested configuration values
When you
link a repository
for a Next.js project, Netlify provides a suggested build command and publish directory:
next build
and
.next
.
If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify suggests a dev command and port:
next
and
3000
.
You can override suggested values or set them in a configuration file instead, but suggested values from automatic framework detection may help simplify the process of setting up a Next.js site on Netlify.
For manual configuration, check out the
typical build settings
for Next.js.
#
pnpm support
If you’re planning to use pnpm with Next.js to manage dependencies, you must do one of the following:
Set a
PNPM_FLAGS
environment variable
with a value of
--shamefully-hoist
. This appends a
--shamefully-hoist
argument to the
pnpm install
command that Netlify runs.
Enable public hoisting
by adding an
.npmrc
file in the root of your project with this content:
public-hoist-pattern[]
=
*
Learn more about using
pnpm on Netlify
.
#
Troubleshooting
If you run into issues running a Next.js app on Netlify, check out our
troubleshooting page
. You can also visit the
Netlify Support Forums
to see if others have encountered similar issues.
#
More resources
Next.js documentation
Posts about Next.js in our blog
Last updated: April 1, 2025
←
Frameworks overview
Next.js Middleware
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_redirects-and-rewrites.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/redirects-and-rewrites/
Scraped_At: 2025-06-02T19:57:52.749195

Contact
Forums
Contact support
Legacy Next.js Runtime
The information on this page applies to Next.js version 10-13.4 and Netlify Next.js Runtime v4, which is currently in maintenance support.
Visit our Next.js adapter docs
for info on newer versions of Next.js.
Netlify’s Next.js Runtime supports Next.js
rewrites
and
redirects
. These are defined in your
next.config.js
file and have some features that are not included in Netlify redirects and rewrites.
#
Use Netlify redirects and rewrites on a Next.js site
Every site on Netlify supports
redirects and rewrites
, which are defined in a
_redirects
or
netlify.toml
file. Sites that use Next.js Runtime are no exception.
However, there are some things to keep in mind when you use Netlify redirects and rewrites on a Next.js site. Next.js Runtime generates several rewrites on its own, which are used to map paths from your site to different Netlify Functions. The functions handle SSR, preview mode, and images, as well as assets in
/_next/static
.
Any Netlify redirects or rewrites that you create
take precedence
over those created by Next.js Runtime.
Avoid root-level rewrite
Do not add a rewrite from the site root (such as
from = "/"
) in
netlify.toml
or
_redirects
. Your root-level rewrite would take precedence over Next.js Runtime’s generated rewrites and break routing on your site.
#
Redirect and rewrite precedence
Redirects and rewrites are processed in the following order:
Redirects and rewrites in the
_redirects
file. These are read in order until a match is found, then processing stops.
Redirects and rewrites in the
netlify.toml
file. None of these are read if one previous rule has already matched.
At this point, if the request targets a static file, then the static file returns without further evaluation of Next.js redirects or rewrites.
Any request that does not target a static file will then be passed to Next.js, which will then evaluate redirects and rewrites (defined in the
next.config.js
file).
#
General principles
Netlify and Next.js redirects support different features and are evaluated at different points in the request lifecycle. To determine which one to use with your site, consider the following:
#
When to use Netlify redirects or rewrites
Generally, if your redirect can be handled with Netlify redirects, this is the preferred option because they are faster to evaluate.
Identity
,
proxying
, and
country-based redirects
are Netlify-specific features and must use Netlify redirects.
If you need redirects or rewrites to be applied before loading static files, you must use Netlify redirects and rewrites.
#
When to use Next.js redirects or rewrites
If you are using a
rewrite
that points to a dynamic Next.js page, you must use Next.js rewrites. Next.js has no way of knowing what the rewritten page is when using Netlify rewrites, so the wrong page is likely to be rendered. Note that this only applies to rewrites, not redirects.
If you need Next.js-specific features, such as regex path or header matching, you must use Next.js rewrites.
#
Use
_redirects
and
_headers
files
If you use
_redirects
or
_headers
files rather than a
netlify.toml
file, be aware that these files must be in the published directory of your site, not the root of your repo.
To do this, put them in
public
and they will be moved into
.next
at build time. Do not put them directly into
.next
, because it is emptied at build time. Any
_redirects
or
_headers
files in the root of the repo will not be found when deployed.
Last updated: April 1, 2025
←
Legacy Next.js on Netlify
Next.js advanced API routes
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_next-js_runtime-v4_troubleshooting.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/troubleshooting/
Scraped_At: 2025-06-02T19:57:53.584888

Contact
Forums
Contact support
Legacy Next.js Runtime
The information on this page applies to Next.js version 10-13.4 and Netlify Next.js Runtime v4, which is currently in maintenance support.
Visit our Next.js adapter docs
for info on newer versions of Next.js.
If you encounter issues running Next.js on Netlify, the information on this page may help you solve them.
#
Including content files for SSR/ISR
If your server-rendered page relies on local files in your repository, the files need to be bundled with the handler functions. This can be done by modifying your
file based configuration
.
Under the
functions
option, add an entry to the
included_files
option. Be careful to not include unnecessary files. Particularly large files like images or videos can make your handler function sizes grow quickly. There is a 250 MB size limit for each handler’s unzipped function bundle.
Review the
Functions Configuration Docs
for more information.
Update your
netlify.toml
file to include the following (assuming local content is located in the
/content
directory):
[
functions
]
included_files
=
[
"content/**"
]
#
Large function error
You may encounter an error about generated functions being too large. During deployment, each unzipped function bundle is limited to 250 MB in size. The cause of this error could be large dependencies or a large number of pre-rendered pages. The list of largest files shown in the build logs will help you determine the cause.
#
Large dependencies
This is the most common root cause of generated functions being too large. Some node modules are very large, mostly those that include native modules. Examples include
electron
and
chromium
.
The function bundler is usually able to find modules that are actually used by your code, but sometimes it will incorrectly include unneeded modules. If this is the case, you can either remove the module from your dependencies if you installed it yourself, or exclude it manually in your
netlify.toml
.
[
functions
]
included_files
=
[
"!node_modules/A_LARGE_MODULE/**/*"
]
In the above example, you should change the value to match the problematic module. The
!
at the beginning of the module path indicates that it should be excluded.
If you do need large modules at runtime, you can try changing to a Netlify Function which has less overhead than the equivalent Next.js function.
#
Large numbers of pre-rendered pages
A large number of pre-rendered pages can take up a lot of space in the function. To fix this, consider deferring the building of the pages. If you return
fallback: "blocking"
from
getStaticPaths
, the rendering will be deferred until the first user requests the page. This approach reduces build and deploy time, and can make your bundle a lot smaller.
#
Netlify Support Forums
Can’t find what you’re looking for? The
Netlify Support Forums
are a great place to find more information and ask questions that are specific to your needs.
Last updated: April 1, 2025
←
Legacy Next.js on Netlify
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_nuxt.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/nuxt/
Scraped_At: 2025-06-02T19:57:54.438037

Contact
Forums
Contact support
Nuxt is an open source, modular framework for building performant sites and applications using Vue.js.
#
Key features
These Nuxt features provide key benefits for sites and apps, including ones built and deployed with Netlify.
Improved SEO
. With the ability to
statically generate
your site, Nuxt can help to boost search engine optimization for your content.
Page routing.
Nuxt has a
file system-based routing structure
. Organizing files and subdirectories within a pages directory automatically results in corresponding routes.
Image optimization
. The
nuxt/image
module
, backed by
Netlify Image CDN
, allows you to automatically optimize images for your site.
Git-based Headless CMS.
The
nuxt/content
module
parses Markdown, JSON, YAML, XML and CSV files within your site.
Server-side rendering.
Powered by the
Nitro
server engine, SSR is supported automatically when you use Nuxt 3.
#
Netlify integration
Nuxt sites on Netlify can benefit from automatic framework detection and require minimal setup considerations.
Nuxt 3 introduces new rendering options, such as server-side rendering (SSR). SSR is supported when you deploy Nuxt 3 to Netlify, but requires configuration when you use
Edge Functions
.
For more information, check out the Nuxt
Getting Started Guide
and
Deploy Nuxt to Netlify
doc.
#
Automatic framework detection
When you
link a repository
for a project, Netlify tries to detect the framework your site is using.
If your site is built with Nuxt, Netlify provides a suggested build command and publish directory:
Nuxt 3:
npm run build
(assuming your build command is set to
nuxt build
) and
dist
Nuxt 2:
nuxt generate
and
dist
If you’re using the CLI to run
Netlify Dev
for a local development environment, the CLI should work automatically assuming you are using the dev command and port:
nuxt
and
3000
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up a site on Netlify.
For manual configuration, check out the
typical build settings
for Nuxt.
#
pnpm support
If you’re planning to use pnpm with Nuxt 3, you must set a
PNPM_FLAGS
environment variable
with  a value of
--shamefully-hoist
. This appends an argument to the
pnpm install
command that Netlify runs. Learn more about using
pnpm on Netlify
.
#
Edge Functions
Edge Functions
connect the Netlify platform and workflow with an open runtime standard at the network edge. This enables you to build fast, personalized web experiences with an ecosystem of development tools.
Nuxt supports
server-side rendering (SSR)
, but the use of Edge Functions requires some configuration. When you use Edge Functions, Nitro, the server engine that powers Nuxt, will not auto-detect them and needs a different deployment preset. Learn more in the
Nitro documentation
.
You can browse a
full library of reference examples
for different ways to use Edge Functions. For more details, check out the
Edge Functions documentation
.
#
Netlify Image CDN
When deploying your Nuxt applications to Netlify, the Nuxt image module automatically uses
Netlify Image CDN
to optimize and transform images on demand without impacting build times. Netlify Image CDN also handles content negotiation to use the most efficient image format for the requesting client.
To transform a source image hosted on another domain, you must first configure allowed domains in your
nuxt.config.ts
file. Visit the
Nuxt Image docs
to learn more.
#
Deploy a Nuxt site on Netlify
This section demonstrates how to deploy a Nuxt site on Netlify. It covers:
Starting a new project using Nuxt
Deploying your Nuxt project to Netlify with Netlify CLI
#
Start a new project using Nuxt
Before you begin, make sure you have
Node.js
version 18.14.0 or later installed on your machine.
To get started, create your project from the command line with any of the following package managers:
Loading error: Refresh the page to access this code sample
npx nuxi@latest init my-project
pnpm
dlx nuxi@latest init my-project
Next, navigate to your project directory and install your dependencies:
Loading error: Refresh the page to access this code sample
cd
my-project
npm
install
cd
my-project
pnpm
install
cd
my-project
yarn
install
When using
pnpm
, you must set a
PNPM_FLAGS
environment variable with a value of
--shamefully-hoist
.
Start your development server:
Loading error: Refresh the page to access this code sample
npm
run dev --
-o
pnpm
dev
-o
yarn
dev
-o
From here you can customize your site. You can also create a Git repository for your site to take advantage of
continuous deployment
.
Avoid 404s for SPAs
If your project is a single page app (SPA) that uses the history
pushState
method to get clean URLs, you must add a
rewrite rule
to serve the
index.html
file no matter what URL the browser requests.
#
Deploy your Nuxt project with Netlify CLI
You can
deploy your project from the command line
using
Netlify CLI
.
To ensure you have the latest version of Netlify CLI installed, run this command from any directory in your terminal:
npm
install
netlify-cli
-g
In the directory for your project, run the following command to create a new Netlify site:
netlify init
Didn’t initialize a Git repository?
When you run
netlify init
without initializing a Git repository first, the CLI prompts you to connect your local directory to GitHub. Follow the steps in your terminal to link your local directory with a remote repo in order to use continuous deployment for your site.
Follow the prompts to create your site, select a team if necessary, and optionally create a site name. If you already initialized a Git repository, you can authorize your Git provider and set your build command and directory.
If you used continuous deployment, your site is now published! To learn how to manually deploy a site, check out the
manual deploy docs
.
#
More resources
Typical Nuxt build settings
Netlify Blog: Nuxt posts
Video: Get started with Nuxt
Video: Building with Sanity and Nuxt
Video: Build a Static Blog with Nuxt and Strapi
Nuxt documentation
Nitro documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_react-router.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/react-router/
Scraped_At: 2025-06-02T19:57:55.298810

Deploy a React Router site
Deploy to Netlify
Get started with React Router on Netlify right away by clicking the button above
Demo repo
Demo site
###End of file##

-------- frameworks_react.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/react/
Scraped_At: 2025-06-02T19:57:56.259631

Contact
Forums
Contact support
React is a JavaScript library for building user interfaces (UI). It allows you to create reusable UI components and manage the state of an application. React uses a declarative approach to building UIs and is widely used especially for single-page applications.
Here are a few of the common React-based frameworks you can deploy on Netlify:
Gatsby
Next.js
React Router
Remix
You can also use Create React App. Create React App is ideal for quickly getting started building a React application, especially if you want to focus on learning the basics of React. Below, learn about deploying projects built with Create React App on Netlify.
#
Create React App
Create React App is a command line tool that generates a boilerplate React single-page application (SPA) with a pre-configured build pipeline. It simplifies the complexity of setting up a React project, allowing you to focus on building out the app itself.
#
Netlify integration
When you
link a repository
for a project, Netlify tries to detect the framework your site is using. If your site is built with Create React App, Netlify provides a suggested build command and publish directory:
react-scripts build
and
build
. If you’re using the Netlify CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
react-scripts start
and
3000
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up a project with Create React App on Netlify.
For manual configuration, check out the
typical build settings
for Create React App.
#
Environment variables
Environment variables prefixed with
REACT_APP_
are processed and made available in the browser for client-side JavaScript access. For more information on how to use environment variables in React, check out the
Environment variables and frameworks doc
.
#
Deploy a Create React App site on Netlify
This section demonstrates how to deploy a Create React App site on Netlify. It covers:
Starting a new project using Create React App
Deploying your Create React App project to Netlify with Netlify CLI
#
Start a new project using Create React App
Before you begin, make sure you have
Node.js
version 18.14.0 or later installed on your machine. Then, you can start a new project using Create React App.
To get started, run the following in your terminal to create your project:
npx create-react-app my-app
To navigate to your project directory and start your development server:
cd
my-app
npm
start
From here you can customize your site. You can also create a Git repository for your site to take advantage of
continuous deployment
.
Avoid 404s for SPAs
If your project is a single page app (SPA) that uses the history
pushState
method to get clean URLs, you must add a
rewrite rule
to serve the
index.html
file no matter what URL the browser requests.
#
Deploy your Create React App project with Netlify CLI
You can
deploy your project from the command line
using
Netlify CLI
.
To ensure you have the latest version of Netlify CLI installed, run this command from any directory in your terminal:
npm
install
netlify-cli
-g
In the directory for your project, run the following command to create a new Netlify site:
netlify init
Didn’t initialize a Git repository?
When you run
netlify init
without initializing a Git repository first, the CLI prompts you to connect your local directory to GitHub. Follow the steps in your terminal to link your local directory with a remote repo in order to use continuous deployment for your site.
Follow the prompts to create your site, select a team if necessary, and optionally create a site name. If you already initialized a Git repository, you can authorize your Git provider and set your build command and directory.
If you used continuous deployment, your site is now published! To learn how to manually deploy a site, check out the
manual deploy docs
.
#
More resources
Typical Create React App build settings
Deploy React apps in less than 30 seconds
React documentation
Create React App documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_remix.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/remix/
Scraped_At: 2025-06-02T19:57:57.190465

Contact
Forums
Contact support
Remix gives you a server and browser runtime that focuses on performance and excellent user experiences. With Remix, you get a number of built-in tools to build better websites, such as nested routes, parallel data requests, and robust built-in error handling.
#
Key features
These features provide important benefits for Remix projects, including those built by and deployed with Netlify.
Nested routes.
By default, Remix creates routes for components that serve as boundaries for data loading and code splitting.
Parallel data requests by default.
Instead of waiting on sequential requests, Remix processes requests in parallel and then sends a complete HTML document.
Built-in global error handling.
Remix has built-in error handling for server and client rendering and server side data handling. Error boundaries don’t block the entire page from rendering, only the affected component.
#
Netlify integration
You can create a Remix app and deploy it on Netlify using the Netlify starter template for Remix with the command
npx create-remix@latest --template netlify/remix-template
. This template automatically creates everything you need to deploy to Netlify — including a pre-configured
netlify.toml
file with
typical build settings
.
#
Create a new Remix app to deploy to Netlify
You can use the command line to scaffold a new project based on the Netlify starter template for Remix. This can streamline the process of getting your project up and running.
In your terminal, run
npx create-remix@latest --template netlify/remix-template
.
Choose where you want to create your project.
Decide whether you want to use TypeScript or JavaScript.
Enter
Y
to have
create-remix
run
npm install
for your project.
Choose whether you want to run your app with functions or
edge functions
.
Follow the starter template README to get your project running.
#
Update the deploy target for an existing Remix app
If you have an existing Remix project that isn’t deployed on Netlify and you want to change the deploy target to Netlify, you need to create a new Remix project.
Create a
new Remix project
with Netlify as the deploy target.
Replace the new project’s
app
directory with the
app
directory from your old project.
#
Manual configuration
Alternatively, you can configure this manually.
First, ensure you're using Remix Vite. If not,
follow this
guide
.
Then, install Netlify's Remix adapter and add its Vite plugin to your Vite config:
npm
install
--save-dev @netlify/remix-adapter
Loading error: Refresh the page to access this code sample
import
{
vitePlugin
as
remix
}
from
"@remix-run/dev"
;
import
{
defineConfig
}
from
"vite"
;
import
tsconfigPaths
from
"vite-tsconfig-paths"
;
// ↓ add this
import
{
netlifyPlugin
}
from
"@netlify/remix-adapter/plugin"
;
export
default
defineConfig
(
{
plugins
:
[
remix
(
)
,
tsconfigPaths
(
)
,
netlifyPlugin
(
)
// ← add this
]
}
)
;
import
{
vitePlugin
as
remix
}
from
"@remix-run/dev"
;
// ↓ add this
import
{
netlifyPlugin
}
from
"@netlify/remix-adapter/plugin"
;
export
default
{
plugins
:
[
remix
(
)
,
netlifyPlugin
(
)
// ← add this
]
}
;
#
Edge Functions
Edge Functions
connect the Netlify platform and workflow with an open runtime standard at the network edge. This enables you to build fast, personalized web experiences with an ecosystem of development tools, including Remix.
To take advantage of Netlify Edge Functions with Remix, follow the steps above to
create a new Remix app to deploy on Netlify
. When the CLI prompts you to select the type of functions to run your Remix app with, select
Netlify Edge Functions
.
To change an existing site to use Edge Functions, replace the
@netlify/remix-adapter
NPM
dependency with
@netlify/remix-edge-adapter
and install this additional dependency:
npm
i @netlify/remix-runtime
You can browse a
full library of reference examples
for different ways to use Edge Functions. For more details, check out the
Edge Functions documentation
.
#
More resources
Remix quickstart
Netlify blog: Remix posts
Developer guide: build a high-performance Remix image component with Unpic and Netlify Image CDN
Remix docs about HTTP handlers and adapters
Last updated: December 19, 2024
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_sveltekit.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/sveltekit/
Scraped_At: 2025-06-02T19:57:58.105250

Contact
Forums
Contact support
SvelteKit is a versatile, open source framework for building web applications using
Svelte
components. Unlike React and Vue, Svelte has no virtual DOM and includes a compiler that builds projects into plain HTML, CSS, and JavaScript. SvelteKit enables features like client-side routing, server-side rendering (SSR), and hot module replacement for Svelte projects.
#
Key features
These SvelteKit features are available for projects built and deployed with Netlify.
Multiple rendering modes.
As opposed to globally setting one rendering mode for a project, you can define which rendering mode to use on a per-page basis. With SvelteKit, choose between modes such as prerendering and static site generation (SSG), client-side rendering (CSR), and server-side rendering (SSR).
Automatic API endpoints.
API routes allow developers to create endpoints to interact with third-party services for data fetching.
Consistent navigation experience.
With SvelteKit, you can use hybrid rendering to combine server-side rendered pages with a client-side router. This makes the navigation experience similar to a typical single-page app (SPA) that doesn’t require full page reloads.
Developer-friendly tooling.
SvelteKit uses
Vite
for a modern scaffolding and development experience.
#
Netlify integration
SvelteKit projects on Netlify benefit from
automatic framework detection
and have minor setup considerations for
deployment
.
#
Automatic framework detection
When you
link a repository
for a project, Netlify tries to detect the framework your project is using. For SvelteKit projects, Netlify automatically suggests a build command and output directory of
vite build
and
build
.
Projects that use SvelteKit starter templates can use
npm run build
as the build command and this will run
vite build
.
If you’re using the CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
vite dev
and
5173
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up a SvelteKit site on Netlify.
For manual configuration, check out the
typical build settings
for SvelteKit.
#
Deployment
To deploy a SvelteKit project on Netlify, use
SvelteKit’s Netlify adapter
. This adapter deploys SvelteKit endpoints as
Netlify Functions
. For example, SSR routes are deployed to a
render
function. If you enable the
split
feature, each route is deployed to its own function. Check out the
split functions
section below for details.
Function routing limitations
Paths handled by proxies or functions may not redirect from HTTP to HTTPS URLs as expected. If you’re working with proxies or functions, we recommend only publishing HTTPS URLs for your visitors to use.
To deploy your project on Netlify:
Install the adapter into your project.
Loading error: Refresh the page to access this code sample
npm
install
-D
@sveltejs/adapter-netlify
yarn
add
-D
@sveltejs/adapter-netlify
Add the adapter to your project’s
svelte.config.js
file and
pass any options
you need.
import
adapter
from
'@sveltejs/adapter-netlify'
;
export
default
{
kit
:
{
adapter
:
adapter
(
)
}
}
;
If the config file already has an adapter import from
@sveltejs/adapter-auto
, we recommend replacing it with the more specific import from
@sveltejs/adapter-netlify
. This ensures that SvelteKit will select the correct adapter module in all development environments, including local development.
Alternatively, you can use
@sveltejs/adapter-static
for a fully static site, and it will also work successfully with Netlify.
Create a
netlify.toml
in your project’s
base directory
and specify a build command and publish directory.
[
build
]
command
=
"npm run build"
publish
=
"build"
Create your new project
on Netlify with Git or the Netlify CLI.
#
Split functions
By default, SvelteKit’s Netlify adapter will bundle all of your routes and SSR functionality into a single Netlify Function called
render
. This can result in a large function. If desired, you can configure the adapter to generate multiple functions instead by setting the
split
option to true.
The
split
feature does not work with Edge Functions. In
svelte.config.js
, you should either set
edge
to
false
or leave that option out.
// svelte.config.js
export
default
{
kit
:
{
adapter
:
adapter
(
{
edge
:
false
,
split
:
true
}
)
}
}
;
When the split option is true, the adapter generates a function for each route (pages and SvelteKit endpoints) and uses the route or endpoint name as the function name. But, generated function names for nested and random routes can be hard to predict. To confirm the name of a generated function, refer to the
Functions
page in the Netlify UI for a list of all the generated functions for your SvelteKit site.
#
Edge Functions
Edge Functions
connect the Netlify platform and workflow with an open runtime standard at the network edge. This enables you to build fast, personalized web experiences with an ecosystem of development tools.
When you enable Edge Functions in SvelteKit, SSR happens in a Deno-based edge function that’s deployed close to your site visitors. If you don’t enable Edge Functions, SSR relies on standard Node-based Netlify Functions.
You can browse a
full library of reference examples
for different ways to use Edge Functions. For more details, check out the
Edge Functions documentation
.
#
Enable Edge Functions in your SvelteKit project
The
netlify-sveltekit
adapter supports Edge Functions. To enable Edge Functions for your SvelteKit project, you need to update your
svelte.config.js
file. Specifically, add the
edge: true
option to the
adapter
function. The
edge
option defaults to
false
.
If you use Edge Functions, you can’t use the adapter’s
split
feature.
export
default
{
kit
:
{
adapter
:
adapter
(
{
edge
:
true
,
split
:
false
}
)
}
}
;
#
Limitations
Edge functions don’t work locally.
Currently, edge functions do not work as expected when running
netlify dev
with SvelteKit.
Redirects are not supported in
netlify.toml
.
Use
_redirects
instead.
#
More resources
Typical SvelteKit build settings
Video: Building with SvelteKit and GraphCMS
Video: How to use Netlify Functions in SvelteKit Applications
Learn with Jason: Experimenting with SvelteKit
SvelteKit documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_tanstack-start.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/tanstack-start/
Scraped_At: 2025-06-02T19:57:58.896248

Explore a TanStack app
Deploy to Netlify
Explore this working example of a TanStack app built with TanStack Router, Sentry, and Claude AI. This chat app uses Claude AI to answer questions.
Demo repo
Demo site
###End of file##

-------- frameworks_vite.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/vite/
Scraped_At: 2025-06-02T19:57:59.523766

Contact
Forums
Contact support
Vite is a next-generation frontend build tool designed to provide a fast, lean development experience for modern web projects. It includes a dev server and a build command that bundles your code. Use the frontend library or framework of your choice when you create a project with Vite.
#
Key features
The features listed below outline benefits for Vite projects, including those built and deployed with Netlify.
Dependency resolving and pre-bundling.
Vite detects bare module imports in all served source files and pre-bundles them to improve page loading speed. It also converts CommonJS modules to ES modules and ensures the browser imports them properly.
Hot Module Replacement (HMR)
. Frameworks with HMR capabilities can leverage Vite’s HMR API to provide instant updates without reloading the page or impacting the application state.
Out-of-the-box support for Typescript, Vue, and JSX.
With Vite, you can import TS, JSX, and TSX files out of the box and enjoy first-class support for Vue.
Build optimizations.
Features such as
CSS code splitting
,
automatically generated directives
, and
async chunk loading optimization
are automatically applied as part of the build process, without the need for additional configuration.
Easily extendable
. Vite can be extended
using plugins
based on the mature ecosystem of Rollup plugins. Use plugins to extend the dev server and enable
SSR functionality
.
#
Netlify integration
When you link a repository for a project, Netlify tries to detect the framework your site is using. If your site is built with Vite, Netlify provides a suggested build command and publish directory:
npm run build
or
yarn build
and
dist
. You can
override suggested values
or
set them in a configuration file
instead, but automatic framework detection may help simplify the process of setting up a project with Vite on Netlify.
#
Deploy a Vite site on Netlify
This section demonstrates how to deploy a Vite site on Netlify. It covers:
Starting a new project using Vite
Deploying your Vite project to Netlify with Netlify CLI
#
Start a new project using Vite
Before you begin, make sure you have
Node.js
version 18.14.0 or later installed on your machine. Then, you can start a new project using Vite.
Scaffold your Vite project from the command line with any of the following package managers:
Loading error: Refresh the page to access this code sample
npm
create vite@latest
yarn
create vite
pnpm
create vite
Follow the prompts to enter your project name and select the template you want to use. Check out the
create-vite
docs
for more information about the supported templates.
Launch your site locally by running the appropriate dev command. For example, if you built your project with npm:
npm
run dev
From here you can customize your site. You can also create a Git repository for your site to take advantage of
continuous deployment
.
#
Deploy your Vite project with Netlify CLI
You can
deploy your project from the command line
using
Netlify CLI
.
To ensure you have the latest version of Netlify CLI installed, run this command from any directory in your terminal:
npm
install
netlify-cli
-g
In the directory for your project, run the following command to create a new Netlify site:
netlify init
Didn’t initialize a Git repository?
When you run
netlify init
without initializing a Git repository first, the CLI prompts you to connect your local directory to GitHub. Follow the steps in your terminal to link your local directory with a remote repo in order to use continuous deployment for your site.
Follow the prompts to create your site, select a team if necessary, and optionally create a site name. If you already initialized a Git repository, you can authorize your Git provider and set your build command and directory.
If you used continuous deployment, your site is now published! To learn how to manually deploy a site, check out the
manual deploy docs
.
Avoid 404s for SPAs
If your project is a single page app (SPA) that uses the history
pushState
method to get clean URLs, you must add a
rewrite rule
to serve the
index.html
file no matter what URL the browser requests.
#
More resources
Typical Vite build settings
Vite documentation
Vite documentation: deploying a static site
Last updated: July 19, 2024
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- frameworks_vue-cli.txt --------
Start of file
URL: https://docs.netlify.com/frameworks/vue-cli/
Scraped_At: 2025-06-02T19:58:00.805701

Contact
Forums
Contact support
Vue CLI is a set of tools for rapid development of
Vue.js
applications. It includes a command line interface for prototyping and building projects and a graphical user interface for creating and managing applications.
#
Key features
These features provide important benefits for Vue CLI projects, including ones built and deployed with Netlify.
Default setup.
Vue CLI provides a standard baseline for
project setup
with common features like hot module reloading and common defaults for build tools.
Ready for development.
Built-in support for Babel, TypeScript, ESLint, PostCSS, Progressive web apps (PWAs), unit testing, and end-to-end testing unlocks your productivity.
Optional configuration.
Vue CLI allows for full
configuration of tooling
without needing to eject.
#
Netlify integration
When you
link a repository
for a project, Netlify tries to detect the framework your site is using. If your site is built with Vue CLI, Netlify provides a suggested build command and publish directory:
vue-cli-service build
and
dist
. If you’re using the Netlify CLI to run
Netlify Dev
for a local development environment, Netlify also suggests a dev command and port:
vue-cli-service serve
and
8080
. You can override suggested values or set them in a configuration file instead, but automatic framework detection may help simplify the process of setting up a Vue CLI project on Netlify.
For manual configuration, check out the
typical build settings
for Vue CLI.
Avoid 404s for SPAs
If your project is a single page app (SPA) that uses the history
pushState
method to get clean URLs, you must add a
rewrite rule
to serve the
index.html
file no matter what URL the browser requests.
#
Vue-specific environment variables
Environment variables prefixed with
VUE_APP_
are processed by the Vue CLI and made available in the browser for client-side JavaScript access. For more information on how to use environment variables in Vue, check out the
Environment variables and frameworks doc
.
#
More resources
Typical Vue CLI build settings
Vue CLI documentation
Last updated: May 13, 2025
←
Frameworks overview
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_api.txt --------
Start of file
URL: https://docs.netlify.com/functions/api/
Scraped_At: 2025-06-02T19:58:01.460626

Contact
Forums
Contact support
This page provides a full reference of the Netlify Functions API.
Upgrading from Lambda compatibility mode
If you’re using the older
Lambda compatibility mode
for functions, consider upgrading to get access to the full context object below.
Learn more.
#
Netlify-specific
Context
object
The
Context
object exposes the following properties:
#
account
An object containing Netlify team account information. The
id
property in the object holds the unique ID of the team that the site and function belong to.
#
cookies
A simplified interface for reading and storing cookies:
cookies.get(name)
:
reads a cookie with a given name from the incoming request.
cookies.set(options)
:
sets a cookie on the outgoing response, using the same format as the
options
value in
the
CookieStore.set
web standard
.
cookies.delete(name)
or
cookies.delete(options)
:
adds an instruction to the outgoing response for the client to delete a cookie. Following
the
CookieStore.delete
web standard
, accepts a string representing the name of the cookie, or an options object.
Setting cookies across subdomains requires a custom domain
Since the
netlify.app
domain is used by many customers, it is listed in the Mozilla Foundation’s
Public Suffix List
, which prevents setting cookies across subdomains.
#
deploy
An object containing Netlify deploy information with the following property:
context
:
the
context
of the deploy that the function belongs to.
id
:
unique ID of the deploy that the function belongs to.
published
:
a boolean that indicates whether or not the function belongs to the current
published deploy
.
#
geo
An object containing geolocation data for the client with the following properties:
city
:
name of the city.
country
:
code
:
ISO 3166 code for the country.
name
:
name of the country.
latitude
:
latitude of the location.
longitude
:
longitude of the location.
subdivision
:
code
:
ISO 3166 code for the country subdivision.
name
:
name of the country subdivision.
timezone
:
timezone of the location.
postalCode
:
postal (zip) code of the location. We support all regional formats, so the format will vary.
#
ip
A string containing the client IP address.
#
params
An object containing the parameters set for the function’s
path
in the
configuration object
and the values they receive from the incoming request URL.
For example, for a function configured to run at
/pets/:name
, the
params
value for a request to
/pets/boo
will be
{"name":"boo"}
.
To access the query string, use
request.url
instead.
#
requestId
A string containing the Netlify request ID.
For example,
01FDWR77JMF2DA1CHF5YA6H07C
.
#
server
An object containing server metadata with the following property:
region
:
the region code where the deployment is running; for example,
us-east-1
.
#
site
An object containing Netlify site metadata with the following properties:
id
:
unique ID for the site; for example,
1d01c0c0-4554-4747-93b8-34ce3448ab95
.
name
:
name of the site, its Netlify subdomain; for example,
petsof
.
url
:
URL representing the main address to your site. It can be either a Netlify subdomain or your own custom domain if you set one; for example,
https://petsof.netlify.app
or
https://www.petsofnetlify.com
.
#
waitUntil
context.waitUntil()
is a function accepting a promise, allowing you to extend the function’s execution until that promise it completed,
without blocking the response to the client
from being sent.
Learn more.
Usage notes:
This method is available for functions deployed on or after March 20, 2025. To test locally, use the latest version of the Netlify CLI.
The duration which is reported in
logs
, reported in
metrics
, exported via
log drains
and used for
billing
includes the full duration of the function until it completes, including any asynchronous operations. Typically, the end-user is receiving the response before the function completes all async work.
The Netlify function can run until its
execution time limit
. That includes all async work.
#
Netlify
global object
This global object exposes the following properties:
#
Netlify.context
The Netlify-specific
context
object
.
This property is available within the
scope
of the function handler. If accessed from outside the handler, it returns
null
.
#
Netlify.env
An object providing access to
environment variables
with the following properties:
delete(name)
:
in the context of the invocation, deletes an environment variable with a given name.
get(name)
:
returns the string value of an environment variable with a given name; if the environment variable is not defined,
undefined
is returned.
has(name)
:
returns a boolean value containing
true
if an environment variable with a given name exists, and
false
otherwise.
set(name, value)
:
in the context of the invocation, sets an environment variable with a given name and value.
toObject()
:
returns a plain object containing all the environment variables and their values.
Last updated: March 27, 2025
←
Get started with functions
Lambda compatibility
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_background-functions.txt --------
Start of file
URL: https://docs.netlify.com/functions/background-functions/
Scraped_At: 2025-06-02T19:58:02.320497

Contact
Forums
Contact support
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
Netlify’s Background Functions provide an option for serverless functions that run for up to 15 minutes and don’t need to complete before a visitor can take next steps on your site. For tasks like batch processing, scraping, and slower API workflow execution, they may be a better fit than synchronous functions.
#
How background functions work
Background functions are longer-running functions that are processed as background tasks using asynchronous invocation.
When a function is invoked asynchronously, there is an initial
202
success response that indicates that the function was successfully invoked. The function will run separately in the background until it completes or it reaches the 15 minute execution limit. If function invocation returns an error, a retry happens after one minute. If it fails again, another retry happens two minutes later.
When a background function is successfully executed, you generally pass the result to a destination other than the originating client.
Like all Netlify Functions, background functions are version-controlled, built, and deployed along with the rest of your Netlify site. Background functions are deployed with the
default deployment options
, and you can
configure
and
monitor
them along with your other functions.
Background functions don’t support response streaming because they don’t return responses.
#
Create background functions
You can
create background functions in TypeScript
,
JavaScript
, or
Go
.
To get started,
create a function file
in your functions directory and append the name with
-background
. For example,
netlify/functions/hello-background.mts
. Based on the filename, Netlify will deploy a background function that can be called on the following endpoint, relative to the base URL of your site:
/.netlify/functions/hello-background
.
Background function syntax
is similar to synchronous function syntax. The file has a default export with a function that receives a web platform
Request
and a
Netlify-specific
Context
object on each invocation. But, with background functions, the client receives an empty response while the execution happens in the background, so you generally pass the invocation result to a different destination.
Check out our
get started with functions
doc to learn more about how to
name your function
and the
background function format
.
Want to use background functions with Next.js?
If you have a Next.js site on Netlify, you can use advanced API routes for background functions. The endpoint for background functions with Next.js differs from the endpoint described above. Read more about
background API routes for Next.js
.
#
Invoke background functions
Typically, you invoke a background function with a
POST
request to your endpoint, so that you can pass parameters as needed. You can also trigger background functions on
Netlify events
and
Identity events
.
You can then reference the
function logs
to observe and troubleshoot the background functions as they run.
#
More Background Functions resources
Netlify Blog: What are Background Functions?
Netlify Blog: Background and Scheduled API Routes for Next.js
Last updated: April 30, 2024
←
Functions & Identity
Scheduled Functions
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_deploy.txt --------
Start of file
URL: https://docs.netlify.com/functions/deploy/?fn-language=ts
Scraped_At: 2025-06-02T19:58:05.255286

Contact
Forums
Contact support
This page describes workflows for deploying your functions.
Choose your programming language:
TypeScript
JavaScript
Go
TypeScript
JavaScript
Go
The deployment preparation process includes both compiling and bundling your TypeScript function files into executable artifacts.
You can use
continuous deployment
, the
Netlify CLI
, or the
Netlify API
to deploy functions.
#
Continuous deployment with Git
With
continuous deployment
, your functions are built if needed and deployed each time you push changes to your Git provider. You can rely on
Netlify’s default automatic build process
, use
your own custom build process on Netlify
, or
build outside of Netlify
.
#
Automatic build
Netlify can automatically detect and build your functions from their source files. This is the most common workflow.
To use this option, follow the TypeScript file naming instructions on the
get started with functions
page.
TypeScript and JavaScript together
If you include TypeScript and JavaScript functions with the same name, for example,
my-function.ts
and
my-function.js
, the TypeScript function is ignored while the JavaScript function is deployed. This allows you to handle TypeScript compilation in a
custom build command
, if preferred. Netlify then bundles and deploys the resulting JavaScript function.
#
Custom build
If you want more control over the handling of your function source files, you can use your site’s build command to customize the build process.
Netlify runs your build command before accessing your functions directory to prepare and deploy your functions. This means you can use your build command to override any part of the default preparation process up until the point Netlify deploys executable artifacts.
Here are some examples of customizations you could make to the process:
Bundle your functions with tools not available through Netlify such as Webpack or Rollup.
Run unit tests to validate your functions before they’re deployed.
If you want your custom build to bypass Netlify’s automated function and dependency preparation entirely, your build process needs to result in Node.js ZIP archives in your functions directory. Netlify will deploy these without modification.
To customize the build process, do one of the following:
Include customizations directly in your build command. For example:
tsc hello/function.ts
--outfile
netlify/functions/hello.js
This example customizes the TypeScript compilation stage.
Invoke scripts through a file called by your build command. For example:
npm
run test:functions
&&
npm
run build
Where
test:functions
is a unit testing script configured in
package.json
. For more information, visit our Forums for a verified Support Guide on
testing your Netlify builds
.
#
External build
For even more control over the handling of your function source files and dependencies, you can bundle ZIP archives outside of Netlify.
If you put your bundled ZIP archives in your functions directory before you push changes to your Git provider, Netlify will deploy these executable artifacts without modification.
Consider CLI deploys instead
It’s not a best practice to track bundling results in Git. So, if you want to bundle your own ZIP archives, we recommend you use
CLI deploys
instead of continuous deployment with Git.
#
Manual deploys with CLI
Netlify CLI can upload files directly from your local project directory to your site on Netlify.
Common use cases for this workflow:
updating a site while
builds are stopped
deploying to Netlify at the end of external CI tool tasks
Prepare your function dependencies before you deploy with the CLI.
Install your dependencies. This enables Netlify CLI to automatically zip dependencies with your functions for deployment.
Follow the
instructions on the CLI page
to deploy your site including your functions.
TypeScript and JavaScript together
If you include TypeScript and JavaScript functions with the same name, for example,
my-function.ts
and
my-function.js
, the TypeScript function is ignored while the JavaScript function is deployed. This allows you to handle TypeScript compilation locally, if preferred. Netlify then bundles and deploys the resulting JavaScript function.
#
File digest deploys with API
Netlify API can upload functions when you use the file digest method for manual deploys.
Common use cases for this workflow:
updating a site while
builds are stopped
automating workflows that connect with other systems
Prepare your functions before you deploy with the API.
Zip each function with its dependencies.
Follow the
instructions on the API page
to deploy your site including executable artifacts for Netlify Functions.
The deployment preparation process includes bundling your JavaScript function files into executable artifacts.
You can use
continuous deployment
, the
Netlify CLI
, or the
Netlify API
to deploy functions.
#
Continuous deployment with Git
With
continuous deployment
, your functions are built if needed and deployed each time you push changes to your Git provider. You can rely on
Netlify’s default automatic build process
, use
your own custom build process on Netlify
, or
build outside of Netlify
.
#
Automatic build
Netlify can automatically detect and build your functions from their source files. This is the most common workflow.
To use this option, follow the JavaScript file naming instructions on the
get started with functions
page.
TypeScript and JavaScript together
If you include TypeScript and JavaScript functions with the same name, for example,
my-function.ts
and
my-function.js
, the TypeScript function is ignored while the JavaScript function is deployed. This allows you to handle TypeScript compilation in a
custom build command
, if preferred. Netlify then bundles and deploys the resulting JavaScript function.
#
Custom build
If you want more control over the handling of your function source files, you can use your site’s build command to customize the build process.
Netlify runs your build command before accessing your functions directory to prepare and deploy your functions. This means you can use your build command to override any part of the default preparation process up until the point Netlify deploys executable artifacts.
Here are some examples of customizations you could make to the process:
Bundle your functions with tools not available through Netlify such as Webpack or Rollup.
Run unit tests to validate your functions before they’re deployed.
If you want your custom build to bypass Netlify’s automated function and dependency preparation entirely, your build process needs to result in Node.js ZIP archives in your functions directory. Netlify will deploy these without modification.
To customize the build process, do one of the following:
Include customizations directly in your build command. For example:
rollup hello/function.js
--file
netlify/functions/hello.js
--format
cjs
This example uses Rollup to bundle a specific function.
Invoke scripts through a file called by your build command. For example:
npm
run test:functions
&&
npm
run build
Where
test:functions
is a unit testing script configured in
package.json
. For more information, visit our Forums for a verified Support Guide on
testing your Netlify builds
.
#
External build
For even more control over the handling of your function source files and dependencies, you can bundle ZIP archives outside of Netlify.
If you put your bundled ZIP archives in your functions directory before you push changes to your Git provider, Netlify will deploy these executable artifacts without modification.
Consider CLI deploys instead
It’s not a best practice to track bundling results in Git. So, if you want to bundle your own ZIP archives, we recommend you use
CLI deploys
instead of continuous deployment with Git.
#
Manual deploys with CLI
Netlify CLI can upload files directly from your local project directory to your site on Netlify.
Common use cases for this workflow:
updating a site while
builds are stopped
deploying to Netlify at the end of external CI tool tasks
Prepare your function dependencies before you deploy with the CLI.
Install your dependencies. This enables Netlify CLI to automatically zip dependencies with your functions for deployment.
Follow the
instructions on the CLI page
to deploy your site including your functions.
TypeScript and JavaScript together
If you include TypeScript and JavaScript functions with the same name, for example,
my-function.ts
and
my-function.js
, the TypeScript function is ignored while the JavaScript function is deployed. This allows you to handle TypeScript compilation locally, if preferred. Netlify then bundles and deploys the resulting JavaScript function.
#
File digest deploys with API
Netlify API can upload functions when you use the file digest method for manual deploys.
Common use cases for this workflow:
updating a site while
builds are stopped
automating workflows that connect with other systems
Prepare your functions before you deploy with the API.
Zip each function with its dependencies.
Follow the
instructions on the API page
to deploy your site including executable artifacts for Netlify Functions.
The deployment preparation process includes compiling your Go function files into executable artifacts.
You can use
continuous deployment
, the
Netlify CLI
, or the
Netlify API
to deploy functions.
#
Continuous deployment with Git
With
continuous deployment
, your functions are built if needed and deployed each time you push changes to your Git provider. You can rely on
Netlify’s default automatic build process
, use
your own custom build process on Netlify
, or
build outside of Netlify
.
#
Automatic build
Netlify can automatically detect and build your functions from their source files. This is the most common workflow.
To use this option, follow the Go file naming instructions on the
Lambda compatibility for Functions
page.
#
Custom build
If you want more control over the handling of your function source files, you can use your site’s build command to customize the build process.
Netlify runs your build command before accessing your functions directory to prepare and deploy your functions. This means you can use your build command to override any part of the default preparation process up until the point Netlify deploys executable artifacts.
Here are some examples of customizations you could make to the process:
Detect source files from several different directories.
Run unit tests to validate your functions before they’re deployed.
If you want your custom build to bypass Netlify’s automated function preparation entirely, your build process needs to result in binaries compiled for the
linux
operating system and
amd64
architecture in your functions directory. Netlify will deploy these without modification.
You can customize
go build
in one of the following ways.
Include
go build
directly in your build command. For example:
GOOS
=
linux
GOARCH
=
amd64 go build
-o
netlify/functions/hello ./hello/function.go
&&
GOOS
=
linux
GOARCH
=
amd64 go build
-o
netlify/functions/goodbye ./goodbye/function.go
This example builds source files saved in multiple different directories into compiled binaries in the functions directory for deployment.
Invoke
go build
through a file called by the build command. For example:
npm
run build
&&
npm
run build:function
This example invokes a script stored in
package.json
. Visit the
example repository
to explore the full example.
#
External build
For even more control over the handling of your function source files, you can compile binaries outside of Netlify. The binaries must be compiled for the
linux
operating system and
amd64
architecture. Use the Go compilation environment variables
GOOS
and
GOARCH
to set the compiler targets:
GOOS
=
linux
GOARCH
=
amd64 go build
If you put your compiled binaries in your functions directory before you push changes to your Git provider, Netlify will deploy these executable artifacts without modification.
Consider CLI deploys instead
It’s not a best practice to track compilation results in Git. So, if you want to compile your own binaries, we recommend you use
CLI deploys
instead of continuous deployment with Git.
#
Manual deploys with CLI
Netlify CLI can upload files directly from your local project directory to your site on Netlify.
Common use cases for this workflow:
updating a site while
builds are stopped
deploying to Netlify at the end of external CI tool tasks
Prepare your functions before you deploy with the CLI.
Compile your Go functions to binaries for the
linux
operating system and
amd64
architecture in your functions directory.
GOOS
=
linux
GOARCH
=
amd64 go build
Follow the
instructions on the CLI page
to deploy your site including executable artifacts for Netlify Functions.
#
File digest deploys with API
Netlify API can upload functions when you use the file digest method for manual deploys.
Common use cases for this workflow:
updating a site while
builds are stopped
automating workflows that connect with other systems
Prepare your functions before you deploy with the API.
Compile your Go functions to binaries for the
linux
operating system and
amd64
architecture in your functions directory.
GOOS
=
linux
GOARCH
=
amd64 go build
Follow the
instructions on the API page
to deploy your site including executable artifacts for Netlify Functions.
Last updated: November 1, 2023
←
Environment variables
Logs
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_environment-variables.txt --------
Start of file
URL: https://docs.netlify.com/functions/environment-variables/
Scraped_At: 2025-06-02T19:58:06.184476

Contact
Forums
Contact support
Netlify
environment variables
are accessible when you run Netlify Functions, Edge Functions, and On-demand Builders. This allows you to securely provide sensitive values for your functions to use while they run – values such as API keys and tokens.
This page describes how to create environment variables for functions, the specific read-only variables that are available to functions during runtime, and how to use environment variables within your serverless functions and edge functions.
#
Declare variables
You can
declare and set environment variables
using the Netlify UI, CLI, or API for use with functions. If you have the option to set specific
scopes
for your environment variables, the scope must include
Functions
to be available to functions during runtime.
Note that environment variables declared in a Netlify configuration file (
netlify.toml
) are not available to functions.
Visit the
environment variables overview
to learn more about environment variables at Netlify.
Want to configure your functions? Use build environment variables
This document focuses on how to use environment variables in your functions during runtime. If you need to set specific variables to configure how Netlify builds your functions, leverage
build environment variables
instead.
#
Netlify configuration variables
By setting custom values for certain reserved environment variables, you can change some aspects of your functions.
AWS_LAMBDA_JS_RUNTIME
:
value that sets the
Node.js runtime version for Netlify Functions
. This environment variable must be set using the Netlify UI, CLI, or API, and not with a Netlify configuration file (
netlify.toml
).
#
Netlify read-only variables
While Netlify offers a number of
configuration
and
read-only environment variables
during the build step, only the following read-only variables are available to functions during runtime.
Note that read-only environment variables are reserved in Netlify’s system. You can’t set or override these values manually.
#
Functions
The following read-only environment variables are available to serverless functions (including scheduled functions, background functions, and On-demand Builders):
SITE_NAME
: name of the site, its Netlify subdomain; for example,
petsof
.
SITE_ID
: unique ID for the site; for example,
1d01c0c0-4554-4747-93b8-34ce3448ab95
.
URL
: URL representing the main address to your site. It can be either a Netlify subdomain or your own custom domain if you set one; for example,
https://petsof.netlify.app
or
https://www.petsofnetlify.com
.
Also available are the
read-only, reserved runtime environment variables
provided by AWS.
Note that other Netlify
read-only environment variables
are available when you use
Netlify Dev
to help with local development, but only the above subset are available in all other environments.
#
Edge Functions
The following read-only environment variable is available to edge functions. The variable is provided by
Deno
:
DENO_DEPLOYMENT_ID
: unique Deno ID of the deployment.
You can also leverage the
Context
object
to access read-only information within your edge functions. For example, the
Context
object includes a
server
property with the
region
where the deployment is running and a Netlify-specific
site
property with the site’s
id
,
name
, and
url
.
#
Overrides and limitations
The general environment variable
overrides
and
limitations
apply to environment variables used with functions. Here are some additional limitations to note:
Environment variables declared in a Netlify configuration file (
netlify.toml
) are not available to functions.
Because Netlify Functions are powered by AWS Lambda, AWS’s
environment property limits
apply to environment variables used with Netlify Functions. If you have the option to set specific
scopes
for your environment variables, you can adjust the scope of your variables to avoid hitting these limits.
In addition to Netlify’s
read-only variables
, AWS’s
reserved environment variables
are reserved in Netlify’s system. You can’t create environment variables with a key that’s reserved by a read-only variable. You also can’t set or override these values manually.
Changes to environment variables for functions require a require a build and deploy to take effect.
#
Access environment variables
Once you declare environment variables for the
Functions
scope, you can access them in two different ways depending on if you are using
serverless functions
or
edge functions
. The following sections include examples of how to access these variables during runtime.
Want to use build environment variables in your functions?
Unlike environment variables set for the
Functions
scope,
variables set for the
Build
scope
are only available during the build step for your site. If you would like to use build environment variables in your functions, you’ll need to embed their values into the functions while your site is building. You can write a script to do this or use a plugin like
Netlify Bundle ENV
.
#
Functions
In your serverless functions (including scheduled functions, background functions, and On-demand Builders), use the format
process.env.VARIABLE_NAME
to access environment variables available in the functions scope.
Loading error: Refresh the page to access this code sample
import
type
{
Handler
,
HandlerEvent
,
HandlerContext
}
from
"@netlify/functions"
;
const
handler
:
Handler
=
async
(
event
:
HandlerEvent
,
context
:
HandlerContext
)
=>
{
const
value
=
process
.
env
.
MY_IMPORTANT_VARIABLE
;
return
{
statusCode
:
200
,
body
:
JSON
.
stringify
(
{
message
:
`
Value of MY_IMPORTANT_VARIABLE is
${
value
}
.
`
}
)
,
}
;
}
;
export
{
handler
}
;
exports
.
handler
=
async
function
(
event
,
context
)
{
const
value
=
process
.
env
.
MY_IMPORTANT_VARIABLE
;
return
{
statusCode
:
200
,
body
:
JSON
.
stringify
(
{
message
:
`
Value of MY_IMPORTANT_VARIABLE is
${
value
}
.
`
}
)
,
}
;
}
;
#
Edge Functions
Netlify provides environment variables to edge functions using the
Netlify.env
API.
get(key)
:
get the value of an environment variable
toObject()
:
get all environment variables as an object
Note that you can’t use the
Netlify.env.set
and
Netlify.env.delete
methods to update environment variables from within edge functions. Instead, use the Netlify
env
API endpoints
.
You can also leverage the Netlify-specific
context object
to access read-only information within your edge functions.
Loading error: Refresh the page to access this code sample
import
type
{
Context
}
from
"@netlify/edge-functions"
;
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
const
value
=
Netlify
.
env
.
get
(
"MY_IMPORTANT_VARIABLE"
)
;
return
new
Response
(
`
Value of MY_IMPORTANT_VARIABLE for
${
context
.
site
.
name
}
is
${
value
}
.
`
,
{
headers
:
{
"content-type"
:
"text/html"
}
,
}
)
;
}
;
export
default
async
(
request
,
context
)
=>
{
const
value
=
Netlify
.
env
.
get
(
"MY_IMPORTANT_VARIABLE"
)
;
return
new
Response
(
`
Value of MY_IMPORTANT_VARIABLE for
${
context
.
site
.
name
}
is
${
value
}
.
`
,
{
headers
:
{
"content-type"
:
"text/html"
}
,
}
)
;
}
;
Using Edge Functions for Middleware with Next.js? Use
process.env
If you’re using Netlify
Edge Functions for Middleware
with your Next.js site, you can also use
process.env
to access environment variables.
#
More environment variables and functions resources
Environment variables overview
Build environment variables
Edge Functions example: Use environment variables
Verified Support Guide on
using an SSH key via environment variables during build
Netlify blog: How to use really long environment variables in Netlify Functions
Last updated: November 6, 2024
←
Scheduled Functions
Deploy
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_functions-and-identity.txt --------
Start of file
URL: https://docs.netlify.com/functions/functions-and-identity/
Scraped_At: 2025-06-02T19:58:07.016020

Contact
Forums
Contact support
Netlify Identity is deprecated
Netlify Identity service and the underlying
GoTrue
API are
deprecated
. While Identity and GoTrue continue to function for sites that currently have them enabled, new Identity or GoTrue configurations are not recommended. While we will keep fixing any major security issues that arise, we will no longer fix bugs in the functionality of Identity or GoTrue.
For help migrating, existing users can reach out to
Support
to help you export a list of your users
For an alternative to Netlify Identity, we suggest using Auth0. Learn more in our
Auth0 extension docs
.
For an alternative to GoTrue, we suggest
Supabase Auth
, which is an actively maintained fork of GoTrue.
If you have
Identity
enabled on your site, your serverless functions get access to the Identity instance and to Identity user claims in the
context
object. You can also trigger functions from Identity events.
#
Access Identity info with clientContext
If an Identity service is active for a site, functions running on that site have access to an
identity
and a
user
object in Netlify’s base64-encoded custom
clientContext
. You can access the client context with TypeScript or JavaScript like this:
Loading error: Refresh the page to access this code sample
import
type
{
Handler
,
HandlerEvent
,
HandlerContext
}
from
"@netlify/functions"
;
const
handler
:
Handler
=
async
function
(
event
:
HandlerEvent
,
context
:
HandlerContext
)
{
const
rawNetlifyContext
=
context
.
clientContext
.
custom
.
netlify
;
const
netlifyContext
=
Buffer
.
from
(
rawNetlifyContext
,
'base64'
)
.
toString
(
'utf-8'
)
;
const
{
identity
,
user
}
=
JSON
.
parse
(
netlifyContext
)
;
// Do stuff and return a response...
}
;
export
{
handler
}
;
exports
.
handler
=
async
function
(
event
,
context
)
{
const
rawNetlifyContext
=
context
.
clientContext
.
custom
.
netlify
;
const
netlifyContext
=
Buffer
.
from
(
rawNetlifyContext
,
'base64'
)
.
toString
(
'utf-8'
)
;
const
{
identity
,
user
}
=
JSON
.
parse
(
netlifyContext
)
;
// Do stuff and return a response...
}
;
Visit our docs on
Go functions
to learn how to access the
clientContext
with Go.
The
user
object is present if the function request has an
Authorization: Bearer <token>
header with a valid JWT from the Identity instance. In this case the object will contain the decoded claims.
The
identity
object has
url
and
token
attributes. The URL is the endpoint for the underlying
GoTrue
API powering the Identity service. The
token
attribute is a short-lived admin token that can be used to make requests as an admin to the GoTrue API.
#
Trigger functions on Identity events
You can
trigger function calls
when certain Identity events happen, like when a user signs up. The following events are currently available:
identity-validate
: Triggered when an Identity user tries to sign up with Identity.
identity-signup
: Triggered when an Identity user signs up with Netlify Identity and confirms their email address. Note that this fires for email+password signups only, not for signups using external providers such as Google or GitHub.
identity-login
: Triggered when an Identity user logs in with Netlify Identity
To set a synchronous function to trigger on one of these events, match the name of the function file to the name of the event. For example, to trigger a function on
identity-login
events, name the function file
identity-login.ts
.
To trigger a
background function
on one of the Identity events, include the event name in the function file name. For example, to trigger a background function on
identity-login
events, name the function file
identity-login-background.ts
.
If you return a status other than
200
,
202
, or
204
from one of these event functions, the signup or login will be blocked.
The payload in the body of an Identity event function is formatted like:
{
"event"
:
"login|signup|validate"
,
"user"
:
{
# an Identity user object
}
}
If your function returns a
200
, you can also return a JSON object with new
user_metadata
or
app_metadata
for the Identity user. For example:
Loading error: Refresh the page to access this code sample
import
type
{
Handler
,
HandlerEvent
}
from
"@netlify/functions"
;
export
async
function
handler
(
event
:
HandlerEvent
)
:
Handler
{
const
user
=
JSON
.
parse
(
event
.
body
)
.
user
;
return
{
body
:
JSON
.
stringify
(
{
...
user
,
app_metadata
:
{
...
user
.
app_metadata
,
roles
:
[
"admin"
]
,
}
,
}
)
,
statusCode
:
200
,
}
;
}
export
async
function
handler
(
event
)
{
const
user
=
JSON
.
parse
(
event
.
body
)
.
user
;
return
{
body
:
JSON
.
stringify
(
{
...
user
,
app_metadata
:
{
...
user
.
app_metadata
,
roles
:
[
"admin"
]
,
}
,
}
)
,
statusCode
:
200
,
}
;
}
This function replaces the value of the Identity user’s
app_metadata
to give them the
admin
role.
Last updated: February 28, 2025
←
Trigger on events
Background Functions
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_get-started.txt --------
Start of file
URL: https://docs.netlify.com/functions/get-started/?fn-language=ts
Scraped_At: 2025-06-02T19:58:09.027163

Contact
Forums
Contact support
This page will help you get started with Functions. It describes how to write your functions and route requests to them.
Choose your programming language:
TypeScript
JavaScript
Go
TypeScript
JavaScript
Go
#
Prepare project
Start by adding the
@netlify/functions
module to your project, which exports all the types you need to create type-safe functions.
npm
install
@netlify/functions
You don’t need any additional tooling or configuration to use TypeScript functions, but you can choose to provide your own
tsconfig.json
file
if you want to extend the base configuration in order to
rewrite import paths
, for example.
Our build system will load any
tsconfig.json
files from your functions directory, the repository root directory, or the
base directory
, if set.
#
Create function file
To add a serverless function to your project, create a TypeScript file in
your functions directory
.
You can store your function file directly under the functions directory or in a subdirectory dedicated to the function. If you choose a subdirectory, the function entry file must be named
index
or have the same name as the subdirectory.
For example, any of the following files would create a function called
hello
:
netlify/functions/hello.mts
netlify/functions/hello/hello.mts
netlify/functions/hello/index.mts
Using ES modules
Naming your function with the
.mts
extension lets you use the modern
ES modules syntax
. To learn more about the different module formats, refer to
runtime
.
#
Write a function
A function file must be written using the
JavaScript modules
syntax and have a
default export
with a handler function.
The handler function receives the following arguments:
A web platform
Request
object
that represents the incoming HTTP request
A Netlify-specific
context
object
with metadata related to the client and the site
For synchronous functions, the return value of the handler function may be used as the HTTP response to be delivered to the client.
#
Synchronous function
A synchronous function lets you implement a traditional client/server interaction, where the connection is kept open until the function execution is finished, allowing the client to wait for a response before rendering a page or moving on to the next task.
The handler function should return a
Response
object
representing the HTTP response to be delivered to the client, including any
caching headers
you want to set. If no value is returned, the client will receive an empty response with a 204 status code.
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
return
new
Response
(
"Hello, world!"
)
}
You can also use
context.waitUntil
to handle background tasks without delaying the response. This is useful for logging, analytics, or other operations that don’t need to block the client.
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
context
.
waitUntil
(
logRequest
(
req
)
)
;
return
new
Response
(
"Hello, world!"
)
;
}
;
async
function
logRequest
(
req
:
Request
)
{
await
fetch
(
"https://example.com/log"
,
{
method
:
"POST"
,
body
:
JSON
.
stringify
(
{
url
:
req
.
url
,
timestamp
:
Date
.
now
(
)
}
)
,
headers
:
{
"Content-Type"
:
"application/json"
}
,
}
)
;
}
Synchronous functions can stream data to clients as it becomes available, rather than returning a buffered payload at the end of the computation. This lets developers and frameworks create faster experiences by using streaming and partial hydration to get content and interactions in front of people as quickly as possible.
To stream a function’s response, return a
ReadableStream
as the
body
property of the
Response
object.
Examples
Loading error: Refresh the page to access this code sample
export
default
async
(
)
=>
{
const
encoder
=
new
TextEncoder
(
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
"en"
,
{
timeStyle
:
"medium"
}
)
;
const
body
=
new
ReadableStream
(
{
start
(
controller
)
{
controller
.
enqueue
(
encoder
.
encode
(
"<html><body><ol>"
)
)
;
let
i
=
0
;
const
timer
=
setInterval
(
(
)
=>
{
controller
.
enqueue
(
encoder
.
encode
(
`
<li>Hello at
${
formatter
.
format
(
new
Date
(
)
)
}
</li>\n\n
`
)
)
;
if
(
i
++
>=
5
)
{
controller
.
enqueue
(
encoder
.
encode
(
"</ol></body></html>"
)
)
;
controller
.
close
(
)
;
clearInterval
(
timer
)
;
}
}
,
1000
)
;
}
}
)
;
return
new
Response
(
body
)
;
}
;
export
default
async
(
)
=>
{
// Get the request from the request query string, or use a default
const
pie
=
event
.
queryStringParameters
?.
pie
??
"something inspired by a springtime garden"
;
// The response body returned from "fetch" is a "ReadableStream",
// so you can return it directly in your streaming response
const
res
=
await
fetch
(
"https://api.openai.com/v1/chat/completions"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/json"
,
// Set this environment variable to your own key
Authorization
:
`
Bearer
${
process
.
env
.
OPENAI_API_KEY
}
`
}
,
body
:
JSON
.
stringify
(
{
model
:
"gpt-3.5-turbo"
,
messages
:
[
{
role
:
"system"
,
content
:
"You are a baker. The user will ask you for a pie recipe. You will respond with the recipe. Use markdown to format your response"
}
,
// Use "slice" to limit the length of the input to 500 characters
{
role
:
"user"
,
content
:
pie
.
slice
(
0
,
500
)
}
]
,
// Use server-sent events to stream the response
stream
:
true
}
)
}
)
;
return
new
Response
(
body
,
{
headers
:
{
// This is the mimetype for server-sent events
"content-type"
:
"text/event-stream"
}
}
)
;
}
;
import
Groq
from
"groq-sdk"
;
const
client
=
new
Groq
(
{
apiKey
:
process
.
env
.
GROQ_API_KEY
}
)
;
export
default
async
(
)
=>
{
// Get the request from the request query string, or use a default
const
pie
=
event
.
queryStringParameters
?.
pie
??
"something inspired by a springtime garden"
;
// Create a transcription job
const
stream
=
await
client
.
chat
.
completions
.
create
(
{
// The language model which will generate the completion.
model
:
"llama3-8b-8192"
,
messages
:
[
{
role
:
"system"
,
content
:
"You are a baker. The user will ask you for a pie recipe. You will respond with the recipe. Use markdown to format your response"
}
,
// Use "slice" to limit the length of the input to 500 characters
{
role
:
"user"
,
content
:
pie
.
slice
(
0
,
500
)
}
]
,
//
// Optional parameters
//
// Controls randomness: lowering results in less random completions.
// As the temperature approaches zero, the model will become deterministic
// and repetitive.
temperature
:
0.5
,
// The maximum number of tokens to generate. Requests can use up to
// 2048 tokens shared between prompt and completion.
max_tokens
:
1024
,
// Controls diversity via nucleus sampling: 0.5 means half of all
// likelihood-weighted options are considered.
top_p
:
1
,
// A stop sequence is a predefined or user-specified text string that
// signals an AI to stop generating content, ensuring its responses
// remain focused and concise. Examples include punctuation marks and
// markers like "[end]".
stop
:
null
,
// If set, partial message deltas will be sent.
stream
:
true
}
)
;
// Wrap the Stream<ChatCompletionChunk> in a ReadableStream
const
readableStream
=
new
ReadableStream
(
{
async
start
(
controller
)
{
for
await
(
const
chunk
of
stream
)
{
// Enqueue the chunk into the ReadableStream
controller
.
enqueue
(
new
TextEncoder
(
)
.
encode
(
chunk
.
choices
[
0
]
?.
delta
?.
content
||
""
)
)
;
}
controller
.
close
(
)
;
// Close the stream when it's done
}
}
)
;
return
new
Response
(
readableStream
,
{
headers
:
{
// This is the mimetype for server-sent events
"content-type"
:
"text/event-stream"
}
}
)
;
}
;
When returning a stream, keep the following limitations in mind:
10 second execution limit. If the limit is reached, the response stops streaming.
20 MB response size limit. Responses larger than 20 MB cannot be streamed.
#
Background function
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
With background functions, the function invocation is placed into a queue and the client connection is terminated immediately. This pattern lets you perform longer-running operations without forcing clients to wait for a response.
The handler function does not need to return anything, as the client will always receive an empty response with a 202 status code. Any response returned by the handler function will be ignored.
import
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
await
someLongRunningTask
(
)
;
console
.
log
(
"Done"
)
;
}
;
To define a background function, the name of the function needs to have a
-background
suffix (for example,
netlify/functions/hello-background.mts
or
netlify/functions/hello-background/index.mts
).
#
Route requests
Netlify automatically creates a dedicated endpoint for every function you create, using the format
https://<YOUR DOMAIN>/.netlify/functions/<FUNCTION NAME>
.
Additionally, you can configure the function to run on any path of your choice by defining a
path
property in the
config
export of your function.
import
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
{
city
,
country
}
=
context
.
params
;
return
new
Response
(
`
You're visiting
${
city
}
in
${
country
}
!
`
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/travel-guide/:city/:country"
}
;
You can choose to run a function on one or more URL paths. To configure multiple paths, set the
path
property as an array.
import
{
Config
}
from
"@netlify/functions"
;
export
const
config
:
Config
=
{
path
:
[
"/cats"
,
"/dogs"
]
}
;
You can leverage
the
URLPattern
syntax from the web platform
to define wildcards and named groups, which are matched against the incoming request URL and exposed to the function in the
context.params
object.
import
{
Config
}
from
"@netlify/functions"
;
export
const
config
:
Config
=
{
path
:
[
"/sale/*"
,
"/item/:sku"
]
}
;
When needed, use
excludedPath
as an optional
URLPattern
exclusion to limit the routes matched by
path
. Must also start with
/
, for example
excludedPath = "/*.css"
. Accepts a single string or an array of strings.
import
{
Config
}
from
"@netlify/functions"
;
export
const
config
:
Config
=
{
path
:
"/product/*"
,
excludedPath
:
[
"/product/*.css"
,
"/product/*.js"
]
}
By default, a function runs for any requests to its configured paths regardless of whether or not static assets exist on those paths. To prevent the function from shadowing files on the CDN, set
preferStatic
to
true
.
import
{
Config
}
from
"@netlify/functions"
;
export
const
config
:
Config
=
{
path
:
[
"/product/:sku"
,
"/item/:sku"
]
,
preferStatic
:
true
}
;
#
Environment variables
Netlify Functions have access to environment variables in the runtime environment via the
Netlify.env
global object.
import
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
requestKey
=
req
.
headers
.
get
(
"X-API-Key"
)
;
const
apiKey
=
Netlify
.
env
.
get
(
"MY_API_KEY"
)
;
if
(
requestKey
===
apiKey
)
{
return
new
Response
(
"Welcome!"
)
;
}
return
new
Response
(
"Sorry, no access for you."
,
{
status
:
401
}
)
;
}
;
If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to functions during runtime.
You can also leverage
build environment variables
to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.
Learn more about how to set and use
environment variables with functions
.
#
Runtime
Netlify Functions run in
Node.js
, using the version
configured for your site
. Node.js version 18.0.0 is the minimum version required because functions use the
standard Fetch API
, which was only added natively to Node.js in version 18.0.0.
#
Module format
Node.js supports two distinct module formats with different capabilities and APIs:
ECMAScript modules
(or ES modules), an official standard format for JavaScript packages, and
CommonJS
, a legacy format specific to Node.js.
The module format for each function will be determined by the file extension of its entry file:
Functions with the
.mts
extension are always executed as ES modules
Functions with the
.cts
extension are always executed as CommonJS
Functions with the
.ts
extension are executed as ES modules if the closest
package.json
file has a
type
property with the value
module
; otherwise they are executed as CommonJS
Choosing a module format has implications on how you write your function, especially when it comes to importing npm packages:
CommonJS functions cannot use a static
import
to load npm packages written as ES modules and must use a
dynamic import
ES modules functions cannot use named imports (for example,
import { kebabCase } from "lodash"
) when referencing npm packages written in CommonJS, and should instead use a default import (for example,
import _ from "lodash"
)
In ES modules, Node.js built-in primitives like
__dirname
and
__filename
are not available and should be replaced with
import.meta.url
Prefer ES modules
Unless you have strong reasons to prefer CommonJS, we recommend that you choose ES modules, since it’s a modern, standard, forward-looking format. Since it’s also used in
Edge Functions
, using this format will make your code interoperable between the two function types.
#
Lambda compatibility
Netlify Functions support an alternative API surface that is compatible with
AWS Lambda
. This may be useful if you’re looking to migrate Lambda workflows into Netlify with minimal refactoring required.
To opt-in, your handler function must be exported using a
handler
named export.
import
type
{
Handler
}
from
"@netlify/functions"
;
export
const
handler
:
Handler
=
async
(
event
,
context
)
=>
{
return
{
body
:
JSON
.
stringify
(
{
message
:
"Hello World"
}
)
,
statusCode
:
200
,
}
}
For more information about this API, refer to
Lambda compatibility
.
#
Test locally
To streamline writing and testing your functions on Netlify, run a local development environment with
Netlify Dev
. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The
netlify dev
command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.
By default, the
geo
location used is the location of your local environment. To override this to a default mock location of San Francisco, CA, USA, use the
--geo=mock
flag. To mock a specific country, use
--geo=mock --country=
with a two-letter country code. For more information about the
--geo
flag, visit the
CLI docs
.
#
Next steps
Push your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about
other workflows for deploying your functions
including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.
Monitor function
logs
and
metrics
in the Netlify UI to observe and help troubleshoot your deployed functions.
Netlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the
Netlify CLI
.
#
Create function file
To add a serverless function to your project, create a JavaScript file in
your functions directory
following the instructions below for naming and coding your function. Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function.
You can store your function file directly under the functions directory or in a subdirectory dedicated to the function. If you choose a subdirectory, the function entry file must be named
index
or have the same name as the subdirectory.
For example, any of the following files would create a function called
hello
:
netlify/functions/hello.mjs
netlify/functions/hello/hello.mjs
netlify/functions/hello/index.mjs
Using ES modules
Naming your function with the
.mjs
extension lets you use the modern
ES modules syntax
. To learn more about the different module formats, refer to
runtime
.
#
Write a function
A function file must be written using the
JavaScript modules
syntax and have a
default export
with a handler function.
The handler function receives the following arguments:
A web platform
Request
object
that represents the incoming HTTP request
A Netlify-specific
context
object
with metadata related to the client and the site
For synchronous functions, the return value of the handler function may be used as the HTTP response to be delivered to the client.
#
Synchronous function
A synchronous function lets you implement a traditional client/server interaction, where the connection is kept open until the function execution is finished, allowing the client to wait for a response before rendering a page or moving on to the next task.
The handler function should return a
Response
object
representing the HTTP response to be delivered to the client. If no value is returned, the client will receive an empty response with a 204 status code.
export
default
async
(
req
,
context
)
=>
{
return
new
Response
(
"Hello, world!"
)
;
}
;
Synchronous functions can stream data to clients as it becomes available, rather than returning a buffered payload at the end of the computation. This lets developers and frameworks create faster experiences by using streaming and partial hydration to get content and interactions in front of people as quickly as possible.
To stream a function’s response, return a
ReadableStream
as the
body
property of the
Response
object.
Examples
Loading error: Refresh the page to access this code sample
export
default
async
(
)
=>
{
const
encoder
=
new
TextEncoder
(
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
"en"
,
{
timeStyle
:
"medium"
}
)
;
const
body
=
new
ReadableStream
(
{
start
(
controller
)
{
controller
.
enqueue
(
encoder
.
encode
(
"<html><body><ol>"
)
)
;
let
i
=
0
;
const
timer
=
setInterval
(
(
)
=>
{
controller
.
enqueue
(
encoder
.
encode
(
`
<li>Hello at
${
formatter
.
format
(
new
Date
(
)
)
}
</li>\n\n
`
)
)
;
if
(
i
++
>=
5
)
{
controller
.
enqueue
(
encoder
.
encode
(
"</ol></body></html>"
)
)
;
controller
.
close
(
)
;
clearInterval
(
timer
)
;
}
}
,
1000
)
;
}
}
)
;
return
new
Response
(
body
)
;
}
;
export
default
async
(
)
=>
{
// Get the request from the request query string, or use a default
const
pie
=
event
.
queryStringParameters
?.
pie
??
"something inspired by a springtime garden"
;
// The response body returned from "fetch" is a "ReadableStream",
// so you can return it directly in your streaming response
const
res
=
await
fetch
(
"https://api.openai.com/v1/chat/completions"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/json"
,
// Set this environment variable to your own key
Authorization
:
`
Bearer
${
process
.
env
.
OPENAI_API_KEY
}
`
}
,
body
:
JSON
.
stringify
(
{
model
:
"gpt-3.5-turbo"
,
messages
:
[
{
role
:
"system"
,
content
:
"You are a baker. The user will ask you for a pie recipe. You will respond with the recipe. Use markdown to format your response"
}
,
// Use "slice" to limit the length of the input to 500 characters
{
role
:
"user"
,
content
:
pie
.
slice
(
0
,
500
)
}
]
,
// Use server-sent events to stream the response
stream
:
true
}
)
}
)
;
return
new
Response
(
body
,
{
headers
:
{
// This is the mimetype for server-sent events
"content-type"
:
"text/event-stream"
}
}
)
;
}
;
When returning a stream, keep the following limitations in mind:
10 second execution limit. If the limit is reached, the response stops streaming.
20 MB response size limit. Responses larger than 20 MB cannot be streamed.
#
Background function
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
With background functions, the function invocation is placed into a queue and the client connection is terminated immediately. This pattern lets you perform longer-running operations without forcing clients to wait for a response.
The handler function does not need to return anything, as the client will always receive an empty response with a 202 status code. Any response returned by the handler function will be ignored.
export
default
async
(
req
,
context
)
=>
{
await
someLongRunningTask
(
)
;
console
.
log
(
"Done"
)
;
}
;
To define a background function, the name of the function needs to have a
-background
suffix (for example,
netlify/functions/hello-background.mjs
or
netlify/functions/hello-background/index.mjs
).
#
Route requests
Netlify automatically creates a dedicated endpoint for every function you create, using the format
https://<YOUR DOMAIN>/.netlify/functions/<FUNCTION NAME>
.
Additionally, you can configure the function to run on any path of your choice by defining a
path
property in the
config
export of your function.
export
default
async
(
req
,
context
)
=>
{
const
{
city
,
country
}
=
context
.
params
;
return
new
Response
(
`
You're visiting
${
city
}
in
${
country
}
!
`
)
;
}
;
export
const
config
=
{
path
:
"/travel-guide/:city/:country"
}
;
You can choose to run a function on one or more URL paths. To configure multiple paths, set the
path
property as an array.
export
const
config
=
{
path
:
[
"/cats"
,
"/dogs"
]
}
;
You can leverage
the
URLPattern
syntax from the web platform
to define wildcards and named groups, which are matched against the incoming request URL and exposed to the function in the
context.params
object.
export
const
config
=
{
path
:
[
"/sale/*"
,
"/item/:sku"
]
}
;
When needed, use
excludedPath
as an optional
URLPattern
exclusion to limit the routes matched by
path
. Must also start with
/
, for example
excludedPath = "/*.css"
. Accepts a single string or an array of strings.
export
const
config
=
{
path
:
"/product/*"
,
excludedPath
:
[
"/product/*.css"
,
"/product/*.js"
]
}
By default, a function runs for any requests to its configured paths regardless of whether or not static assets exist on those paths. To prevent the function from shadowing files on the CDN, set
preferStatic
to
true
.
export
const
config
=
{
path
:
[
"/product/:sku"
,
"/item/:sku"
]
,
preferStatic
:
true
}
;
#
Environment variables
Netlify Functions have access to environment variables in the runtime environment via the
Netlify.env
global object.
export
default
async
(
req
,
context
)
=>
{
const
requestKey
=
req
.
headers
.
get
(
"X-API-Key"
)
;
const
apiKey
=
Netlify
.
env
.
get
(
"MY_API_KEY"
)
;
if
(
requestKey
===
apiKey
)
{
return
new
Response
(
"Welcome!"
)
;
}
return
new
Response
(
"Sorry, no access for you."
,
{
status
:
401
}
)
;
}
;
If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to functions during runtime.
You can also leverage
build environment variables
to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.
Learn more about how to set and use
environment variables with functions
.
#
Runtime
Netlify Functions run in
Node.js
, using the version
configured for your site
. Node.js version 18.0.0 is the minimum version required because functions use the
standard Fetch API
, which was only added natively to Node.js in version 18.0.0.
#
Module format
Node.js supports two distinct module formats with different capabilities and APIs:
ECMAScript modules
(or ES modules), an official standard format for JavaScript packages, and
CommonJS
, a legacy format specific to Node.js.
The module format for each function will be determined by the file extension of its entry file:
Functions with the
.mjs
extension are always executed as ES modules
Functions with the
.cjs
extension are always executed as CommonJS
Functions with the
.js
extension are executed as ES modules if the closest
package.json
file has a
type
property with the value
module
; otherwise they are executed as CommonJS
Choosing a module format has implications on how you write your function, especially when it comes to importing npm packages:
CommonJS functions cannot use a static
import
to load npm packages written as ES modules and must use a
dynamic import
ES modules functions cannot use named imports (for example,
import { kebabCase } from "lodash"
) when referencing npm packages written in CommonJS, and should instead use a default import (for example,
import _ from "lodash"
)
In ES modules, Node.js built-in primitives like
__dirname
and
__filename
are not available and should be replaced with
import.meta.url
Prefer ES modules
Unless you have strong reasons to prefer CommonJS, we recommend that you choose ES modules, since it’s a modern, standard, forward-looking format. Since it’s also used in
Edge Functions
, using this format will make your code interoperable between the two function types.
#
Lambda compatibility
Netlify Functions support an alternative API surface that is compatible with
AWS Lambda
. This may be useful if you’re looking to migrate Lambda workflows into Netlify with minimal refactoring required.
To opt-in, your handler function must be exported using a
handler
named export.
export
const
handler
:
Handler
=
async
(
event
,
context
)
=>
{
return
{
body
:
JSON
.
stringify
(
{
message
:
"Hello World"
}
)
,
statusCode
:
200
}
;
}
;
For more information about this API, refer to
Lambda compatibility
.
#
Test locally
To streamline writing and testing your functions on Netlify, run a local development environment with
Netlify Dev
. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The
netlify dev
command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.
By default, the
geo
location used is the location of your local environment. To override this to a default mock location of San Francisco, CA, USA, use the
--geo=mock
flag. To mock a specific country, use
--geo=mock --country=
with a two-letter country code. For more information about the
--geo
flag, visit the
CLI docs
.
#
Next steps
Push your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about
other workflows for deploying your functions
including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.
Monitor function
logs
and
metrics
in the Netlify UI to observe and help troubleshoot your deployed functions.
Netlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the
Netlify CLI
.
#
Use the Lambda-compatible API for Go
To write functions in Go, use the
Lambda-compatible functions API
.
Last updated: March 20, 2025
←
Overview
API
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_lambda-compatibility.txt --------
Start of file
URL: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=ts
Scraped_At: 2025-06-02T19:58:15.177741

Contact
Forums
Contact support
Upgrading from Lambda compatibility mode
If you’re using this mode, consider upgrading to get access to the full context object below. Learn more in our
blog on functions 2.0
.
Choose your programming language:
TypeScript
JavaScript
Go
TypeScript
JavaScript
Go
#
Prepare project
Before creating a TypeScript function, prepare your project by doing the following:
Add the
@netlify/functions
module to your project to import typings for TypeScript.
npm
install
@netlify/functions
Set up
tsconfig.json
. We recommend that you enable the properties
esModuleInterop
and
verbatimModuleSyntax
in your TypeScript configuration file for better compatibility. During the build process, Netlify automatically loads any
tsconfig.json
configuration files found in your functions directory, the repository root directory, or the
base directory
, if set.
#
Create function file
To add a serverless function to your project, create a TypeScript file in your functions directory following the instructions below for naming and coding your function. Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function.
The default functions directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can optionally
configure a custom functions directory
.
#
Name your function
You can store your function file directly under the functions directory or in a subdirectory dedicated to the function. The function’s endpoint name is case-sensitive and determined by its filename or the name of its dedicated parent directory.
For example, to create a function with an endpoint name of
hello
, save the function file in one of the following ways:
netlify/functions/hello.ts
netlify/functions/hello/hello.ts
netlify/functions/hello/index.ts
These formats would deploy a synchronous function that can be called on the following endpoint:
/.netlify/functions/hello
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello
for a site using a custom domain.
To create a
background function
, append the function name with
-background
. For example, to create a background function with an endpoint name of
hello-background
, save the function file in one of these ways:
netlify/functions/hello-background.ts
netlify/functions/hello-background/hello-background.ts
netlify/functions/hello-background/index.ts
These formats would deploy a background function that can be called on the following endpoint:
/.netlify/functions/hello-background
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello-background
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello-background
for a site using a custom domain.
Reserved names for event-driven functions
Certain function names are reserved as triggers initiated by various built-in events on your Netlify site. You can find a list of these function names and how they work on the page about
event-driven functions
.
#
Code your function
This section will help you learn how to write functions. It covers the syntax for
synchronous functions
, both buffered and
streaming
, as well as
background functions
.
#
Synchronous function format
To create a synchronous function, use the following general syntax in your TypeScript function file to export a
handler
method:
import
type
{
Handler
,
HandlerEvent
,
HandlerContext
}
from
"@netlify/functions"
;
const
handler
:
Handler
=
async
(
event
:
HandlerEvent
,
context
:
HandlerContext
)
=>
{
// your server-side functionality
}
;
export
{
handler
}
;
Import types before declaring the function.
If you import the
Handler
type as demonstrated in the previous code sample, the
event
and
context
arguments and the response are typed accordingly.
Alternatively, you can import the types
HandlerEvent
,
HandlerContext
, and
HandlerResponse
separately and use them to construct a
handler
function.
Netlify provides the
event
and
context
parameters when the function is invoked.
The
event
object received by the
handler
is similar to the following:
{
"path"
:
"Path parameter (original URL encoding)"
,
"httpMethod"
:
"Incoming request’s method name"
,
"headers"
:
{
Incoming request headers
}
,
"queryStringParameters"
:
{
Query string parameters
}
,
"body"
:
"A JSON string of the request payload"
,
"isBase64Encoded"
:
"A boolean flag to indicate if the applicable request payload is Base64-encoded"
}
If you need to parse a
multipart/form-data
-encoded
event.body
, we recommend using
busboy
. To learn more, visit our blog article on
processing multipart form data with Netlify Functions
.
The
context
object received by the
handler
includes information about the context in which the function was called, like certain
Identity user information
, for example.
Here’s a basic example function,
hello.ts
:
import
type
{
Handler
,
HandlerEvent
,
HandlerContext
}
from
"@netlify/functions"
;
const
handler
:
Handler
=
async
(
event
:
HandlerEvent
,
context
:
HandlerContext
)
=>
{
return
{
statusCode
:
200
,
body
:
JSON
.
stringify
(
{
message
:
"Hello World"
}
)
,
}
;
}
;
export
{
handler
}
;
This function deploys to an endpoint at
/.netlify/functions/hello
relative to the base URL of your site.
A successful invocation returns the
200
status code and the string, “Hello, World”.
Synchronous functions can return a response object that includes the following information:
{
"isBase64Encoded"
:
true
|
false
,
"statusCode"
:
httpStatusCode
,
"headers"
:
{
"headerName"
:
"headerValue"
,
...
}
,
"multiValueHeaders"
:
{
"headerName"
:
[
"headerValue"
,
"headerValue2"
,
...
]
,
...
}
,
"body"
:
"..."
}
Because
async
function code returns a
promise
, we recommend returning a response with at least an HTTP status code instead of allowing the function to time out. Using
async
in your function code doesn’t automatically designate a function as a background function.
#
Response streaming
This feature is in
Beta
.
Netlify Functions can stream data to clients as it becomes available, rather than returning a buffered payload at the end of the computation. This lets developers and frameworks create faster experiences by using streaming and partial hydration to get content and interactions in front of people as quickly as possible.
To stream a function’s response:
wrap your
handler
export with the
stream
decorator
return a
ReadableStream
as the
body
Here’s a simplified example that you can use to test that your function response streams to the client:
import
{
stream
}
from
"@netlify/functions"
;
export
const
handler
=
stream
(
async
(
)
=>
{
const
encoder
=
new
TextEncoder
(
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
"en"
,
{
timeStyle
:
"medium"
}
)
;
const
body
=
new
ReadableStream
(
{
start
(
controller
)
{
controller
.
enqueue
(
encoder
.
encode
(
"<html><body><ol>"
)
)
;
let
i
=
0
;
const
timer
=
setInterval
(
(
)
=>
{
controller
.
enqueue
(
encoder
.
encode
(
`
<li>Hello at
${
formatter
.
format
(
new
Date
(
)
)
}
</li>\n\n
`
)
)
;
if
(
i
++
>=
5
)
{
controller
.
enqueue
(
encoder
.
encode
(
"</ol></body></html>"
)
)
;
controller
.
close
(
)
;
clearInterval
(
timer
)
;
}
}
,
1000
)
;
}
}
)
;
return
{
headers
:
{
"content-type"
:
"text/html"
}
,
statusCode
:
200
,
body
}
;
}
)
;
For an extended example that demonstrates a more likely response streaming use case, consider this function:
import
{
stream
}
from
"@netlify/functions"
;
export
const
handler
=
stream
(
async
event
=>
{
// Get the request from the request query string, or use a default
const
pie
=
event
.
queryStringParameters
?.
pie
??
"something inspired by a springtime garden"
;
// The response body returned from "fetch" is a "ReadableStream",
// so you can return it directly in your streaming response
const
res
=
await
fetch
(
"https://api.openai.com/v1/chat/completions"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/json"
,
// Set this environment variable to your own key
Authorization
:
`
Bearer
${
process
.
env
.
OPENAI_API_KEY
}
`
}
,
body
:
JSON
.
stringify
(
{
model
:
"gpt-3.5-turbo"
,
messages
:
[
{
role
:
"system"
,
content
:
"You are a baker. The user will ask you for a pie recipe. You will respond with the recipe. Use markdown to format your response"
}
,
// Use "slice" to limit the length of the input to 500 characters
{
role
:
"user"
,
content
:
pie
.
slice
(
0
,
500
)
}
]
,
// Use server-sent events to stream the response
stream
:
true
}
)
}
)
;
return
{
headers
:
{
// This is the mimetype for server-sent events
"content-type"
:
"text/event-stream"
}
,
statusCode
:
200
,
// Pipe the event stream from OpenAI to the client
body
:
res
.
body
}
;
}
)
;
When invoked this function sends a prompt to OpenAI and streams the response back to the client like a chatbot.
Keep the following limitations in mind when working with streaming functions:
10 second execution limit. If the limit is reached, the response stops streaming.
20 MB response size limit. Responses larger than 20 MB cannot be streamed.
Background Functions can’t stream responses.
On-demand Builders can’t stream responses.
Scheduled Functions can’t stream responses.
#
Background function format
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
To create a
background function
, append the function name with
-background
. For example,
netlify/functions/hello-background.ts
or
netlify/functions/hello-background/index.ts
.
Background function syntax is similar to synchronous function syntax with a couple of key differences:
You will generally pass the function result to a destination other than the originating client.
Background functions don’t support response streaming because they don’t return responses.
Like the
synchronous function format
, each TypeScript file to be deployed as a background function must import types and export a
handler
method. As with synchronous function invocation, Netlify provides the
event
and
context
parameters when a background function is invoked. Although background functions rely on asynchronous invocation, they don’t require the use of
async
TypeScript syntax.
Here’s a simplified example background function that you can use to test that your function runs longer than 30 seconds,
count-background.ts
:
import
type
{
BackgroundHandler
,
HandlerEvent
,
HandlerContext
}
from
"@netlify/functions"
;
export
const
handler
:
BackgroundHandler
=
(
event
:
HandlerEvent
,
context
:
HandlerContext
)
=>
{
const
sleep
=
(
ms
:
number
)
=>
{
return
new
Promise
(
(
resolve
)
=>
setTimeout
(
resolve
,
ms
)
)
;
}
;
(
async
(
)
=>
{
for
(
let
i
=
0
;
i
<=
60
;
i
++
)
{
const
date
=
new
Date
(
)
;
await
sleep
(
1000
)
;
console
.
log
(
date
.
toLocaleString
(
)
,
i
)
;
}
console
.
log
(
"Done"
)
;
}
)
(
)
;
}
;
This function deploys to an endpoint at
/.netlify/functions/count-background
relative to the base URL of your site.
When invoked, the function returns an initial
202
success response.
When successfully executed, the function logs numbers 1 through 60.
Real-time logs only
The Background Functions beta currently supports only real-time logs. You can’t use the function log date filter to explore log history.
For an extended example that demonstrates a more likely background function use case, consider this
send-pdf-background.ts
function:
import
{
jsPDF
}
from
"jspdf"
;
import
mailgun
from
"mailgun-js"
;
import
type
{
BackgroundHandler
,
HandlerEvent
}
from
"@netlify/functions"
;
type
Context
=
{
content
:
string
;
destination
:
string
;
}
;
const
mg
=
mailgun
(
{
apiKey
:
process
.
env
.
MAILGUN_API_KEY
,
domain
:
process
.
env
.
MAILGUN_DOMAIN
,
}
)
;
const
handler
:
BackgroundHandler
=
async
(
event
:
HandlerEvent
)
=>
{
if
(
!
event
.
body
)
{
return
;
}
const
{
content
,
destination
}
=
JSON
.
parse
(
event
.
body
)
as
Context
;
console
.
log
(
`
Sending PDF report to
${
destination
}
`
)
;
const
report
=
Buffer
.
from
(
new
jsPDF
(
)
.
text
(
content
,
10
,
10
)
.
output
(
"arraybuffer"
)
)
;
const
info
=
await
mg
.
messages
(
)
.
send
(
{
from
:
process
.
env
.
MAILGUN_SENDER
,
to
:
destination
,
subject
:
"Your report is ready!"
,
text
:
"Details in attached report PDF"
,
attachments
:
[
{
filename
:
`
report-
${
new
Date
(
)
.
toDateString
(
)
}
.pdf
`
,
content
:
report
,
contentType
:
"application/pdf"
,
}
,
]
,
}
)
;
console
.
log
(
`
PDF report sent: %s
`
,
info
.
id
)
;
}
;
export
{
handler
}
;
This background function deploys to an endpoint at
/.netlify/functions/send-pdf-background
relative to the base URL of your site.
When invoked, the function returns an initial
202
success response.
When successfully executed, a PDF report is generated and emailed as an attachment.
#
Environment variables
Netlify Functions have access to environment variables in the runtime environment. If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to functions during runtime.
You can also leverage
build environment variables
to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.
Learn more about how to set and use
environment variables with functions
.
#
Manage dependencies
To optimize build performance, specify function dependencies in the top-level
package.json
file in the site’s
base directory
. Here’s an example of a recommended layout:
my-base-directory/
├─ package.json
├─ node_modules
└─ netlify/
   └─ functions/
        ├─ hello.ts
        └─ send-pdf-background.ts
With
continuous deployment
, Netlify automatically zips dependencies with your functions for deployment. To do this, Netlify’s
build system installs your dependencies
and parses each function file to note its dependencies. For each function, Netlify then pulls the required dependencies from the associated
node_modules
folder and zips them with the function file for deployment. For more details about how this bundling functionality works, visit the repository for the underlying module:
@netlify/zip-it-and-ship-it
.
Dependencies and bundling
If you are using
devDependencies
in your
package.json
file, they won’t be bundled in your functions. We recommend using
dependencies
instead of
devDependencies
.
If you’re using a Netlify configuration file to configure custom
[functions]
settings, note that the
node_bundler
value for TypeScript functions always overrides to
esbuild
.
#
Test locally
To streamline writing and testing your functions on Netlify, run a local development environment with
Netlify Dev
. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The
netlify dev
command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.
To simulate Netlify Functions in a standalone server without the full overhead of Netlify Dev,
serve functions locally
with the
netlify functions:serve
CLI command (currently in beta). Then to
debug functions
, inspect the functions server process.
#
Type check
Because Netlify’s build system doesn’t perform type checking, we recommend that you type check locally with one of these options:
Use your code editor to type check during local development.
Use the official
TypeScript compiler
, running
tsc --noEmit
locally before committing the files.
#
Next steps
Push your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about
other workflows for deploying your functions
including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.
Monitor function
logs
and
metrics
in the Netlify UI to observe and help troubleshoot your deployed functions.
Netlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the
Netlify CLI
.
Learn how to
use Netlify Blobs with lambda-compatible functions
.
#
Create function file
To add a serverless function to your project, create a JavaScript file in your functions directory following the instructions below for naming and coding your function. Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function.
The default functions directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can optionally
configure a custom functions directory
.
#
Name your function
You can store your function file directly under the functions directory or in a subdirectory dedicated to the function. The function’s endpoint name is case-sensitive and determined by its filename or the name of its dedicated parent directory.
For example, to create a function with an endpoint name of
hello
, save the function file in one of the following ways:
netlify/functions/hello.js
netlify/functions/hello/hello.js
netlify/functions/hello/index.js
These formats would deploy a synchronous function that can be called on the following endpoint:
/.netlify/functions/hello
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello
for a site using a custom domain.
To create a
background function
, append the function name with
-background
. For example, to create a background function with an endpoint name of
hello-background
, save the function file in one of these ways:
netlify/functions/hello-background.js
netlify/functions/hello-background/hello-background.js
netlify/functions/hello-background/index.js
These formats would deploy a background function that can be called on the following endpoint:
/.netlify/functions/hello-background
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello-background
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello-background
for a site using a custom domain.
Reserved names for event-driven functions
Certain function names are reserved as triggers initiated by various built-in events on your Netlify site. You can find a list of these function names and how they work on the page about
event-driven functions
.
#
Code your function
This section will help you learn how to write functions. It covers the syntax for
synchronous functions
, both buffered and
streaming
, as well as
background functions
.
#
Synchronous function format
To create a synchronous function, use the following general syntax in your JavaScript function file to export a
handler
method:
exports
.
handler
=
async
function
(
event
,
context
)
{
// your server-side functionality
}
;
Netlify provides the
event
and
context
parameters when the function is invoked.
The
event
object received by the
handler
is similar to the following:
{
"path"
:
"Path parameter (original URL encoding)"
,
"httpMethod"
:
"Incoming request’s method name"
,
"headers"
:
{
Incoming request headers
}
,
"queryStringParameters"
:
{
Query string parameters
}
,
"body"
:
"A JSON string of the request payload"
,
"isBase64Encoded"
:
"A boolean flag to indicate if the applicable request payload is Base64-encoded"
}
If you need to parse a
multipart/form-data
-encoded
event.body
, we recommend using
busboy
. To learn more, visit our blog article on
processing multipart form data with Netlify Functions
.
The
context
object received by the
handler
includes information about the context in which the function was called, like certain
Identity user information
, for example.
Here’s a basic example function,
hello.js
:
exports
.
handler
=
async
function
(
event
,
context
)
{
return
{
statusCode
:
200
,
body
:
JSON
.
stringify
(
{
message
:
"Hello World"
}
)
}
;
}
;
This function deploys to an endpoint at
/.netlify/functions/hello
relative to the base URL of your site.
A successful invocation returns the
200
status code and the string, “Hello, World”.
Synchronous functions can return a response object that includes the following information:
{
"isBase64Encoded"
:
true
|
false
,
"statusCode"
:
httpStatusCode
,
"headers"
:
{
"headerName"
:
"headerValue"
,
...
}
,
"multiValueHeaders"
:
{
"headerName"
:
[
"headerValue"
,
"headerValue2"
,
...
]
,
...
}
,
"body"
:
"..."
}
Because
async
function code returns a
promise
, we recommend returning a response with at least an HTTP status code instead of allowing the function to time out. Using
async
in your function code doesn’t automatically designate a function as a background function.
#
Response streaming
This feature is in
Beta
.
Netlify Functions can stream data to clients as it becomes available, rather than returning a buffered payload at the end of the computation. This lets developers and frameworks create faster experiences by using streaming and partial hydration to get content and interactions in front of people as quickly as possible.
To stream a function’s response:
wrap your
handler
export with the
stream
decorator
return a
ReadableStream
as the
body
Here’s a simplified example that you can use to test that your function response streams to the client:
const
{
stream
}
=
require
(
"@netlify/functions"
)
;
exports
.
handler
=
stream
(
async
(
)
=>
{
const
encoder
=
new
TextEncoder
(
)
;
const
formatter
=
new
Intl
.
DateTimeFormat
(
"en"
,
{
timeStyle
:
"medium"
}
)
;
const
body
=
new
ReadableStream
(
{
start
(
controller
)
{
controller
.
enqueue
(
encoder
.
encode
(
"<html><body><ol>"
)
)
;
let
i
=
0
;
const
timer
=
setInterval
(
(
)
=>
{
controller
.
enqueue
(
encoder
.
encode
(
`
<li>Hello at
${
formatter
.
format
(
new
Date
(
)
)
}
</li>\n\n
`
)
)
;
if
(
i
++
>=
5
)
{
controller
.
enqueue
(
encoder
.
encode
(
"</ol></body></html>"
)
)
;
controller
.
close
(
)
;
clearInterval
(
timer
)
;
}
}
,
1000
)
;
}
}
)
;
return
{
headers
:
{
"content-type"
:
"text/html"
}
,
statusCode
:
200
,
body
}
;
}
)
;
For an extended example that demonstrates a more likely response streaming use case, consider this function:
const
{
stream
}
=
require
(
"@netlify/functions"
)
;
exports
.
handler
=
stream
(
async
event
=>
{
// Get the request from the request query string, or use a default
const
pie
=
event
.
queryStringParameters
?.
pie
??
"something inspired by a springtime garden"
;
// The response body returned from "fetch" is a "ReadableStream",
// so you can return it directly in your streaming response
const
res
=
await
fetch
(
"https://api.openai.com/v1/chat/completions"
,
{
method
:
"POST"
,
headers
:
{
"Content-Type"
:
"application/json"
,
// Set this environment variable to your own key
Authorization
:
`
Bearer
${
process
.
env
.
OPENAI_API_KEY
}
`
}
,
body
:
JSON
.
stringify
(
{
model
:
"gpt-3.5-turbo"
,
messages
:
[
{
role
:
"system"
,
content
:
"You are a baker. The user will ask you for a pie recipe. You will respond with the recipe. Use markdown to format your response"
}
,
// Use "slice" to limit the length of the input to 500 characters
{
role
:
"user"
,
content
:
pie
.
slice
(
0
,
500
)
}
]
,
// Use server-sent events to stream the response
stream
:
true
}
)
}
)
;
return
{
headers
:
{
// This is the mimetype for server-sent events
"content-type"
:
"text/event-stream"
}
,
statusCode
:
200
,
// Pipe the event stream from OpenAI to the client
body
:
res
.
body
}
;
}
)
;
When invoked this function sends a prompt to OpenAI and streams the response back to the client like a chatbot.
Keep the following limitations in mind when working with streaming functions:
10 second execution limit. If the limit is reached, the response stops streaming.
20 MB response size limit. Responses larger than 20 MB cannot be streamed.
Background Functions can’t stream responses.
On-demand Builders can’t stream responses.
Scheduled Functions can’t stream responses.
#
Background function format
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
To create a
background function
, append the function name with
-background
. For example,
netlify/functions/hello-background.js
or
netlify/functions/hello-background/index.js
.
Background function syntax is similar to synchronous function syntax with a couple of key differences:
You will generally pass the function result to a destination other than the originating client.
Background functions don’t support response streaming because they don’t return responses.
Like the
synchronous function format
, each JavaScript file to be deployed as a background function must export a
handler
method. As with synchronous function invocation, Netlify provides the
event
and
context
parameters when a background function is invoked. Although background functions rely on asynchronous invocation, they don’t require the use of
async
JavaScript syntax.
Here’s a simplified example background function that you can use to test that your function runs longer than 30 seconds,
count-background.js
:
exports
.
handler
=
function
(
event
,
context
)
{
function
sleep
(
ms
)
{
return
new
Promise
(
resolve
=>
setTimeout
(
resolve
,
ms
)
)
;
}
async
function
demo
(
)
{
for
(
let
i
=
0
;
i
<
60
;
i
++
)
{
let
date
=
new
Date
(
)
;
await
sleep
(
1000
)
;
console
.
log
(
date
.
toLocaleString
(
)
,
i
)
;
}
console
.
log
(
"Done"
)
;
}
demo
(
)
;
}
;
This function deploys to an endpoint at
/.netlify/functions/count-background
relative to the base URL of your site.
When invoked, the function returns an initial
202
success response.
When successfully executed, the function logs numbers 1 through 60.
Real-time logs only
The Background Functions beta currently supports only real-time logs. You can’t use the function log date filter to explore log history.
For an extended example that demonstrates a more likely background function use case, consider this
send-pdf-background.js
function:
const
{
jsPDF
}
=
require
(
"jspdf"
)
;
const
nodemailer
=
require
(
"nodemailer"
)
;
const
mg
=
require
(
"nodemailer-mailgun-transport"
)
;
const
transporter
=
nodemailer
.
createTransport
(
mg
(
{
auth
:
{
api_key
:
process
.
env
.
MAILGUN_API_KEY
,
domain
:
process
.
env
.
MAILGUN_DOMAIN
}
}
)
)
;
exports
.
handler
=
async
function
(
event
)
{
const
{
content
,
destination
}
=
JSON
.
parse
(
event
.
body
)
;
console
.
log
(
`
Sending PDF report to
${
destination
}
`
)
;
const
report
=
Buffer
.
from
(
new
jsPDF
(
)
.
text
(
content
,
10
,
10
)
.
output
(
"arraybuffer"
)
)
;
const
info
=
await
transporter
.
sendMail
(
{
from
:
process
.
env
.
MAILGUN_SENDER
,
to
:
destination
,
subject
:
"Your report is ready!"
,
text
:
"Details in attached report PDF"
,
attachments
:
[
{
filename
:
`
report-
${
new
Date
(
)
.
toDateString
(
)
}
.pdf
`
,
content
:
report
,
contentType
:
"application/pdf"
}
]
}
)
;
console
.
log
(
`
PDF report sent:
${
info
.
messageId
}
`
)
;
}
;
This background function deploys to an endpoint at
/.netlify/functions/send-pdf-background
relative to the base URL of your site.
When invoked, the function returns an initial
202
success response.
When successfully executed, a PDF report is generated and emailed as an attachment.
#
Environment variables
Netlify Functions have access to environment variables in the runtime environment. If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to functions during runtime.
You can also leverage
build environment variables
to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.
Learn more about how to set and use
environment variables with functions
.
#
Manage dependencies
To optimize build performance, specify function dependencies in the top-level
package.json
file in the site’s
base directory
. Here’s an example of a recommended layout:
my-base-directory/
├─ package.json
├─ node_modules
└─ netlify/
   └─ functions/
        ├─ hello.js
        └─ send-pdf-background.js
With
continuous deployment
, Netlify automatically zips dependencies with your functions for deployment. To do this, Netlify’s
build system installs your dependencies
and parses each function file to note its dependencies. For each function, Netlify then pulls the required dependencies from the associated
node_modules
folder and zips them with the function file for deployment. For more details about how this bundling functionality works, visit the repository for the underlying module:
@netlify/zip-it-and-ship-it
.
#
Test locally
To streamline writing and testing your functions on Netlify, run a local development environment with
Netlify Dev
. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The
netlify dev
command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.
To simulate Netlify Functions in a standalone server without the full overhead of Netlify Dev,
serve functions locally
with the
netlify functions:serve
CLI command (currently in beta). Then to
debug functions
, inspect the functions server process.
#
Next steps
Push your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about
other workflows for deploying your functions
including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.
Monitor function
logs
and
metrics
in the Netlify UI to observe and help troubleshoot your deployed functions.
Netlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the
Netlify CLI
.
Learn how to
use Netlify Blobs with lambda-compatible functions
.
#
Create function file
To add a serverless function to your project, create a Go file in a dedicated function subdirectory in your functions directory following the instructions below for naming and coding your function. Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function.
The default functions directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can optionally
configure a custom functions directory
.
#
Name your function
You must store your function in a subdirectory dedicated to the function. The function’s endpoint name is case-sensitive and determined by the name of its dedicated parent directory.
For example, to create a function with an endpoint name of
hello
, save the function file in one of the following ways:
netlify/functions/hello/hello.go
netlify/functions/hello/main.go
These formats would deploy a synchronous function that can be called on the following endpoint:
/.netlify/functions/hello
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello
for a site using a custom domain.
To create a
background function
, append the function name with
-background
. For example, to create a background function with an endpoint name of
hello-background
, save the function file in one of these ways:
netlify/functions/hello-background/hello-background.go
netlify/functions/hello-background/main.go
These formats would deploy a background function that can be called on the following endpoint:
/.netlify/functions/hello-background
. The endpoint is relative to the base URL of your site. Here are some example full endpoint URLs:
yoursitename.netlify.app/.netlify/functions/hello-background
for a site using the default Netlify subdomain or
www.yourcustomdomain.com/.netlify/functions/hello-background
for a site using a custom domain.
Reserved names for event-driven functions
Certain function names are reserved as triggers initiated by various built-in events on your Netlify site. You can find a list of these function names and how they work on the page about
event-driven functions
.
#
Code your function
This section will help you learn how to write functions. It covers the syntax for both
synchronous
and
background
functions.
#
Synchronous function format
To create a synchronous function, use the following general syntax in your Go function file. This makes a
handler
function to receive invocation events:
package
main
import
(
"github.com/aws/aws-lambda-go/events"
"github.com/aws/aws-lambda-go/lambda"
)
func
handler
(
request events
.
APIGatewayProxyRequest
)
(
*
events
.
APIGatewayProxyResponse
,
error
)
{
// Your server-side functionality
}
func
main
(
)
{
// Make the handler available for Remote Procedure Call
lambda
.
Start
(
handler
)
}
Here’s a complete example function
hello.go
:
package
main
import
(
"github.com/aws/aws-lambda-go/events"
"github.com/aws/aws-lambda-go/lambda"
)
func
handler
(
request events
.
APIGatewayProxyRequest
)
(
*
events
.
APIGatewayProxyResponse
,
error
)
{
return
&
events
.
APIGatewayProxyResponse
{
StatusCode
:
200
,
Body
:
"Hello, World!"
,
}
,
nil
}
func
main
(
)
{
lambda
.
Start
(
handler
)
}
This function deploys to an endpoint at
/.netlify/functions/hello
relative to the base URL of your site.
A successful invocation returns the
200
status code and the string, “Hello, World”.
Synchronous functions can return a response object that includes the following information:
return
&
events
.
APIGatewayProxyResponse
{
StatusCode
:
200
,
Headers
:
map
[
string
]
string
{
"Content-Type"
:
"text/plain"
}
,
MultiValueHeaders
:
http
.
Header
{
"Set-Cookie"
:
{
"Ding"
,
"Ping"
}
}
,
Body
:
"Hello, World"
,
IsBase64Encoded
:
false
,
}
,
nil
For more examples to help you learn how to create functions with Go, visit the
AWS Lambda for Go
repository.
#
Access the
ClientContext
Netlify can provide extra request information about the context in which the function was called, including certain
Identity user information
, using a
ClientContext
parameter
.
To access the
ClientContext
data
, do the following:
Use a handler definition that includes a Go
Context
struct.
Transform this object into a LambdaContext.
Here is an example:
package
main
import
(
"context"
"github.com/aws/aws-lambda-go/events"
"github.com/aws/aws-lambda-go/lambda"
"github.com/aws/aws-lambda-go/lambdacontext"
)
func
handler
(
ctx context
.
Context
,
request events
.
APIGatewayProxyRequest
)
(
*
events
.
APIGatewayProxyResponse
,
error
)
{
lc
,
ok
:=
lambdacontext
.
FromContext
(
ctx
)
if
!
ok
{
return
&
events
.
APIGatewayProxyResponse
{
StatusCode
:
503
,
Body
:
"Something went wrong :("
,
}
,
nil
}
cc
:=
lc
.
ClientContext
return
&
events
.
APIGatewayProxyResponse
{
StatusCode
:
200
,
Body
:
"Hello, "
+
cc
.
Client
.
AppTitle
,
}
,
nil
}
func
main
(
)
{
lambda
.
Start
(
handler
)
}
#
Background function format
This feature is in
Beta
and is available on
Pro
and
Enterprise
plans.
To create a
background function
, append the function name with
-background
. For example,
netlify/functions/hello-background/hello-background.go
or
netlify/functions/hello-background/main.go
.
Background function syntax is similar to synchronous function syntax, but you will generally pass the function result to a destination other than the originating client. Like the
synchronous function format
, a Go file to be deployed as a background function must include a
handler
function to receive invocation events.
Here’s a simplified example background function that you can use to test that your function runs longer than 30 seconds,
count-background.go
:
package
main
import
(
"log"
"time"
"github.com/aws/aws-lambda-go/events"
"github.com/aws/aws-lambda-go/lambda"
)
func
handler
(
request events
.
APIGatewayProxyRequest
)
(
*
events
.
APIGatewayProxyResponse
,
error
)
{
for
i
:=
0
;
i
<
60
;
i
++
{
log
.
Println
(
i
)
time
.
Sleep
(
1
*
time
.
Second
)
}
return
nil
,
nil
}
func
main
(
)
{
lambda
.
Start
(
handler
)
}
This function deploys to an endpoint at
/.netlify/functions/count-background
relative to the base URL of your site.
When invoked, the function returns an initial
202
success response.
When successfully executed, the function logs numbers 1 through 60.
Real-time logs only
The Background Functions beta currently supports only real-time logs. You can’t use the function log date filter to explore log history.
You can explore an
extended background function example
that demonstrates a more likely use case.
This
event-triggered background function
is called on a new user email and password signup and uses the
ctx
parameter to
access the
ClientContext
.
When the function is executed, it finds and downloads a user’s Gravatar profile image, resizes the image to three different sizes, and saves these images to the site’s repository.
For more details, visit the
example’s repository README
. Note that this extended example doesn’t follow the file name requirements described on this page. That is because rather than using Netlify’s default automatic build workflow, this example uses a
custom build with continuous deployment
to compile
save.go
to
identity-signup-background
.
#
Environment variables
Netlify Functions have access to environment variables in the runtime environment. If you have the option to set specific scopes for your environment variables, the scope must include
Functions
to be available to functions during runtime.
You can also leverage
build environment variables
to configure how Netlify builds your functions. For example, you can use an environment variable to set the Node.js version.
Learn more about how to set and use
environment variables with functions
.
#
Test locally
To streamline writing and testing your functions on Netlify, run a local development environment with
Netlify Dev
. This feature of Netlify CLI includes tools for local function development through a simulated Netlify production environment. The
netlify dev
command starts a framework server if a framework is detected and handles redirects, proxy rules, environment variables, and Netlify Functions.
To simulate Netlify Functions in a standalone server without the full overhead of Netlify Dev,
serve functions locally
with the
netlify functions:serve
CLI command.
#
Next steps
Push your function source files to your Git provider for continuous deployment where Netlify’s build system automatically detects, builds, and deploys your functions. For more control over the process, learn about
other workflows for deploying your functions
including custom builds with continuous deployment and manual deploys with the Netlify CLI or API.
Monitor function
logs
and
metrics
in the Netlify UI to observe and help troubleshoot your deployed functions.
Netlify function logs are found in the Netlify UI. You can also stream Netlify function logs to the console with the
Netlify CLI
.
Last updated: March 27, 2025
←
API
Trigger on events
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_logs.txt --------
Start of file
URL: https://docs.netlify.com/functions/logs/
Scraped_At: 2025-06-02T19:58:16.042298

Contact
Forums
Contact support
Netlify provides logs in the Netlify UI to help you observe and troubleshoot serverless functions in your current
published deploy
, branch deploys, and Deploy Previews.
#
Access function logs
In the Netlify UI, for your chosen site, go to
Logs
>
Functions
.
Select a function from the list to open the log for that function.
By default, the Functions list displays the functions in the current published deploy. To find functions on another deploy, you can use the search field at the top of the list. You can start typing to jump to a particular branch, or find a Deploy Preview by number.
Team Owners and Developers can monitor the function logs for a specific deploy by going to the
Function logs
tab of the
Netlify Drawer
in a collaborative Deploy Preview.
#
Log contents
Netlify displays a log for each function, including:
Start of each invocation
Any
console.log()
statements you include in your function code
Log statements as each
background function
is executed
Note that function
log retention limits
apply and may impact what the Netlify UI displays.
#
Date filter
By default, the function log displays a live tail of the latest activity in
Real-time
. You can also filter to review data from a specific time period, including the
Last hour
,
Last day
,
Last 7 days
, or select
Custom
to input a specific date and time range.
#
Text filter
You can filter the contents of the log with simple text matches on request ID, message, or log level. Some common log levels include:
INFO
ERROR
WARN
FATAL
DEBUG
TRACE
#
Log retention and limits
Logs are retained for at least 24 hours of function activity, even after a new function deployment. This log retention period increases to 7 days for certain pricing plans.
Log limitations
For functions using the
Lambda compatibility mode
, historical function log output is limited to 4 KB total per invocation. If a log’s output exceeds 4 KB, only the last 4 KB of the log is retained and the log message will be truncated.
#
Log Drains
This feature is available on
Enterprise
plans.
You can connect your function logs to third-party monitoring services for analysis using Netlify’s Log Drains feature. Check out our
Log Drains
doc for more information.
For logs sent via Log Drains, the output for a single log entry is limited to 700 KB.
#
Function Metrics
With
Function Metrics
, you can get insights into the performance, reliability, and usage patterns of functions on your site. By analyzing success and error rates alongside other metrics, such as invocation count and function duration, you can optimize performance, troubleshoot issues, and make data-driven decisions to enhance the overall quality and user experience of your projects.
Last updated: May 13, 2025
←
Deploy
Optional configuration
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_optional-configuration.txt --------
Start of file
URL: https://docs.netlify.com/functions/optional-configuration/?fn-language=ts
Scraped_At: 2025-06-02T19:58:20.185757

Contact
Forums
Contact support
This document describes optional configuration settings you can use for more control over how your functions are built, deployed, and executed.
Choose your programming language:
TypeScript
JavaScript
Go
TypeScript
JavaScript
Go
#
Directory
Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function. The default directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can customize the directory using the Netlify UI or file-based configuration.
In the Netlify UI, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
and select
Configure
. In the
Functions directory
field, enter a path to the directory in your repository where you want to store your functions.
Alternatively, add the following to
netlify.toml
for
file-based configuration
.
[
functions
]
directory
=
"my_functions"
Settings in
netlify.toml
override settings in the Netlify UI.
For both methods, the path is an absolute path relative to the site’s
base directory
in your repository. To help keep your site secure, make sure your functions directory is outside of your
publish directory
so that your source files aren’t deployed as part of your site.
#
Region
This feature is available on
Pro
and
Enterprise
plans.
Netlify offers several
AWS regions
for deploying your serverless functions. You may want to customize the region for the following reasons:
Optimize performance.
Deploying serverless functions close to their data sources, such as a database or another backend service, can greatly reduce roundtrip time for data retrieval resulting in faster response times for your users.
Ensure compliance.
In some cases, data protection laws and industry-specific regulations may require that sensitive data processing happens within specific regions.
Use Private Connectivity.
Static IP addresses for
Private Connectivity
are available in only some regions.
By default, Netlify deploys functions for new sites to
us-east-2
(Ohio). This is a common choice for many database providers, so this optimizes performance for most cases.
You can change the region through the Netlify UI to one of the following regions.
ap-northeast-1 - Asia Pacific (Tokyo)
ap-southeast-1 - Asia Pacific (Singapore)
ap-southeast-2 - Asia Pacific (Sydney)
ca-central-1 - Canada (Central)
eu-central-1 - EU (Frankfurt)
eu-west-2 - EU (London)
sa-east-1 - South America (São Paulo)
us-east-1 - US East (N. Virginia)
us-east-2 - US East (Ohio)
us-west-1 - US West (N. California)
us-west-2 - US West (Oregon)
In addition to the above self-serve regions, the following regions are available through support-assisted configuration.
eu-west-3 - EU (Paris)
eu-south-1 - EU (Milan)
If you want your site to use one of the above regions, please
contact support
.
To configure your functions region through the Netlify UI:
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Functions region
.
Select
Configure
.
Use the menu to select a new region.
Confirm with
Save
.
Redeploy your site to apply the new region configuration.
Old deploys will continue to use the region configuration from when they were deployed.
#
Bundle
For granular control over which files are bundled in your executable function artifacts, use the
netlify.toml
properties
external_node_modules
and
included_files
. Visit the
file-based configuration
doc for details.
[
functions
]
# Flags "package-1" as an external node module for all functions.
external_node_modules
=
[
"package-1"
]
# Includes all Markdown files inside the "files/" directory.
included_files
=
[
"files/*.md"
]
#
Node.js version for runtime
For all Node.js functions deployed on or after May 15, 2023, the default functions runtime is based on the
Node.js version used for the build
. The Node.js version used for the build must be a valid
AWS Lambda runtime for Node.js
that isn’t set to be deprecated in the next two months.
If the build uses a version of Node.js that does not meet these conditions, then the functions runtime uses a fallback default version of Node.js 22.
You can override the default to any valid
AWS Lambda runtime for Node.js
that isn’t set to be deprecated in the next two months. Do so by completing the following steps.
In the Netlify UI,
set the environment variable
AWS_LAMBDA_JS_RUNTIME
to the desired version. For example, to use Node.js 20 for all future functions deployed, set the variable value to
nodejs20.x
.
Redeploy your site to apply the new runtime version.
Note that this environment variable must be set using the Netlify UI, CLI, or API, and not with a Netlify configuration file (
netlify.toml
).
#
Directory
Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function. The default directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can customize the directory using the Netlify UI or file-based configuration.
In the Netlify UI, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
and select
Configure
. In the
Functions directory
field, enter a path to the directory in your repository where you want to store your functions.
Alternatively, add the following to
netlify.toml
for
file-based configuration
.
[
functions
]
directory
=
"my_functions"
Settings in
netlify.toml
override settings in the Netlify UI.
For both methods, the path is an absolute path relative to the site’s
base directory
in your repository. To help keep your site secure, make sure your functions directory is outside of your
publish directory
so that your source files aren’t deployed as part of your site.
#
Region
This feature is available on
Pro
and
Enterprise
plans.
Netlify offers several
AWS regions
for deploying your serverless functions. You may want to customize the region for the following reasons:
Optimize performance.
Deploying serverless functions close to their data sources, such as a database or another backend service, can greatly reduce roundtrip time for data retrieval resulting in faster response times for your users.
Ensure compliance.
In some cases, data protection laws and industry-specific regulations may require that sensitive data processing happens within specific regions.
Use Private Connectivity.
Static IP addresses for
Private Connectivity
are available in only some regions.
By default, Netlify deploys functions for new sites to
us-east-2
(Ohio). This is a common choice for many database providers, so this optimizes performance for most cases.
You can change the region through the Netlify UI to one of the following regions.
ap-northeast-1 - Asia Pacific (Tokyo)
ap-southeast-1 - Asia Pacific (Singapore)
ap-southeast-2 - Asia Pacific (Sydney)
ca-central-1 - Canada (Central)
eu-central-1 - EU (Frankfurt)
eu-west-2 - EU (London)
sa-east-1 - South America (São Paulo)
us-east-1 - US East (N. Virginia)
us-east-2 - US East (Ohio)
us-west-1 - US West (N. California)
us-west-2 - US West (Oregon)
In addition to the above self-serve regions, the following regions are available through support-assisted configuration.
eu-west-3 - EU (Paris)
eu-south-1 - EU (Milan)
If you want your site to use one of the above regions, please
contact support
.
To configure your functions region through the Netlify UI:
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Functions region
.
Select
Configure
.
Use the menu to select a new region.
Confirm with
Save
.
Redeploy your site to apply the new region configuration.
Old deploys will continue to use the region configuration from when they were deployed.
#
Bundle
To optimize bundling time and artifact size, you can have Netlify use
esbuild
for bundling your JavaScript functions. Enable this opt-in beta feature in
netlify.toml
.
[
functions
]
node_bundler
=
"esbuild"
For granular control over which files are bundled in your executable function artifacts, use the
netlify.toml
properties
external_node_modules
and
included_files
. Visit the
file-based configuration
doc for details.
[
functions
]
# Flags "package-1" as an external node module for all functions.
external_node_modules
=
[
"package-1"
]
# Includes all Markdown files inside the "files/" directory.
included_files
=
[
"files/*.md"
]
#
Node.js version for runtime
For all Node.js functions deployed on or after May 15, 2023, the default functions runtime is based on the
Node.js version used for the build
. The Node.js version used for the build must be a valid
AWS Lambda runtime for Node.js
that isn’t set to be deprecated in the next two months.
If the build uses a version of Node.js that does not meet these conditions, then the functions runtime uses a fallback default version of Node.js 22.
You can override the default to any valid
AWS Lambda runtime for Node.js
that isn’t set to be deprecated in the next two months. Do so by completing the following steps.
In the Netlify UI,
set the environment variable
AWS_LAMBDA_JS_RUNTIME
to the desired version. For example, to use Node.js 20 for all future functions deployed, set the variable value to
nodejs20.x
.
Redeploy your site to apply the new runtime version.
Note that this environment variable must be set using the Netlify UI, CLI, or API, and not with a Netlify configuration file (
netlify.toml
).
#
Directory
Netlify will access the functions directory during every build, preparing and deploying each supported code file as a function. The default directory is
YOUR_BASE_DIRECTORY/netlify/functions
. You can customize the directory using the Netlify UI or file-based configuration.
In the Netlify UI, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Build settings
and select
Configure
. In the
Functions directory
field, enter a path to the directory in your repository where you want to store your functions.
Alternatively, add the following to
netlify.toml
for
file-based configuration
.
[
functions
]
directory
=
"my_functions"
Settings in
netlify.toml
override settings in the Netlify UI.
For both methods, the path is an absolute path relative to the site’s
base directory
in your repository. To help keep your site secure, make sure your functions directory is outside of your
publish directory
so that your source files aren’t deployed as part of your site.
#
Region
This feature is available on
Pro
and
Enterprise
plans.
Netlify offers several
AWS regions
for deploying your serverless functions. You may want to customize the region for the following reasons:
Optimize performance.
Deploying serverless functions close to their data sources, such as a database or another backend service, can greatly reduce roundtrip time for data retrieval resulting in faster response times for your users.
Ensure compliance.
In some cases, data protection laws and industry-specific regulations may require that sensitive data processing happens within specific regions.
Use Private Connectivity.
Static IP addresses for
Private Connectivity
are available in only some regions.
By default, Netlify deploys functions for new sites to
us-east-2
(Ohio). This is a common choice for many database providers, so this optimizes performance for most cases.
You can change the region through the Netlify UI to one of the following regions.
ap-northeast-1 - Asia Pacific (Tokyo)
ap-southeast-1 - Asia Pacific (Singapore)
ap-southeast-2 - Asia Pacific (Sydney)
ca-central-1 - Canada (Central)
eu-central-1 - EU (Frankfurt)
eu-west-2 - EU (London)
sa-east-1 - South America (São Paulo)
us-east-1 - US East (N. Virginia)
us-east-2 - US East (Ohio)
us-west-1 - US West (N. California)
us-west-2 - US West (Oregon)
In addition to the above self-serve regions, the following regions are available through support-assisted configuration.
eu-west-3 - EU (Paris)
eu-south-1 - EU (Milan)
If you want your site to use one of the above regions, please
contact support
.
To configure your functions region through the Netlify UI:
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Functions region
.
Select
Configure
.
Use the menu to select a new region.
Confirm with
Save
.
Redeploy your site to apply the new region configuration.
Old deploys will continue to use the region configuration from when they were deployed.
#
Go version for builds
The Go version used in the deployment pipeline is determined by your site’s
build image
.
To modify the Go version used for your builds, change the build image for your site at
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Build image selection
.
Last updated: May 13, 2025
←
Logs
Usage & billing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_overview.txt --------
Start of file
URL: https://docs.netlify.com/functions/overview/
Scraped_At: 2025-06-02T19:58:20.858126

Contact
Forums
Contact support
Serverless functions open a world of possibilities for running on-demand, server-side code without having to run a dedicated server. However, managing service discovery, configuring API gateways, and coordinating deployments between your app and your functions can quickly become overwhelming.
With Netlify Functions, your serverless functions are version-controlled, built, and deployed along with the rest of your Netlify site, and we will automatically handle service discovery through our built-in API gateway. This eliminates overhead and brings the power of Deploy Previews and rollbacks to your functions.
To provide faster customer experiences, synchronous functions can use
response streaming
to get content in front of people as quickly as possible.
For longer-running function tasks,
Background Functions
allow for extended execution time using asynchronous invocation.
Currently, you can deploy functions built with TypeScript, JavaScript, and Go.
#
Manage your functions
Functions deployed from Netlify are immutable. This means that an update to a function on your production branch won’t change the version that was deployed in a branch deploy, or in a Deploy Preview. You can access all versions of your functions in the Netlify web interface, under the
Functions
tab.
By default, the list displays all of the functions, including background functions, in the current
published deploy
. To find functions on another deploy, you can use the search field at the top of the list. You can start typing to jump to a particular branch, or find a Deploy Preview by number.
#
Default deployment options
By default, all functions are deployed with:
us-east-2 AWS Lambda region (for sites created after October 4, 2023)
Private Connectivity
If your team has
Private Connectivity
enabled, note that this region selection makes your functions use the private network.
1024 MB of memory
30 second execution limit for synchronous functions, including
scheduled functions
15 minute execution limit for
background functions
6 MB request and response payload size limit for buffered synchronous functions
Lower effective limit for binary request payloads
We Base64-encode requests with binary payloads such as image uploads. This encoding comes with approximately 30% overhead relative to the size of the original binary data, effectively reducing the binary request payload size limit to 4.5 MB.
20 MB response payload size limit for streamed synchronous functions
256 KB request and response payload size limit for
background functions
#
Custom deployment options
Depending on your
plan
, you can change the deployment options for synchronous functions.
Region
can be customized through the Netlify UI.
Private Connectivity
can be enabled by
contacting your account manager
.
Limits other than the ones mentioned above cannot be changed.
If you wish to deploy functions onto your own AWS account (in order to integrate with other AWS services on your account), please
contact sales
.
#
More Functions resources
Get started with functions
API
Lambda compatibility
Trigger functions on events
Functions and Identity
Background Functions overview
Scheduled Functions overview
On-demand Builders
Environment variables and functions
Deploy functions
Function logs
Optional configuration for functions
Functions usage and billing
Function Metrics
Use the Netlify Blobs API in a function
Go to our
Trust Center
to download our reference architecture for HIPAA-compliant composable sites on Netlify
Visit our
Forums
to join the conversation about Functions
Optional configuration for functions: Directory
Deploy functions
Deploy functions
Last updated: September 6, 2024
Get started with functions
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_scheduled-functions.txt --------
Start of file
URL: https://docs.netlify.com/functions/scheduled-functions/
Scraped_At: 2025-06-02T19:58:21.798530

Contact
Forums
Contact support
This feature is in
Beta
.
Scheduled Functions is a feature of Netlify Functions that enables you to run functions on a regular and consistent schedule, much like a cron job. Scheduled functions can do almost anything that serverless functions do today, though some tasks are better suited to scheduled functions than others.
For example, you may want to:
Invoke a set of APIs to collate data for a report at the end of every week
Backup data from one data store to another at the end of every night
Build and/or deploy all your static content every hour instead of for every authored or merged pull request
Or anything else you can imagine you might want to invoke on a regular basis!
Note that scheduled functions don’t work with payloads or
POST
request data. When you need to work with payloads, you should use either a
synchronous
or
background function
instead.
#
Getting started
The Scheduled Functions beta is enabled by default for all accounts. To try the feature, write a scheduled function for your site.
Keep the
default deployment options
, such as memory and execution time limits, in mind as you work with scheduled functions.
#
Writing a scheduled function
Scheduled functions use the
“cron expression” format used by tools like crontab
and are executed according to the UTC timezone.
For example, the cron expression
0 0 * * *
will run a scheduled function every day at midnight UTC. We also support the
extensions
in the RFC, except for the
@reboot
and
@annually
specifications.
With extensions, the expression
0 0 * * *
can be written as
@daily
.
There are two ways to specify a cron expression for a scheduled function —
inline in function code
or
in
netlify.toml
.
Specifying cron expressions inline only works for TypeScript and JavaScript
If you use a function language other than TypeScript or JavaScript, you must specify your cron expression in
netlify.toml
.
#
Cron expression inline in function code
First, make sure you install the
@netlify/functions
npm module to your local project directory:
npm
install
@netlify/functions
Then, create a scheduled function in your Netlify functions directory using the general syntax of a
synchronous function
. Netlify provides a web platform
Request
and a
Netlify-specific
Context
object on each invocation.
For scheduled functions, the request body is a JSON-encoded object containing a
next_run
property. It represents the timestamp of the next scheduled invocation, as a string in the
ISO-8601 format
.
To set the schedule of a function, export a
config
object with a
schedule
property containing the cron expression.
Loading error: Refresh the page to access this code sample
// YOUR_BASE_DIRECTORY/netlify/functions/test-scheduled-function.mts
import
type
{
Config
}
from
"@netlify/functions"
export
default
async
(
req
:
Request
)
=>
{
const
{
next_run
}
=
await
req
.
json
(
)
console
.
log
(
"Received event! Next invocation at:"
,
next_run
)
}
export
const
config
:
Config
=
{
schedule
:
"@hourly"
}
// YOUR_BASE_DIRECTORY/netlify/functions/test-scheduled-function.mjs
export
default
async
(
req
)
=>
{
const
{
next_run
}
=
await
req
.
json
(
)
console
.
log
(
"Received event! Next invocation at:"
,
next_run
)
}
export
const
config
=
{
schedule
:
"@hourly"
}
#
Cron expression in
netlify.toml
If you prefer to keep your cron expressions in one file and separate from your function code, you can specify them in the
netlify.toml
configuration at the root of your repository.
First, create a function in your Netlify functions directory using the general syntax of a
synchronous function
. Netlify provides a web platform
Request
and a
Netlify-specific
Context
object on each invocation.
For scheduled functions, the request body is a JSON-encoded object containing a
next_run
property. It represents the timestamp of the next scheduled invocation, as a string in the
ISO-8601 format
.
Loading error: Refresh the page to access this code sample
// YOUR_BASE_DIRECTORY/netlify/functions/test-scheduled-function.mts
export
default
async
(
req
:
Request
)
=>
{
const
{
next_run
}
=
await
req
.
json
(
)
console
.
log
(
"Received event! Next invocation at:"
,
next_run
)
}
// YOUR_BASE_DIRECTORY/netlify/functions/test-scheduled-function.mjs
export
default
async
(
req
)
=>
{
const
{
next_run
}
=
await
req
.
json
(
)
console
.
log
(
"Received event! Next invocation at:"
,
next_run
)
}
Then, specify the function as a scheduled function in your configuration file:
# ./netlify.toml
[
functions."test-scheduled-function"
]
schedule
=
"@hourly"
#
Developing and debugging scheduled functions
Scheduled functions only run on published deploys and, similar to
event-triggered functions
, you can’t invoke them directly with a URL. This means that you can’t test with deploy previews, for example.
Therefore, the best way to test a scheduled function is to use Netlify Dev to
serve your scheduled function locally
and then use the
netlify functions:invoke
command to invoke it. Note that Netlify Dev will not execute the scheduled function on any kind of schedule — the invoke command only allows you to debug the function code invocation.
You can also invoke functions locally on the URL path but these invocations are purely for interactive debugging. Netlify Dev wraps the function response with a note that this URL invocation isn’t possible in production.
Alternatively, you can create a new test site to experiment with scheduled functions as part of published deploys.
Once you deploy your code, the deployed function should appear on the Functions page of the Netlify UI with a
Scheduled
badge. The function will show a next execution date and time, converted to the user’s timezone.
Select the scheduled function to access the function’s schedule and logs.
#
Supported cron extensions
@yearly
: once a year, on January 1st 00:00 (
0 0 1 1 *
)
@monthly
: every month, on the first day of the month, at 00:00 (
0 0 1 * -
)
@weekly
: every Sunday, 00:00 (
0 0 * * 0
)
@daily
: once a day, at 00:00 (
0 0 * * *
)
@hourly
: every hour, at minute 0 (
0 * * * *
)
#
Limitations
Scheduled functions have a 30 second execution limit.
Background functions
are more appropriate for tasks that must run longer.
Scheduled functions only run on published deploys. They don’t run on Deploy Previews or branch deploys.
You can’t invoke scheduled functions directly with a URL. Review the
developing and debugging
section above for how to test.
Scheduled functions don’t support response streaming because they don’t return a response body.
Scheduled functions don’t work with
Split Testing
because Split Testing relies on branch deploys and scheduled functions only run on published deploys.
Scheduled functions don’t work with sites that have
site-wide basic password protection
enabled as the protection applies to all parts of your site, including function endpoints. Netlify doesn’t have access to authentication information when executing scheduled functions. Consider using
basic authentication with custom HTTP headers
instead to protect only the sections of the site that need it and exclude the functions.
#
Feedback
We’d love to hear your thoughts on how we can make Scheduled Functions better. Please visit our
Forums
to join the conversation.
Last updated: September 6, 2024
←
Background Functions
Environment variables
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_trigger-on-events.txt --------
Start of file
URL: https://docs.netlify.com/functions/trigger-on-events/
Scraped_At: 2025-06-02T19:58:22.667372

Contact
Forums
Contact support
You can trigger serverless function calls when certain Netlify events happen, like when a deploy completes successfully.
Async Workloads Extension
Event-triggered serverless functions support built-in event triggers using serverless functions. If you’re looking to build durable, event-based architecture, refer to the
Async Workloads documentation
for more information.
An event-triggered function is built like any other, as described in the
get started with functions
doc. To make it trigger on an event, match the name of the function file to the name of the event. For example,
to trigger a synchronous function on
deploy-succeeded
events, name the function file something like
deploy-succeeded.ts
or
deploy-succeeded.go
.
to trigger a
background function
on
deploy-succeeded
events, name the function file something like
deploy-succeeded-background.ts
or
deploy-succeeded-background.go
.
When the event occurs, Netlify will automatically run the function you’ve created for that trigger. For example, when Netlify finishes deploying a site and triggers the
deploy-succeeded
event, the function declared in
deploy-succeeded.ts
will execute.
#
Available triggers
The following events are currently available:
deploy-building
: Triggered when Netlify starts building a site for deployment.
deploy-succeeded
: Triggered when Netlify finishes deploying a site.
deploy-failed
: Triggered when a deploy does not complete.
deploy-deleted
: Triggered when a deploy is deleted.
deploy-locked
: Triggered when a deploy is locked in production and Netlify stops autopublishing deploys.
deploy-unlocked
: Triggered when a deploy is unlocked from production and Netlify resumes autopublishing deploys.
split-test-activated
: Triggered when a split test is activated.
split-test-deactivated
: Triggered when a split test is deactivated.
split-test-modified
: Triggered when a split test’s settings change.
submission-created
: Triggered when a
form submission
is verified for your site.
identity-validate
: Triggered when an Identity user tries to sign up using
Identity
.
identity-signup
: Triggered when an Identity user signs up using Netlify
Identity
and confirms their email address. Note that this fires for email+password signups only, not for signups with external providers such as Google or GitHub.
identity-login
: Triggered when an Identity user logs in using Netlify
Identity
.
#
Payload
The request body for these functions is a JSON document that includes information about the associated site, as well as the object that triggered the event, such as a deploy, split test, or verified form submission. All payloads have this shape:
{
"payload"
:
{
# information about the object that triggered the event
}
,
"site"
:
{
# information about the associated site
}
}
#
Signature
To prevent external requests to event functions, Netlify generates a JSON web signature (JWS) for each event triggered by our platform, and verifies that the signature is correct before invoking an associated event function.
#
Limitations
Password-protected sites.
Functions triggered by events won’t work if you have full
Site Protection
enabled as Netlify doesn’t have access to site credentials or authentication information at event completion. Consider using
basic authentication
instead for only the sections of the site you need to protect and exclude the functions. Netlify automatically adds a layer of security for your event functions with
JSON web signatures
.
Last updated: October 2, 2024
←
Lambda compatibility
Functions & Identity
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- functions_usage-and-billing.txt --------
Start of file
URL: https://docs.netlify.com/functions/usage-and-billing/
Scraped_At: 2025-06-02T19:58:23.426365

Contact
Forums
Contact support
You can check your Functions service usage under
Project configuration
>
Functions
>
Overview
>
Usage
. This shows your current usage level and tracks the following metrics:
Requests:
metric that counts each time a serverless function endpoint is called on your site during the current billing period.
Run time:
metric that calculates the combined compute time of all serverless function requests during the current billing period.
For paid plans,
Functions pricing
scales with usage. When usage reaches a level limit, the site will automatically upgrade to the next level or package. Free tier accounts are also metered based on usage and
have a limit
.
Background Functions
are available on Core Pro and Enterprise
plans
.
#
Account usage insights
You can find additional data about your team’s function usage under
Billing
>
Account usage insights
. Learn more about
usage and insights
.
#
Change levels
Any team member with the ability to change the configuration for your site can also change levels for services on that site.
To do this, go to
Project configuration
>
Functions
>
Overview
>
Usage
, and select
Change level
. Level fees will be prorated and charged at the end of the billing cycle, to the team’s payment method.
#
More usage and billing resources
Function Metrics
Billing FAQ
Billing
Last updated: May 13, 2025
←
Optional configuration
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- get-started.txt --------
Start of file
URL: https://docs.netlify.com/get-started/
Scraped_At: 2025-06-02T19:58:24.121194

Start exploring a demo site
Deploy to Netlify
Want to explore a demo site first? You can return to this guide to help you get to know some key features including Deploy Previews, rollbacks, Netlify Functions, visual editing, environment variables, redirects, and Netlify Forms.
Demo repo
Demo site
Feature tour
###End of file##

-------- git_repo-permissions-linking.txt --------
Start of file
URL: https://docs.netlify.com/git/repo-permissions-linking/
Scraped_At: 2025-06-02T19:58:24.902558

Contact
Forums
Contact support
When you link a site to a Git repository, Netlify must gain permission to access your repository code. We may also require permission if you need to
access other repositories during your site build
.
#
Git provider permissions
Netlify’s method for obtaining permission varies by Git provider. For all sites connected to GitLab or Bitbucket, as well as some existing sites connected to GitHub, we use the Git provider’s OAuth2 authentication to obtain a client token to store in your browser.
For all new sites connected to GitHub, we use the
Netlify GitHub App
. The next section explains the advantages of using the Netlify GitHub App, along with instructions for converting an existing site to use the newer app.
For sites connected to Azure DevOps, we use Azure’s OAuth authentication to obtain a client token to store in your browser. To connect your Azure organization’s repositories to the Netlify UI, your organization must enable
Third-party application access via OAuth
. The Azure DevOps user you authenticate with when connecting a repo must also have Azure DevOps permissions to
Edit subscriptions
and
View subscriptions
. Learn more about
getting started with Azure DevOps
or
troubleshooting Azure access
.
Self-hosted Git
If you want to link a site to a self-hosted GitHub or GitLab repository, you will need to make a custom GitHub Enterprise Server app or GitLab self-managed OAuth app for your self-hosted instance. Visit the
self-hosted Git
doc to get started.
#
Authentication with the Netlify GitHub App
When you create a new site from a GitHub repository, Netlify obtains permission to do this by installing the Netlify GitHub App on your GitHub account. For self-hosted GitHub repositories, Netlify obtains permission by installing your custom GitHub App on your GitHub Enterprise Server account.
Authenticating using a GitHub App offers many advantages over traditional OAuth apps on GitHub, including:
Scoped repository access.
You can choose to grant access to all repositories belonging to your GitHub user or organization, or to specific repositories only. There is no need for special organization-level settings as was previously required for OAuth apps.
Finer-grained permissions.
This allows Netlify to request only the permissions we need, stated when you install the app, and in the GitHub App settings panel.
No deploy keys or webhooks.
GitHub App installations automatically create outgoing webhooks as needed, and handle repository access with generated, limited-scope tokens that expire after one hour for increased security.
Better comment notifications.
Integrations like our
pull request comment notifications
can be sent directly by the Netlify GitHub App, without the need for a personal user access token.
GitHub checks.
GitHub Apps have access to GitHub’s checks API, which enables you to
receive rich deploy summary information
in your GitHub pull requests and commit lists.
#
Install on a new site
When you create a new Netlify site from Git and select GitHub as your Git provider, you will be prompted to install the Netlify GitHub App, if you haven’t already.
During installation, you can choose to grant the app access to all repositories belonging to your GitHub user or organization, or to specific repositories only.
If you don’t get this install prompt, the app has already been installed on your GitHub account or on a GitHub organization you belong to. You can confirm that the app is installed and has the correct permissions by
checking your Installed GitHub Apps
.
If you don’t find the repository or organization you need, this is likely because you have not granted access to it. Check our guidance on
troubleshooting repository linking
to learn how you can adjust organization/repository access.
#
Install on an existing site
If you created a site using a
Deploy to Netlify button
or using the older OAuth app authentication, you will need to manually install the Netlify GitHub App.
You can install the Netlify GitHub App through the Netlify UI. On the
Site overview
page, select
Install
in the
Install the Netlify GitHub App
section.
During installation, you can choose to grant the app access to all repositories belonging to your GitHub user or organization, or to specific repositories only.
You can confirm that the app was installed successfully and has the correct permissions by
checking your Installed GitHub Apps
.
If the
Install the Netlify GitHub App
section isn’t available in the Netlify UI and the app isn’t included in your
Installed GitHub Apps list
, you can also unlink and relink your repository to launch the app install process. Start the repository unlink and relink process at
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
. Select
Manage repository
, then
Link to a different repository
.
#
Change the app’s repository access
Once installed, you can
configure the Netlify GitHub App
at any time to add or remove access to repositories.
If you grant the app access to all repositories owned by your GitHub user or organization, all future repositories and all new sites linked to these repositories will use the app automatically.
#
Troubleshoot GitHub repository linking
If you can’t find the repository or organization you’re searching for as you go through the repository linking process, this is likely because you didn’t grant access to that resource during the Netlify GitHub App installation.
To grant the Netlify GitHub App access to a repository:
While
linking a repository
, in the empty repository selection list, select
Configure Netlify on GitHub
or
Configure Netlify on your self-hosted GitHub
to install the app for the desired organization and configure the app’s repository access.
You can also go directly to your
GitHub Apps settings
to configure repository access for the installed app. For GitHub Enterprise Server accounts, you can
install the app
in a similar manner.
#
Link a Git repository
You can link a site to a Git repository in the Netlify UI. To do so, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
and select
Link repository
. Alternatively, you can link a site to a Git repository
with the Netlify CLI
.
When you link a site to a Git repository, Netlify automatically sets up
continuous deployment
for that site.
Tip
You can
stop builds
if you don’t want your site to be built when changes are pushed to the linked repository.
#
Change linked Git repository
To change which repository is linked to your site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
, select
Manage repository
, then
Link to a different repository
.
#
Unlink a Git repository
You can unlink a site’s Git repository, which can be useful for troubleshooting, deploying with
drag and drop
, and disabling continuous deployment.
Unlinking a repository breaks continuous deployment settings. While the site is unlinked, you will only be able to publish new deploys manually using the CLI, API, or drag and drop. In addition, when you unlink a repository the following are deleted:
Deploy keys
Build hooks
To unlink a repository from an existing site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
, select
Manage repository
, then
Unlink
the current repository. Alternatively, you can unlink a site from a Git repository
with the Netlify CLI
.
#
Get started with Azure DevOps
We recommend following these steps to get started with Netlify from an Azure repo.
Required Azure DevOps user permissions
In order to connect an Azure repo to a site on Netlify, the Azure DevOps user you authenticate with needs Azure DevOps permissions to
Edit subscriptions
and
View subscriptions
. Your admins can add the user to the project administrators group on Azure DevOps, or
grant these specific permissions
.
Ensure your Azure organization has enabled
Third-party application access via OAuth
on Azure DevOps. This is required to access your Azure organization’s repositories on Netlify. Learn more about
organization policies in the Azure DevOps docs
.
Set up continuous deployment by linking an Azure repo to
a new
or
existing Netlify site
in the UI. To troubleshoot your builds or repository linking, check out
Troubleshoot your Azure DevOps connection
.
Customize your
build configurations
and
branch deploys
as needed.
Configure automated deploy notifications for Azure DevOps
commit statuses
and
pull requests
.
Now you’re ready to preview changes to your Netlify site and share
Deploy Previews
with your team.
#
Troubleshoot your Azure DevOps connection
If you’re having issues with your site that builds from an Azure DevOps repo, check out these common issues and solutions.
#
Azure repo setup incomplete for continuous builds and deploys
The Azure project or organization that owns your site repo must have “Edit Subscription” permissions. If the Azure project or organization doesn’t have the right permissions, your repo cannot fully connect to Netlify and run continuous builds or deploys.
To resolve this repo connection error, someone with “Edit Subscription” permissions needs to
relink the Azure repo
to Netlify.
To gain the necessary permissions to link and fully connect site repos in your Azure project or organization to Netlify, ask your Azure admin to upgrade your permissions. Your Azure admin can upgrade your permissions in one of the following ways:
Add you to the
Project Administrator group
on Azure DevOps.
Add you to the
Project Collection Administrators or Organization Administrators
group.
Grant these
specific permissions
to your user.
#
Relink your Azure repo to complete repo setup
If you have the necessary Azure permissions, you can relink your Azure repo to Netlify to fully connect the repo.
To relink your Azure repo to Netlify and enable continuous builds and deploys:
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
. Then select
Manage repository
and
Link to a different repository
.
Choose a repo to connect to Netlify. The same Azure repo that failed to connect can be reselected.
To confirm that continuous builds and deploys are now working, create a new deploy and check your deploys page in the Netlify UI.
#
Azure repos don’t load when importing an existing project
If your Azure repos don’t load when importing an existing project, ensure
Third-party application access via OAuth
is enabled for your organization. Learn more at
Manage a policy for Azure DevOps
.
#
Site never builds or deploys new changes after initial setup deploy
If Netlify detects that the Azure user account used to connect your site repo to Netlify does not have adequate permissions, then your site repo cannot fully connect to Netlify and run continuous builds or deploys.
Azure user accounts used to connect a site repo to Netlify must have “Edit Subscription” permissions in the Azure project or organization that owns the site repo. If you have the necessary Azure permissions, you resolve this error by
relinking your Azure repo on Netlify
.
#
New changes don’t build or autopublish
If your latest changes don’t build or autopublish, there may be an issue with your Azure DevOps connection. For repositories in Azure organizations, ensure
Third-party application access via OAuth
is enabled for your organization. Learn more at
Manage a policy for Azure DevOps
.
#
Site stops building and deploying
If the user who authorized Netlify’s connection to an Azure repo no longer has access to the repo, then your site may stop building and deploying. A new user with access to the repository will need to link the Netlify site to the Azure repo again to reauthorize Netlify.
To
link
your Netlify site to your Azure repo again, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
, and select
Link to a different repository
. You can choose the same repository you previously connected to Netlify.
#
Access other repositories at build
If you need to fetch contents from other repositories, public or private, you’ll need to make some accommodation for this. The two most common methods for accessing other repositories during the build are
Git submodules
and
npm packages
.
#
Git submodules
To include an outside repository as a subdirectory in your own repository,
always configure it as a
submodule
. If you do not, it may work locally using cloning, but the sub-repository content will not be pushed to your Git provider, and it will not be available to your build on Netlify.
If a submodule repository is
public
, you can use
https
format (for example,
https://github.com/owner/project
) to link it in your submodule configuration. If the repository is
private
, or if you prefer to use
ssh
format (for example,
git@github.com:owner/project.git
), you will need to follow the instructions below to
generate a deploy key
in Netlify and add it to the submodule repository settings.
#
Git submodule limitations
Netlify doesn’t support recursive submodules. If you include a submodule that has a submodule, Netlify won’t detect and clone the secondary submodule during the build process. You can try to work around this by including
Git’s
--recursive
option flag
when setting up a submodule with a submodule, but doing so may result in unintended failures resulting from the submodule chain’s configuration.
Netlify doesn’t support client-side Git hooks and won’t run Git hooks from a submodule. Learn more about
Git hooks
.
#
Deploy keys
Submodule repositories linked in
ssh
format,
including all private submodule repositories
, require an SSH key called a
deploy key
(
in GitHub
and
in GitLab
),
access key
(
in Bitbucket
), or
SSH key
(
in Azure DevOps
).
SSH keys are actually a pair of keys: one private, and one public. To generate a new key pair for a Netlify site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Deploy key
, and select
Generate public key
. Netlify will store the private key and provide the public key for you to add to the repository settings for your submodule.
Azure DevOps SSH key setup
Since SSH keys on Azure DevOps are connected to a user and not a repo, consider adding the SSH key to a user that you do not expect to remove from your Azure organization. Some teams even create shared Azure DevOps user accounts.
#
npm packages
You can reference public or private repositories formatted as
npm packages
in your
package.json
file
dependencies
. Private repository modules require a special link syntax that varies by Git provider.
For GitHub, create a
GitHub personal access token
with read-only access, and include it in the package URL as follows:
"package-name"
:
"git+https://oauth2:<github_token>@github.com/<user>/<repo>.git"
For GitHub Enterprise Server, create a
GitHub personal access token
with read-only access, and include it in the package URL as follows:
"package-name"
:
"git+https://<github_token>:x-oauth-basic@<self-hosted-instance.url>/<user>/<repo>.git"
For GitLab, create a
GitLab deploy token
with
read_repository
access, and include it in the package URL as follows:
"package-name"
:
"git+https://<token-username>:<token>@gitlab.com/<user>/<repo>.git"
For GitLab self-managed, create a
GitLab deploy token
with
read_repository
access, and include it in the package URL as follows:
"package-name"
:
"git+https://<token-username>:<token>@<self-hosted-instance.url>/<user>/<repo>.git"
For Bitbucket, create a
Bitbucket app password
with read-only access, and include it in the package URL as follows:
"package-name"
:
"git+https://<user>:<app-password>@bitbucket.org/<user>/<repo>.git"
For Azure DevOps, create an
Azure DevOps personal access token
with read-only access, and include it in the package URL as follows:
"package-name"
:
"git+https://<azure_token>@dev.azure.com/<organization>/<project>/_git/<repo>"
Keep tokens private
You can avoid committing access tokens in public repositories by storing them as
environment variables
in your site or team settings.
#
Community resources
To get help or join the discussion, visit our Forums for a verified Support Guide on
accessing other repositories in the build environment
.
Last updated: May 13, 2025
←
Git overview
Self-hosted Git
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- image-cdn_overview.txt --------
Start of file
URL: https://docs.netlify.com/image-cdn/overview/
Scraped_At: 2025-06-02T19:58:25.739761

Contact
Forums
Contact support
With Netlify Image CDN, you can transform images on demand without impacting build times. Netlify Image CDN also handles content negotiation to use the most efficient image format for the requesting client. Optimizing the size and format of your images improves both the runtime performance and reliability of your site. Transformations are integrated natively into the CDN so that repeated requests leverage layers of caching for improved performance.
To
transform an image
, make a request to
/.netlify/images
with query parameters that specify the source asset and the desired transformations.
After an image is transformed, the result is uniquely cached on our edge and future requests for the same transformation will serve the cached asset. We also cache the source image so that future transformations don’t have to download it again. By default, Netlify Image CDN respects
atomic deploys
. If you change a previously transformed source image in a new deploy, we re-run transformations on new requests so that we don’t serve outdated assets.
Many frameworks on Netlify use Netlify Image CDN to power image optimization and transformation. You can use Netlify Image CDN directly as described below or review our
framework support
details and benefit from Netlify Image CDN through your framework’s built-in image handling.
#
Transform images
Use query parameters on your requests to
/.netlify/images
to specify the following transformation options:
source
size
fit
position
format
quality
You must specify a
source asset
with the
url
parameter as described below. All other parameters are optional.
Query validation and response codes
When a request is made to
/.netlify/images
, we validate the query parameters.
If any transformation parameters have invalid values, we return a
404
.
If the query parameters are valid and the request is for a new transformation, we return a
200
with the requested content and content-type.
If the request is for a previously transformed image, we return a
304
.
For interactive examples of the different parameters, visit our
demo site
.
#
Source
You must specify a source image with the
url
parameter. You can use either a
relative
or a
remote
path to your source image.
Source-only transformations
If you include only a source
url
in your transformation request, we don’t change the size or shape of your image. But, we do transform the
format
to
avif
or
webp
according to which formats are supported by the user’s browser.
#
Relative path
No configuration is required for relative paths to source images.
Here’s an example transformation request using a relative path to an image on the site’s domain.
# transform the source image deployed at https://mysitename.netlify.app/owl.jpeg
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg'
As mentioned above, Netlify Image CDN respects atomic deploys by default. If you change a previously transformed relative source image in a new deploy, we re-run transformations on new requests so that we don’t serve outdated assets.
#
Remote path
To transform a source image hosted on another domain, you must first configure allowed domains in your
netlify.toml
file using the
images
key.
[
images
]
remote_images
=
[
"https://my-images.com/.*"
,
"https://animals.more-images.com/[bcr]at/.*"
]
The
remote_images
property accepts an array of regex. If your images are in specific subdomains or directories, you can use regex to allow just those subdomains or directories. Note that you need to double-escape regex in
netlify.toml
files. For example, the string
https://
can convert to a regex as
https:\/\/
but you should specify it in
netlify.toml
as
https:\\/\\/
. One way to double-escape regex is to use JavaScript’s
.toString()
RegExp method.
After configuring allowed domains for remote images, you can request transformations of assets hosted on the allowed domains. Here’s an example transformation request using a remote path to an image on another domain.
# transform the source image hosted at https://my-images.com/owl.jpeg
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=https://my-images.com/owl.jpeg'
Since remote source images are hosted outside of your site’s Netlify deploys, they aren’t automatically invalidated with atomic deploys. Remote source images are cached based on their
max-age
cache control directives with a minimum retention of 30 minutes. To work around this and refresh your remote source images as if they were part of your atomic deploys, use cache-busting URLs. One way to create a cache-busting URL is to make the filename include an asset fingerprint, for example:
https://my-images.com/owl_SHA_OF_THE_IMAGE.jpeg
.
#
Size
To change the size of an image, use the following parameters with integers to specify the target size in pixels.
w
:
width
h
:
height
# resize the image to 50 px wide
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg&w=50'
How these parameters are applied depends on the
fit
option for the request. By default,
fit=contain
.
#
Fit
To control how an image is resized, use the
fit
parameter. Supported values are as follows:
contain
(default)
cover
fill
The
fit
parameter works in conjunction with the
w
and
h
size
parameters. The
fit
value affects things such as whether or not the aspect ratio is maintained and whether or not the requested dimensions are always returned.
# resize and crop the image to 50 pixels square
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg&fit=cover&w=50&h=50'
Here’s a comparison of the different
fit
options. They each behave in the same way as their equivalent
CSS
object-fit
values. For more information, including example images, read the option-specific sections below.
fit=
source aspect ratio always maintained
excess pixels cropped
requested dimensions always returned
contain
yes
no
no, one dimension may be smaller
cover
no
yes
yes, image scaled proportionally before cropping
fill
no
no
yes, image stretched and squished if needed
#
fit=contain
(default)
Fit within the specified dimensions and maintain the source aspect ratio by resizing the image proportionally. If you supply just one dimension, the other is calculated to maintain the aspect ratio of the source image. If you supply two dimensions and the target aspect ratio is different than the source aspect ratio, one dimension of the resulting image matches the requested size while the other is smaller.
#
fit=cover
Fill the specified dimensions without distortion by resizing the image proportionally, then cropping out any excess pixels. By default, the center of the image is retained with the left and right or top and bottom cropped evenly. To control what part of the image is retained, use the
position
parameter.
To use
fit=cover
, you must supply both
w
and
h
.
#
fit=fill
Fill the specified dimensions exactly. If the target aspect ratio is different than the source aspect ratio, the image is stretched and squished as needed to fill the target dimensions.
#
Position
To control how an image is cropped when
fit=cover
, use the
position
parameter. Supported values are as follows:
top
bottom
left
right
center
(default)
The value represents what part of the image to retain when cropping.
# resize the image and retain the left side when cropping
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg&fit=cover&w=50&h=50&position=left'
#
Format
To change the format of an image, use the
fm
parameter. Supported values are as follows:
avif
jpg
png
webp
- can be static or animated.
gif
- can be static or animated.
blurhash
- returns a string that you can use to render a blurred placeholder image. Visit
BlurHash
to learn more.
# convert a jpeg into png
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg&fm=png'
# resulting image includes an appropriate `content-type` response header
<
HTTP/2
200
<
content-type: image/png
If you don’t specify a format, we inspect the
Accept
header for content negotiation with the following logic:
use
webp
if accepted
otherwise, use
avif
if accepted
if neither is accepted, use the original format
#
Quality
To control the output quality of a lossy conversion, use the
q
parameter. This applies when the target
format
is
avif
,
jpg
,
gif
, or
webp
.
The
q
parameter supports whole integers from
1
to
100
. The default is
75
.
# convert a jpeg into avif with medium quality
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/owl.jpeg&fm=avif&q=50'
#
Redirects and rewrites
You can use
redirects and rewrites
with Netlify Image CDN. This can be helpful, for example, if you want to reuse the same parameters for multiple images.
Loading error: Refresh the page to access this code sample
/transform-small/* /.netlify/images?url=/:splat&w=50&h=50 200
[
[
redirects
]
]
from
=
"/transform-small/*"
to
=
"/.netlify/images?url=/:splat&w=50&h=50"
status
=
200
With the above redirect in place, you can make transformation requests like the following:
# transform the source image deployed at https://mysitename.netlify.app/owl.jpeg
# to a size of 50px wide by 50px high per the parameters in the redirect
curl
-vs
'https://mysitename.netlify.app/transform-small/owl.jpeg'
Cross-site redirects are not recommended
Cross-site redirects for image transformations are not recommended. They could negatively impact your site’s performance.
#
Custom headers
You can use
custom headers
with Netlify Image CDN. This can be helpful, for example, if you want to customize
browser caching
behavior.
You can apply custom headers to source images on the site’s domain. It’s not currently possible to apply custom headers from the site to source images hosted on another domain. However, Netlify will respect any cache headers an external domain sends with the source images.
Note that
Cache-Control
headers on source images only apply to browsers and CDNs in front of Netlify and not the Netlify Cache itself.
To use custom headers with Netlify Image CDN, apply header rules to your source images.
Loading error: Refresh the page to access this code sample
/source-images/*
  Cache-Control: public, max-age=604800, must-revalidate
[
[
headers
]
]
for
=
"/source-images/*"
[
headers.values
]
Cache-Control
=
"public, max-age=604800, must-revalidate"
Headers you set for a source image are applied to the transformed and optimized assets served by Netlify Image CDN.
For example, the above headers will apply when you make this transformation request:
# transform the source image deployed at https://mysitename.netlify.app/source-images/owl.jpeg
curl
-vs
'https://mysitename.netlify.app/.netlify/images?url=/source-images/owl.jpeg'
#
Local development
Use
Netlify Dev
to test image transformations locally. This feature of the Netlify CLI runs a local development server that mimics the Netlify production environment, including Netlify Image CDN.
#
Framework support
The following frameworks offer built-in image optimization tools that we support through integrations with Netlify Image CDN. You can use your framework’s standard image handling syntax and get extra performance optimizations from Netlify Image CDN. For all other frameworks, you can use Netlify Image CDN directly as described above.
Framework
Prerequisites
Remote path
allowlist
Angular
None.
NgOptimizedImage
automatically uses Netlify Image CDN.
[images] remote_images
in
netlify.toml
Astro
None. Astro’s
<Image />
component automatically uses Netlify Image CDN.
image.domains
or
image.remotePatterns
in
astro.config.mjs
Gatsby 5.13 or later
Set environment variable
NETLIFY_IMAGE_CDN
to
true
and use the Contentful, Drupal, or WordPress source plugins.
[images] remote_images
in
netlify.toml
Gatsby 5.11 or earlier
Set environment variable
NETLIFY_IMAGE_CDN
to
true
and use the Contentful, Drupal, or WordPress source plugins.
[images] remote_images
in
netlify.toml
Next.js
If using Next.js 13.5 or later and Next.js adapter v5.
remotePatterns
property in
next.config.js
Nuxt
None. The
nuxt/image
module automatically uses Netlify Image CDN.
image.domains
option in
nuxt.config.ts
#
Limitations
Keep the following limitation in mind when working with Netlify Image CDN:
Split Testing
is not supported. You may get inconsistent image results between your split test branches.
Netlify Image CDN is not currently supported as part of our HIPAA-compliant hosting offering. For more information, visit our
Trust Center
and download our reference architecture for HIPAA-compliant composable sites on Netlify.
Last updated: January 8, 2025
Create an integration
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- images_connect-how-connect-works-diagram-1.png.txt --------
Start of file
URL: https://docs.netlify.com/images/connect-how-connect-works-diagram-1.png
Scraped_At: 2025-06-02T19:58:27.162760

Content not found (no specific selectors matched or body tag missing).
###End of file##

-------- images_connect-syncing-data.png.txt --------
Start of file
URL: https://docs.netlify.com/images/connect-syncing-data.png
Scraped_At: 2025-06-02T19:58:28.204227

Content not found (no specific selectors matched or body tag missing).
###End of file##

-------- index.txt --------
Start of file
URL: https://docs.netlify.com/
Scraped_At: 2025-06-02T19:56:15.141463

Contact
Forums
Contact support
Ship, build, & scale faster with any modern frontend stack
Platform
Get started
Follow our
step-by-step tutorial
Explore solutions for specific use cases with our
Developer Guides
.
Jump into a working example with our
Astro site template
Platform Primitives
Build with primitives to create custom runtime features on our edge network. For example, use primitives to give your site:
Faster site performance through Advanced Caching
Simplified asset management with Blob Storage
Automatic optimization of images through Image CDN
Explore Platform Primitives
Frameworks
Use your favorite frontend framework with Netlify.
We support the latest features in frameworks–including
Astro
,
Angular
,
Next.js
,
Nuxt
,
TanStack
,
Vite
, and a
dozen others
–with zero-config deployments.
Explore framework support
What's new?
Building MCP servers with Netlify
Preview Servers
Internationalization with Edge Functions & Astro
Browse more guides
Browse more videos
Support
Get help
Use the following resources to get help with your Netlify sites and accounts:
Ask Netlify
is our generative AI assistant that can answer general questions about Netlify.
The support forums
include answers to common questions and issues.
Explore
help resources
and get tips for
requesting support
by email.
Or use
email support
if you're on a paid plan.
Changelog
Keep up with the latest updates by checking out:
Our
official changelog
for high-level updates and feature releases
The Developer Hub's
activity feed
for guide updates, tips, and feature releases
Feature updates from the Netlify Forums
for breaking changes to existing features and new feature updates
###End of file##

-------- integrations_contentful-integration.txt --------
Start of file
URL: https://docs.netlify.com/integrations/contentful-integration/
Scraped_At: 2025-06-02T19:58:29.216616

Contact
Forums
Contact support
Contentful
is a headless Content Management System (CMS) built with an API-first architecture. You can upload content to Contentful, then organize and edit it on the Contentful
web app interface
.
Connect your Netlify site with a Contentful space using the Contentful Integration to streamline the way you work with your CMS and Netlify. With this integration, the
Netlify app on your Contentful space
installs once you connect your Netlify site to Contentful, so you can redeploy updated content in fewer steps, and without having to manually create webhooks.
#
Before you begin
To get started integrating Contentful with your Netlify site, make sure you have the following prerequisites:
an
account
with Contentful
a Contentful
space
to connect with a site
a site on Netlify that pulls content from Contentful
To use the features of the integration, your Contentful space needs
content type
and
content
already populated.
#
Get started with Contentful
In the Netlify UI, navigate to the
Extensions
page for your team.
Search for
Contentful
and select it in the search results.
On the details page, select
Install
.
Next, on the details page, select
Connect
to launch the authorization flow.
Log in, if needed, to Contentful.
Configure your account access and select the Contentful organization to grant Netlify access to. Then, select
Authorize access
to complete authorization. This reroutes you back to the Netlify UI.
#
Connect a site to your Contentful space
When you connect a space to your Netlify site, the Netlify app installs in the sidebar of your Contentful space. This enables you to redeploy your site from the Contentful UI when you update content.
To configure a connection for a site in the Netlify UI:
From your team’s
Sites
list, select the site you plan to use with Contentful, and navigate to
Project configuration
>
General
>
Contentful
.
In the
Select a space
menu, choose your desired Contentful space.
In the
Select a trigger
menu, choose how you want to redeploy your site for updates:
When entry published only
When entry published, unpublished, or deleted
Select
Configure
.
In addition to installing the Netlify app on your Contentful space, a successful connection generates a webhook linked to your Netlify site.
You can edit the settings for the webhook at any time from the Netlify UI by navigating to
Project configuration
>
General
>
Contentful
, then following the webhook link under
Connection status
to navigate to the webhook settings in Contentful.
#
Test your connection
Navigate to your Contentful space and select
Content
to access your entries. Select the content name to open more details. Find the Netlify app on your Contentful space in the sidebar if your connection is successful.
If you add a new
content type
after enabling the integration, you’ll need to
manually install
the Netlify app on your Contentful space for that content type.
#
More resources
Contentful documentation
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- integrations_extend-netlify.txt --------
Start of file
URL: https://docs.netlify.com/integrations/extend-netlify/
Scraped_At: 2025-06-02T19:58:30.091081

Contact
Forums
Contact support
There are a number of ways to add on to the Netlify platform — whether it’s for your own use or something you want to make available to others.
Searching for options to add on to your Netlify site?
If you’re a Netlify user looking for information about the available extensions and integrations that you can use with your teams and sites, refer to the
extensions and integrations overview
doc.
#
Framework adapters
If you are a framework author, you can integrate with Netlify using the
Frameworks API
. Use the API to build a framework adapter and define how a framework deploys sites to Netlify.
#
General extensions
For all other use cases, we recommend using the
Netlify SDK
to create an extension. An extension can integrate with other systems, add on to the Netlify platform, or both.
For example, you may develop an extension that renders a configuration form in the Netlify UI and uses the input values to connect to and sync data from a content management system to Netlify Connect.
You can develop an extension that does the following:
runs logic during the build-deploy lifecycle for a site
injects serverless functions and edge functions into a site
syncs data from a data source to Netlify Connect
authenticates users with an OAuth identity provider
creates bespoke extension UI surfaces for your users that we’ll render in the Netlify UI
Refer to the
Netlify SDK
docs to learn how to develop, test, and publish an extension for Netlify.
If you’re interested in becoming a partner and collaborating with us on a project to extend Netlify, contact us through our
technology partner program
.
Last updated: October 2, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- integrations_overview.txt --------
Start of file
URL: https://docs.netlify.com/integrations/overview/
Scraped_At: 2025-06-02T19:58:31.026013

Contact
Forums
Contact support
Expand the capabilities of your site with extensions and integrations available through Netlify. Whether you need to sync data from a content management system (CMS), start a site from a template, or add authentication using a third-party service, Netlify can help you connect to and install solutions.
Interested in creating your own extension or integration? Learn more about your options in our
extend Netlify
doc.
#
Add on to your Netlify site
Discover new tools for your site under
Extensions
in the Netlify UI.
In the
Directory
, you will find extensions published by Netlify, our official partners, and members of the community. Netlify reviews and approves all extensions before we list them in the directory.
You can also select
Created by your team
to find private extensions that your team owns.
You might also be able to access an extension through a direct link. If the extension has a
private
or
unlisted
badge, the extension is available for use but please note that Netlify has not reviewed it. Make sure to review the author, extension code, and documentation carefully before proceeding.
You can also get started with a
template with built-in extensions
to get up and running faster.
#
Extension types
There are two categories of extensions in the directory:
Official
: extensions built and supported by Netlify or one of our
technology partners
.
You can find documentation for extensions built by Netlify on this docs site and get support for them through Netlify’s official support channels. For support with extensions built by partners, please refer to each extension’s details page for links to documentation and support channels.
Community
: extensions built by other members of the community. The author is responsible for providing documentation and support for these extensions.
For all extensions, you can find high-level documentation along with links to more details and contact information on the extension’s details page in the Netlify UI.
Private and unlisted extensions are not reviewed by Netlify
As a Netlify user, you may encounter links to extensions that aren’t listed in the extensions directory — identified through a
private
or
unlisted
badge. Netlify does not review private and unlisted extensions. You can install and use these extensions on your team but we recommend that you review the author, code, and documentation carefully before you begin.
#
Available extensions
The following extensions are available now through the extensions directory in the Netlify UI.
#
Official extensions built by Netlify
Async Workloads
Auth0 by Okta
Content Security Policy
Contentful integration
LaunchDarkly integration
Optimizely Edge Delivery extension
PlanetScale integration
Supabase integration
Turso
Data integrations for Netlify Connect
:
commercetools
Contentful
Contentstack
Drupal
Salesforce Commerce Cloud
Shopify
WordPress
#
Official extensions built by our partners
You can find the following official extensions built by Netlify partners in the
Extensions
directory:
Adobe Experience Manager
Agility CMS
Arcjet
DigitalOcean
Jamsocket
LambdaTest
Nile
Squid Cloud
#
Community extensions
Search for community extensions by navigating to
Extensions
in the Netlify UI.
Searching for something else?
Along with the above extensions, we offer a number of other
integrations, apps, and tools
that you can install and use with your sites. These aren’t listed in the extensions directory but are available through other parts of the Netlify platform.
#
Install an extension
Team Owners can install extensions.
In the Netlify UI, navigate to your team’s
Extensions
page.
Search for the extension you wish to install and select it.
On the extension’s detail page, select
Install
.
Once installed on your team, follow the extension’s documentation to configure it for your individual sites, data layers in Netlify Connect, and more.
#
Uninstall an extension
Team Owners can uninstall extensions. Note that uninstalling an extension will impact any sites, data layers, or projects that use that extension.
In the Netlify UI, navigate to your team’s
Extensions
page.
Select
Installed
.
Find the extension you wish to uninstall and select it.
Navigate to the
Danger zone
section on the extension’s detail page, and then select
Uninstall this extension
.
#
Other integrations, apps, and tools
Along with the above extensions, there are a number of other options available for expanding the functionality of your sites on the Netlify platform. These include integrations, plugins, apps, and templates.
Follow the links below to learn how to install and configure these options for your teams and sites:
Content Source Interface (CSI) modules for Visual Editor
:
Contentful
DatoCMS
Git CMS
Sanity
Email Integration
GPT action
Netlify App for Slack
Netlify Build Plugins
Lighthouse build plugin
Netlify Templates
#
Make your own extension or integration
Interested in creating your own extension or integration? Learn more about your options in our
extend Netlify
doc.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_function-metrics.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/function-metrics/
Scraped_At: 2025-06-02T19:58:31.896378

Contact
Forums
Contact support
Function Metrics give you insights into the performance, reliability, and usage patterns of functions on your site.
To explore Function Metrics for your site, go to
Metrics
>
Function Metrics
.
#
Use cases
By analyzing success and error rates alongside other metrics such as invocation count and function duration, you can optimize performance, troubleshoot issues, and make data-driven decisions to enhance the overall quality and user experience of your projects.
Optimize performance.
Identify performance bottlenecks by analyzing function duration metrics. By pinpointing functions with high average durations or extreme long tails (as indicated by p95 and p99 durations), you can target your optimization efforts.
Troubleshoot errors.
Find functions with high error rates and drill into the logs to troubleshoot. By observing error rates over time, you can detect trends, enabling proactive problem-solving before errors escalate. With deploy markers on the timeline, you can discover if a spike in errors is associated with a specific change and then rollback to an earlier deploy while you fix the issue.
Prioritize development efforts.
Understand function invocation patterns to allocate your time more efficiently. By analyzing which low-performing functions receive the most invocations, you can focus on making high-impact improvements.
#
Metric definitions
Invocations:
requests to your serverless function endpoints. A request to a function path that results in a cached response being served does not count as an invocation.
Errors:
responses from function endpoints with
5xx
status codes.
Successes:
responses from function endpoints with non-
5xx
status codes.
Average duration:
mean compute time.
p50:
50% of invocations were completed within this time.
p95:
95% of invocations were completed within this time.
p99:
99% of invocations were completed within this time.
Percentiles and data granularity
Values for
p50
,
p95
, and
p99
are calculated as an average of hourly percentile scores.
#
Filter your data
Focus on the events and information that you care about by filtering your data.
#
Deployed functions
By default, Function Metrics charts include all functions on the production branch. You can change this in a few ways:
Use the filter menus to pick a different
Branch
, focus on a specific
Function
, or do both depending on your needs.
Select a
Function name
in the
Distribution by function
chart to scope the
Invocations
chart to just that function.
#
Time frame
By default, Function Metrics charts are scoped to the last 24 hours. You can change the time frame in a couple of ways:
Use the
Time frame
menu to select a different range. Note that
data retention
varies by team plan.
Zoom in by clicking and dragging your desired range in the
Invocations
chart.
#
Response codes
By default, the
Invocations
chart is faceted by
Success / Error
. In these groupings, all
5xx
response codes are considered errors and all other response codes are considered successes. You can instead facet the chart by
All Statuses
for more granular data.
In both cases, you can focus on specific response types with facet filters. Here are some examples:
When the chart is faceted by
Success / Error
, you can filter it to just the
Error
data. Filtering the chart to just errors can help you identify patterns and trends that might otherwise be too small to detect when successes are also included in the chart.
When the chart is faceted by
All Statuses
, you can filter it to one or more specific status codes, such as
428
. Filtering the chart to a specific status code can help you troubleshoot specific scenarios, such as missing preconditions.
#
Logs
You can drill into function logs for more information in a few ways:
In the
Invocations
chart, use the
Go to Logs
link.
When the chart includes
All functions
, the link takes you to the function logs index for your site.
When the chart is scoped to a single function, the link takes you to that specific function’s logs filtered to the same time frame you were exploring in Function Metrics.
In the
Distribution by function
chart, use the link on the
Errors
rate.
These links take you to the specific function’s logs filtered to the same time frame you were exploring in Function Metrics.
Older logs may no longer be available
Note that
function metric retention
is different than
function log retention
. If your metrics charts are zoomed in to a time frame in the past, function logs may no longer be available for that period.
#
Inspect a deploy on your chart
When the
Invocations
chart is zoomed in to 3 days or less, it includes
deploy markers
to help you correlate patterns in your metrics with changes to your production code. Deploy markers are displayed as grey vertical lines in the chart.
To inspect deploys, do the following:
Make sure the
Invocations
chart is zoomed in to 3 days or less so that deploy markers are included in it.
Select a deploy marker to reveal a description based on the pull/merge request title or commit message.
Use the link on the deploy description to go to the relevant deploy details page where you can find a deploy summary and deploy log.
#
Data retention and freshness
Metrics are retained for at least 7 days even after new function deployments. The metric retention period increases to 30 days for Core Pro and Enterprise
plans
.
We update Function Metrics data on an ongoing basis. There are a few minutes of delay between when an invocation completes and when the metrics data is updated. You will need to refresh your browser to load the updates.
#
Limitations
Function Metrics do not include data for the following:
On-demand Builders
Background Functions
local invocations
triggered while running
netlify dev
or
netlify functions:serve
#
Next steps
After identifying patterns, trends, spikes, or other points of interest with Function Metrics you can go deeper with other monitoring tools knowing you’re focusing your efforts on impactful areas.
Function logs
.
Examine per-invocation log statements and messages in a filterable interface.
Log Drains
.
Perform flexible queries in third-party monitoring services.
Last updated: May 13, 2025
←
Real User Metrics
Monitor builds
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_lighthouse.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/lighthouse/
Scraped_At: 2025-06-02T19:58:32.739921

Contact
Forums
Contact support
Improve your site’s performance and user experience by monitoring Lighthouse scores and reports from the convenience of your deploys page in the Netlify UI.
Lighthouse is an open source tool designed for testing different aspects of your site’s web performance, SEO, accessibility, and more. By default, Lighthouse uses a mobile-first testing approach and simulates a user’s visit to your site on a mobile device to calculate Lighthouse scores.
Lighthouse also offers practical recommendations for improving your site’s Lighthouse scores and the overall performance and user experience of your site through Lighthouse reports. Learn more about
Lighthouse
.
On Netlify, you can review embedded Lighthouse scores and reports for each site deployment when you
install Netlify’s Lighthouse build plugin
for
compatible sites
. From your site’s deploy details page, you can review your deploy’s Lighthouse scores and a Lighthouse report.
To review more details for a Lighthouse score category, select the category score from the Lighthouse report.
Additionally, you can review how Lighthouse scores have changed across previous deploys of your site from your site’s deploys list.
(Lighthouse scores displayed on your site’s deploys list may not be available on all
plans
.)
#
Set up embedded Lighthouse scores and reports for your site
To enable Lighthouse results in the Netlify UI (and not just the deploy log), you need to install Netlify’s Lighthouse build plugin version 3.2.1 or higher. Previous Lighthouse build plugin versions only support showing Lighthouse scores in your deploy log.
You can install the plugin for your site from the
Project configuration
>
Build & deploy
>
Build plugins
section or in a
netlify.toml
file. For the most
customization options
, including the option to audit different URL paths for your site, we recommend installing the Lighthouse plugin with a
netlify.toml
file.
Once you install the Lighthouse build plugin, Lighthouse scores and reports will appear for new builds in the Netlify UI and your deploy log.
You will also find Lighthouse scores in the
deploy notification comment
on your pull/merge requests along with your Deploy Preview link:
We recommend you keep your Lighthouse build plugin updated for the best experience. To upgrade your plugin, check out our docs on
managing plugin versions
.
#
Advanced configuration options
You can further customize how the Netlify Lighthouse build plugin audits your site and how scores and reports appear in the Netlify UI.
For example, you can run Lighthouse performance testing for desktop, run audits for different site URLs, or generate Lighthouse results in other languages. For these updates and other advanced configuration options, you’ll need to update your site’s
netlify.toml
file. Learn more in the
Lighthouse build plugin
README.md
.
#
Limitations
The Lighthouse build plugin with embedded UI support includes these known limitations:
Sites or site paths that require visitors to log in are not supported.
If you are using Netlify’s Lighthouse build plugin with an Eleventy (11ty) site, you may encounter a build error. Learn more about how to
fix this build error
.
For best compatibility with Node.js versions, we recommend using a version labeled as Long Term Support (LTS). Later Node.js versions may not work as expected.
Last updated: May 13, 2025
←
Monitor builds
Logs
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_log-drains.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/log-drains/
Scraped_At: 2025-06-02T19:58:34.017966

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
The Log Drains feature allows you to connect site traffic logs,
function logs
, and
edge function logs
from Netlify’s CDN to third-party monitoring services for analysis, alerting, and data persistence. Additionally, this feature allows you to connect
deploy logs
from our builds service.
Once you’ve configured a log drain for a site, Netlify batches the site’s log records from our CDN and build system and posts them to an endpoint in JSON/NDJSON format in near real-time. A configured external monitoring provider receives these records from the intake endpoint and makes them available for processing. You can drain the following data:
site traffic log output
:
tracks visitor requests for assets and pages.
function log output
:
tracks information such as function invocations.
edge function log output
:
tracks edge functions that output console log statements.
deploy log output
:
tracks deploy information gathered while building and deploying a site.
Web Application Firewall (WAF) log output
:
tracks
WAF
rules matching requests.
If your site will handle HIPAA-regulated data, visit our
Trust Center
to download and read our reference architecture for HIPAA-compliant composable sites on Netlify before configuring a log drain.
#
Configure a log drain
To set up a log drain, you must be a Netlify Team Owner and have an account and API key provisioned with an external monitoring provider. Netlify supports integration with:
Datadog
New Relic
Axiom
Azure Monitor
Sumo Logic
Splunk Observability Cloud
Logflare
Amazon Simple Storage Service (Amazon S3)
General HTTP endpoints
Select your external monitoring provider:
Datadog
New Relic
Axiom
Azure Monitor
Sumo Logic
Splunk Observability Cloud
Logflare
Amazon S3
General HTTP endpoint
Datadog
New Relic
Axiom
Azure Monitor
Sumo Logic
Splunk Observability Cloud
Logflare
Amazon S3
General HTTP endpoint
#
Datadog
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Datadog
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, select the
Region
where your
Datadog site
is located.
Enter the unique
API key
for your logging service provider account. Verify that you are entering your
API key
instead of the Datadog application key.
Optional: add key/value pairs under
Tags
to tag your logs with certain attributes. These become query parameters in requests to the logs intake endpoint.
Available keys for Datadog:
Key
Tag Description
Example value
ddtag
tags associated with logs, grouped into a single list with the value
ddtags
env:prod
service
name of the application or service generating the log events
mysubdomain
Select
Connect
.
#
New Relic
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
New Relic
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, select the
Region
that applies to your New Relic account.
Enter a
License API key
, also called
INGEST-LICENSE
, for your New Relic account. Verify that you’re entering your License API key and not your License API key ID or
user key
.
Optional: to add a tag for your log drain, under
Tags
, enter the
key
and
value
. Then select
Add tag
. Any tags you add become query parameters in log drain requests to New Relic.
Example tags for New Relic:
Key
Value
Tag description
environment
production
environment type
service
mysubdomain
name of the application or service generating the log events
For guided help on optimizing your New Relic dashboard for your site’s logs, install the
Netlify Logs quickstart
on New Relic.
Select
Connect
.
#
Axiom
To configure a log drain that sends your site logs to Axiom:
On Axiom, go to
Integrations
.
Install Netlify’s Axiom integration, which opens a prompt to authorize the Axiom app to access Netlify on your behalf.
Once installed, you’re redirected to configure your Netlify integration on Axiom. Copy the Axiom integration token.
On Netlify, for your chosen site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Axiom
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, paste the
Integration token
copied from Axiom.
Confirm with
Connect
.
For an overview of reviewing your logs on Axiom, check out
Axiom’s Netlify Integration docs
.
#
Azure Monitor
To send your site’s log drains to Azure Monitor through the Netlify UI:
On Azure Monitor, from your log analytics workspace, go to
Settings
>
Agents
. Under the
Log Analytics Agent Instructions
dropdown, you’ll find the
Workspace ID
and
Primary key
you’ll need to enter into the Netlify UI.
On Netlify, for your chosen site, go to
Logs
>
Log Drains
. If this is your first log drain for your site, select
Enable a log drain
.
Select
Azure
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, enter your Azure
Workspace ID
and
Primary key
.
Confirm with
Connect
.
For an overview of reviewing your logs on Azure, check out
Azure’s Analytics workspace docs
.
#
Sumo Logic
To configure a log drain that sends logs to your Sumo Logic account, you need to:
Configure your HTTP Logs and Metrics Source in Sumo Logic
Set up the log drain in the Netlify UI
#
Configure your HTTP Logs and Metrics Source in Sumo Logic
If you haven’t already, create a
hosted collector
to collect your data in Sumo Logic.
In the Sumo Logic web app, add and configure your HTTP Logs and Metrics Source using
Sumo Logic’s docs
.
Ensure that you copy your
HTTP Source Address
to use in the Netlify UI.
#
Set up the log drain in the Netlify UI
For security, Netlify hides the full
HTTP Source Address
in the Netlify UI. After you configure your log drain, only the base URL is visible in the Netlify UI.
On Netlify, for your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Sumo Logic
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, fill in the
Full URL
field using the
HTTP Source Address
you copied from Sumo Logic.
Select
Connect
.
#
Splunk Observability Cloud
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Splunk Observability Cloud
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, enter the
Realm
from your Splunk Observability Cloud profile.
Enter the
Access Token
from your Splunk Observability Cloud settings.
Select
Connect
.
#
Logflare
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Logflare
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, enter your Logflare Ingest
API key
.
To specify where you want your logs to go, enter the Logflare
Source ID
for your logs.
Select
Connect
.
#
Amazon S3
To configure a log drain that sends logs to your Amazon S3 account as Gzip-compressed files, you need to:
Create an Amazon S3 bucket and set up a bucket policy
Configure the log drain in the Netlify UI
#
Create an Amazon S3 bucket and set up a bucket policy
In the AWS Management Console,
create an S3 bucket
.
Object Ownership
for the bucket should be set to either
Bucket owner enforced
or
Bucket owner preferred
.
Make note of the bucket name to use in your Netlify configuration.
Go to your bucket’s
Permissions
and under
Bucket policy
select
Edit
.
Copy and paste the following bucket policy, replacing
YOUR_BUCKET_NAME
with the name of your Amazon S3 bucket:
{
"Version"
:
"2012-10-17"
,
"Statement"
:
[
{
"Sid"
:
"NetlifyLogDrains"
,
"Effect"
:
"Allow"
,
"Principal"
:
{
"AWS"
:
"arn:aws:iam::128866310339:role/log-shipper"
}
,
"Action"
:
"s3:PutObject"
,
"Resource"
:
"arn:aws:s3:::YOUR_BUCKET_NAME/*"
,
"Condition"
:
{
"StringEquals"
:
{
"s3:x-amz-acl"
:
"bucket-owner-full-control"
}
}
}
]
}
Select
Save Changes
.
Bucket lifecycle
For cost control reasons, we recommend deleting logs after a period of 90 days. You can configure your Amazon S3 bucket to delete logs automatically by
setting lifecycle rules
.
#
Configure the log drain in the Netlify UI
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
Amazon S3
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, select the
Bucket region
where your bucket is located.
Enter your S3
Bucket name
.
Enter your S3
Bucket path
. We recommend using
YOUR_BUCKET_NAME/logs/netlify/
.
Select
Verify bucket and connect
.
Use the provided path to navigate to your S3 bucket’s verification file.
Copy and paste the contents of the file into the
Verification token
field, then select
Verify
.
#
General HTTP endpoint
Netlify’s General HTTP endpoint support allows you to set up a custom log drain with any external monitoring provider that accepts log drain requests in JSON or NDJSON format.
To set up a custom log drain, you must provide a full URL of your external monitoring provider’s endpoint. Depending on your external monitoring provider, you can enter your API key as a query parameter in your endpoint or you can enter an Authorization header in the Netlify UI.
For example, this URL includes an API key and a tag as query parameters:
http://YOUR_ENDPOINT_RESOURCE_PATH?api-key=YOUR_API_KEY&environment=production
For security, Netlify hides the full endpoint in the Netlify UI. After you configure your log drain, only the base URL is visible in the Netlify UI.
For your selected site, go to
Logs
>
Log Drains
and select
Enable a log drain
.
Select
General HTTP endpoint
as the
Log drain service
.
Select the
Log types
to drain. You can drain your site’s traffic logs, function logs, edge function logs, and deploy logs.
Optional: add
Traffic log filtering
. If you’re draining traffic logs and don’t want
client_ip
and
user_agent
in the data, select
Exclude personally identifiable information (PII)
.
Under
Service settings
, enter the
Full URL
for your endpoint, including any optional tags as query parameters. Depending on your external monitoring provider, enter your API key as a query parameter in your endpoint or under
Authorization header
.
Select the
Log Drain Format
that your endpoint accepts.
Select
Connect
.
#
Edit a log drain
If you need to adjust the settings for an existing log drain, under
Logs
>
Log Drains
, select
Configure
. Configuration changes become active within approximately five minutes.
To stop sending specific log data to your external monitoring provider, clear the
Log types
you no longer need and then save your change.
#
Remove a log drain
To terminate an existing log drain configuration for a site, under
Logs
>
Log Drains
, select
Delete
. All log types associated with the site’s log drain will be removed. Saved logs are accessible in your logging service provider account.
#
Traffic log output
Drained site traffic logs include the following fields parsed from our CDN logs:
account_id
:
ID of the Netlify team that the site belongs to.
client_ip
:
IP address of the client. Omitted if you selected
Exclude personally identifiable information (PII)
.
content_type
:
Content-Type
of the request (for example,
text/html
).
country
:
country of origin for the request, formatted as an ISO 3166-1 two-letter code.
deploy_id
:
ID of the deploy (for example,
61153ae8b0f6a900088386e8
).
duration
:
duration of processing the request and sending the response, in milliseconds.
firewall_rule
:
the Firewall traffic rule that matches the request.  Can be one of
default_allow
,
default_deny
,
ip_allow
,
ip_deny
,
geo_allow
,
geo_deny
, or
-
.  If there are no traffic rules added to a site, then
firewall_rule
returns
-
. Learn more about
Firewall traffic rules
.
block_reason
:
indicates why the request was blocked. If there are rate limiting rules applied to the site and if the rules match the request, then
block_reason
returns
rate_limit
. Learn more about
Rate limiting Rules
.
rate_limit
:
rule_id
:
ID of the rate limiting rule the request matched. Learn more about
Rate limiting Rules
.
[Deprecated]
rule_id
:
ID of the rate limiting rule the request matched. This field is being deprecated and will disappear in a future release, use
rate_limit.rule_id
instead.
log_type
:
indicates the type of log. The value is
traffic
.
method
:
request method.
referrer
:
referrer
on the request.
request_id
:
Netlify request ID (for example,
01FDWR77JMF2DA1CHF5YA6H07C
).
request_size
:
size of the request in bytes.
response_size
:
size of the response in bytes.
site_id
:
ID of the site.
status_code
:
status code of the HTTP response.
timestamp
:
timestamp of the request, formatted with RFC 3339 (for example,
2021-08-24T18:54:34.831Z
).
url
:
URL of the request.
user_agent
:
user-agent
that made the request. Omitted if you selected
Exclude personally identifiable information (PII)
.
waf
:
outcome
:
indicates the outcome of the request evaluated by
Web Application Firewall (WAF)
. Can be one of
passive
,
blocked
,
under threshold
, or
no match
.
When WAF is enabled in passive mode and a request matches a WAF rule, the outcome is
passive
.
When WAF is enabled in blocking mode and a request matches enough WAF rules to surpass the anomaly threshold, then the outcome is
blocked
. Otherwise, the outcome is
under threshold
.
When WAF is enabled in passive or blocking mode, and a request does not match any enabled WAF rules, the outcome is
no match
.
rule_id
:
ID of the matched Web Application Firewall rule.
policy_id
:
ID of the WAF policy applied to the evaluated request.  The WAF policy represents all enabled WAF rules or rulesets and any additional configuration, such as excluded paths or whether the passive or blocked mode are enabled.
rule_set_id
:
ID of the ruleset applied to the evaluated request.
#
Function log output
Drained
function logs
include the following fields parsed from our CDN logs:
account_id
:
ID of the Netlify team that the function belongs to.
branch
:
the branch of the deploy.
deploy_id
:
ID of the deploy (for example,
61153ae8b0f6a900088386e8
).
duration
:
amount of time it took for AWS Lambda to execute the function.
function_name
:
name of the function.
function_type
:
type of function (for example,
regular
for a synchronous function or
background
for a background function). Note this value may be
standard
for functions deployed before November 5, 2024, independent of the underlying type.
level
:
level of the log line (for example,
INFO
,
ERROR
,
WARN
,
REPORT
).
message
:
log message.
log_type
:
field indicating the type of log. All function types will have the value
functions
.
method
:
method of the request (for example, GET).
path
:
path of the request (for example,
/.netlify/functions/your-awesome-function
).
request_id
:
Netlify request ID (for example,
01FDWR77JMF2DA1CHF5YA6H07C
).
site_id
:
ID of the site.
status_code
:
status code of the HTTP response.
timestamp
:
timestamp of the request, formatted with RFC 3339 (for example,
2021-08-24T18:54:34.831Z
).
#
Function log output limitations
Netlify’s Log Drains feature doesn’t currently support function log output for Background Functions. We recommend storing historical logs for this type of function on an external service.
Function log output is limited to 4 KB total per invocation. If a log’s output exceeds 4 KB, only the last 4 KB of the log is sent to the logging service and the log message will be truncated.
#
Edge Function log output
Drained
edge function logs
include the following fields parsed from our CDN logs:
account_id
:
ID of the Netlify team that the edge function belongs to.
branch
:
name of the branch. This field is only present for non-production branches.
deploy_id
:
ID of the deploy (for example,
61153ae8b0f6a900088386e8
).
function_name
:
name of the edge function.
function_type
:
type of function. The value for edge function logs is
edge
.
level
:
level of the log line (for example,
INFO
,
ERROR
,
WARN
,
REPORT
).
log_type
:
field indicating the type of log. All function types, including edge functions, will have the value
functions
.
request_id
:
Netlify request ID (for example,
01FDWR77JMF2DA1CHF5YA6H07C
).
request_path
:
path of the request (for example,
/log
).
site_id
:
ID of the site.
timestamp
:
timestamp of the request, formatted with RFC 3339 (for example,
2021-08-24T18:54:34.831Z
).
Log messages will appear in the content field for your logging service.
#
Deploy log output
Drained
deploy logs
include the following fields parsed from our internal build logs:
account_id
:
ID of the Netlify team that the deploy belongs to.
deploy_id
:
ID of the deploy (for example,
61153ae8b0f6a900088386e8
).
deploy_section
:
section of the deploy process (for example,
Initializing
,
Building
,
Deploying
,
Cleanup
,
Post-Processing
).
level
:
level of the log line (for example,
INFO
,
ERROR
,
WARN
,
REPORT
).
log_type
:
field indicating the type of log. The value is
deploys
.
message
:
log message.
site_id
:
ID of the site.
timestamp
:
timestamp of the log line, formatted with RFC 3339 (for example,
2021-08-24T18:54:34.831Z
).
#
WAF log output
Drained
WAF
logs include the following fields:
site_id
:
ID of the site.
deploy_id
:
ID of the deploy (for example,
61153ae8b0f6a900088386e8
).
account_id
:
ID of the Netlify team that the site belongs to.
policy_id
:
ID of the evaluated WAF policy, which defines the WAF rules to be evaluated.
timestamp
:
timestamp of the request in Unix epoch nanosecond format (for example,
1725353586606141655
).
action
:
type
:
indicates the final action taken for the request, can be one of
LOG
or
BLOCK
.
request
:
id
:
Netlify request ID (for example,
01FDWR77JMF2DA1CHF5YA6H07C
).
method
:
request method.
protocol
:
request HTTP protocol, can be one of
HTTPS
or
HTTP
.
url
:
URL of the request.
connection_ip
:
The IP used to create the connection to Netlify. Omitted if you selected
Exclude personally identifiable information (PII)
.
client_ip
:
IP of the original client if the request originates from a known source (such as Cloudfront). In those cases, the
connection_ip
will refer to the known source's outgoing IP, and
client_ip
refers to the request handled by known source. If the request does not come from a known source,
client_ip
and
connection_ip
are the same. Omitted if you selected
Exclude personally identifiable information (PII)
.
location
:
country
:
full name of the country of origin for the request.
size
:
size of the request in bytes.
response
:
status
:
HTTP status of the response (for example,
200
).
size
:
size of the response in bytes.
rule_sets
:
list with information about each ruleset evaluated for the request. Each item on the list has the following format:
id
:
ID of the ruleset (for now always
crs-basic
).
version
:
version of the ruleset (for example,
v1.0.0
).
mode
:
indicates how the ruleset was evaluated, can be one of
passive
or
block
.
outcome
:
indicates the outcome of the request evaluated by Web Application Firewall (WAF). Can be one of
under_threshold
,
blocked
,
passive
or
no_match
.
When the request's calculated score was lower than the threshold needed to trigger the set action, the outcome is
under_threshold
, and no block was applied.
When the request was blocked because it was over the anomaly threshold, the outcome is
blocked
.
When the request is over the anomaly threshold but the ruleset is set to passive mode, the outcome is
passive
.
When the request matched no rules, the outcome is
no_match
.
anomaly_score
:
the anomaly score calculated for the overall request.
anomaly_threshold
:
the anomaly threshold set for the overall request.
anomaly_score_per_category
:
the anomaly score calculated for each rule category of the evaluated request.
anomaly_threshold_per_category
:
the anomaly threshold set for each rule category (only set if defined by the user).
matched_rules
:
list with information about the rules that matched for this ruleset. Each item on the list has the following format:
rule_id
:
ID of the rule.
labels
:
list of labels for the matched rule, obtained from the CRS definition (for example,
["platform-multi", "attack-protocol", "paranoia-level/1"]
).
metadata
:
list with information about the rule matching logic and the input provided from the request. Each item on the list has the following format:
matcher_type
:
type of the matcher being used on the rule, each one matching on a different type of input. Can be one of
header
(a single HEADER-VALUE pair),
cookie
(full value of the cookie header of the request),
path
(request path),
method
(request method),
query
(decoded request query),
protocol
(request protocol),
uri
(decoded request URI),
uri_raw
(encoded request URI),
header_names
(names of the request headers),
cookie_names
(names of cookies - the key on each key-value pair),
query_string
(encoded request query),
query_names
(names of the request query - the key on each key-value pair) or
request_line
(HTTP plaintext representation of the request line, for example
GET /background.png HTTP/1.0
.)
match_on
:
textual representation of the rule matcher being evaluated (for example,
KEY Host, VALUE EQUALS 0
).
value
:
input value matched for this rule matcher.
error
:
if there was an error evaluating the rule (only set if an error occurred).
Last updated: May 13, 2025
←
Logs
Notifications
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_monitor-builds.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/monitor-builds/
Scraped_At: 2025-06-02T19:58:35.004562

Contact
Forums
Contact support
You can check your team’s current builds status and get insights into historical builds usage by visiting your team’s
Builds
tab.
#
Current status
On the main
Builds
page, you’ll find a list of all of your team’s builds and their current state such as completed, building, or
enqueued: awaiting capacity
.
Select any build to visit its detail page where you can examine the
deploy log
,
cancel the deploy
, and more.
The
Concurrent builds
numbers show how much of your
build capacity
you’re currently using. If you have any builds that are enqueued awaiting capacity, there will be an alert message with details on how many builds are waiting for capacity.
#
Prioritize a build
This feature is available on
Enterprise
plans.
If you have a build waiting in your
team build queue
that you would like to build sooner, team-wide
Developers and Owners
can prioritize the build so that it runs as soon as the next space opens in your team
build capacity
.
To prioritize a build, go to your team
Builds
page and select the build you want to prioritize, then select
Build next
.
After confirming your choice, the build will be marked
Enqueued: Prioritized
, along with the name of the team member who prioritized it, and the time it was prioritized. The action is also tracked in the
team audit log
.
Your prioritized build will begin when the next active build completes. If you would like the build to start immediately, you can cancel an active build to make room in your team build capacity.
Only one build can be prioritized at a time. If any team member selects a new build to prioritize, it will replace the currently prioritized build.
#
Historical insights
Switch to the
Usage & insights
page for more information about your team’s builds usage. Here you’ll find data on how your build minutes have been used including the sites that have accrued the most build time. This data updates hourly. You will need to refresh your browser to load the updates.
You can examine the
Build minutes used per day
and
Number of builds per day
charts to explore day-level details.
In the
Top sites
chart, you can select the name of any site to visit the site’s dashboard.
#
Account usage insights
You can find additional data about your team’s builds under
Billing
>
Account usage insights
. Learn more about
usage and insights
.
#
Team usage summary
For a quick summary of your team’s usage, go to your team’s
Projects
page and check out the usage metrics above your sites list. Select a metric widget to expand its details.
On the
Builds
card, you can find a condensed list of the latest team builds and their current state.
#
More resources
Learn more about concurrent builds and build minutes in our
Billing
doc.
Visit our Forums for a verified Support Guide on
optimizing what and how you build
to reduce build queueing and make the most of your build minutes. You can even temporarily
stop builds
for a site if needed. Focusing these efforts on the
Top sites
revealed on the
Usage & insights
page is likely to have the most impact since those sites are accruing the most build time.
Last updated: May 13, 2025
←
Function Metrics
Lighthouse
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_notifications.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/notifications/
Scraped_At: 2025-06-02T19:58:35.872309

Contact
Forums
Contact support
Netlify provides a variety of custom and default notifications to help you monitor your sites.
#
Slack notifications
Set up Slack notifications for your team or site’s activity with the
Netlify App for Slack
, which allows you to track changes to:
You can create subscriptions with this app to track changes to:
DNS zone and domain events
Netlify team configuration changes
Netlify team membership events
Deploy state changes. You can refine these events by
deploy context
or
deploy state
Environment variable events
Form submissions
Site configuration changes
Netlify Drawer activity
#
Deploy notifications
Set up deploy notifications to track a specific site’s deploy activity. Send deploy notifications to email, a pull/merge request, or an external web service. Note that you can also get notified of deploy state changes in Slack.
For example, you can send notifications for these deploy events:
Deploy started
Deploy succeeded
Deploy failed
Deploy deleted
Deploy locked
Deploy unlocked
Previously successful deploy failed
Previously failed deploy succeeded
For a full list of deploy events supported by Deploy notifications, check out the
Deploy notifications
docs.
#
Form notifications
Form submission notifications
inform you about new verified form submissions. You can configure notifications for individual forms or for all forms on your site.
Note that you can also get notified of form submissions in
Slack
.
#
Build settings notifications
If you
stop or activate builds
for your site, Netlify will notify all site members by email.
#
Usage and billing notifications
By default, Netlify sends
site add-on usage notifications
when any site add-on is enabled, as usage for a metered feature approaches level limits, and more. These are sent to the
billing email
you set for your team.
Last updated: October 2, 2024
←
Logs
Status badges
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_project-analytics.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/project-analytics/
Scraped_At: 2025-06-02T19:58:36.657772

Contact
Forums
Contact support
With Netlify Project Analytics, you can get a deeper understanding of your projects by monitoring trends in site/app visitor activity.
Server-side data collection
for Project Analytics complies with the
General Data Protection Regulation (GDPR)
, has no impact on site performance, is not stopped by ad blockers, and does not require any extra configuration.
#
Get started
To enable Project Analytics for your project, go to
Metrics
>
Project Analytics
and select
Enable Analytics
.
Once enabled for your project, data collection begins once your project is first deployed. Up to 30 days of historical data will be backfilled in your charts.
#
Charts
Pageviews:
instances of your project’s pages being served.
Unique visitors:
different IP addresses engaging with your project.
Top locations:
locations where your project has had the most pageviews.
Top pages:
pages of your project that have had the most pageviews.
Top resources not found:
resource requests for your project that returned the most
404
errors.
Top sources:
URLs that generated the most traffic to your project.
Bandwidth used:
how much data has been served by our CDN for your project.
By default, Project Analytics charts are scoped to the last 30 days.
Filters
are available for other time spans.
The
Pageviews
and
Unique visitors
charts plot daily metrics. You can examine the charts to explore day-level details. Data for the current day updates hourly.
In the
Top locations
chart, you can examine the map to explore pageview counts for all locations.
In the
Top pages
and
Top sources
charts, you can select the URL of any source or page to visit it in a new tab. Similarly, in the
Top resources not found
chart, you can select the URL of any resource to visit the
404
page served for it in a new tab.
The
Bandwidth used
chart plots daily metrics. You can examine the chart to explore day-level details about your project’s
bandwidth usage
. Data for the current day updates hourly.
#
Filters
Filters allow you to check your Analytics data over the span of
30 days
,
7 days
, or
24 hours
.
You can review your Analytics data from the last 30 days in 7-day or 24-hour increments by choosing the
7 days
or
24 hours
filter and then selecting
Previous
.
#
30 days filter
By default, the Analytics page loads all available data for the last
30 days
.
#
7 days filter
To scope Analytics data to the last 7 days, select the
7 days
filter. To review data for other 7-day periods within the last 30 days, select
Previous
.
Charts using the
7 days filter
plot daily metrics. You can examine the charts to explore day-level details. Data for the current day updates hourly.
#
24 hours filter
To scope the data to the last day, select the
24 hours
filter. Both the range and granularity of the data will update and all data on the page will be scoped to the last day by default.
To review data for other 24-hour periods within the last 30 days, select
Previous
.
Charts plot hourly metrics. You can examine the charts to explore hour-level details.
Visit our
Forums
to get inspired, ask questions, and share ideas and feature requests about Netlify Analytics.
#
Remove Project Analytics
To cancel the Project Analytics service for a project, go to
Metrics
>
Project Analytics
>
Danger zone
. Select
Cancel Project Analytics service
.
Project Analytics charts for your project will no longer be available.
Last updated: May 13, 2025
How it works
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_real-user-metrics.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/real-user-metrics/
Scraped_At: 2025-06-02T19:58:37.398994

Contact
Forums
Contact support
This feature is available on
Pro
and
Enterprise
plans.
Real User Metrics allows you to understand and prioritize the real-world experience of your site visitors.
With Real User Metrics, you can identify the production deploys that most impact your site’s usability and understand site performance based on Web Vitals that rely on real user interactions with your production site.
#
Overview
Real User Metrics surfaces the following Web Vitals based on real user interactions with your site.
Web Vitals Metric
Measurement focus
Quick definition
Largest Contentful Paint (LCP)
Loading experience for largest assets
How quickly the page completely loads
First Input Delay (FID)
Interactivity and responsiveness
How quickly the browser responds to a user interaction that relies on JavaScript, such as a click or tap
Interaction to Next Paint (INP)
Responsiveness as the latency of a user’s click, tap, or keyboard interaction
How quickly the page responds to user interaction. Learn more about INP at the
web.dev docs
.
Cumulative Layout Shift (CLS)
Visual stability
How much the layout changes as a proxy for the visual stability of your site
First Contentful Paint (FCP)
Loading speed
How quickly the first parts of a page load
These metrics are based on user-centric Web Vitals and include Core Web Vitals. Learn more about these metrics from
web.dev
.
INP will replace FID
The Core Web Vital metric First Input Delay (FID) will be deprecated in March 2024 from Core Web Vitals and replaced by Interaction to Next Paint (INP). Learn more in the
web.dev docs
.
#
How Real User Metrics are collected
Real User Metrics collects user-centric Web Vitals based on real site vistor activity and aggregates this data for you along with production deploy details.
Unlike
Lighthouse
, which relies on synthetic testing, Real User Metrics takes a
real user monitoring
approach.
Once a Team Owner or Developer enables Real User Metrics for your site, Netlify injects a JavaScript snippet into the HTML of your production site to collect these Web Vitals events.
The JavaScript snippet is minified and injected with an
async
attribute before the closing
</body>
tag and so it’s expected that there will be very little to no detected impact to site performance for users.
Once enabled, Real User Metrics does not require additional configuration or cookies on the client browser. Note that Ad blockers do not prevent real User Metrics from being collected.
Real User Metrics is best for busy sites with many visitors as it aggregates site visitor
experiences. This avoids the subway effect, where one user on a subway who experiences a poor web experience doesn’t
dramatically offset the results.
For a deeper understanding of your site performance, we recommend using Netlify’s analytics tools together. Here’s a quick overview of how these tools compare.
Real User Metrics
Project Analytics
Lighthouse
Offers overview of site usability based on site visitor interactions and user-centric Web Vitals
Offers general overview of site usage, such as pageviews, number of unique visitors, top locations, etc. with adjustable time scales
Offers usability scores based on Web Vitals
Only for production site
Only for production site
Can apply to all site deploys
Gives insights after deploying to production
Gives insights after deploying to production
Gives insights before deploying to production and after
Most useful for high traffic sites
Useful for any site
Useful for any site
Offers real-world insights
Offers real-world insights
Offers insights based on synthetic testing
#
Enable Real User Metrics for your site
To enable Real User Metrics for your site:
From your
Site overview
page, go to
Metrics
>
Real User Metrics
.
Select
Enable Real User Metrics
.
After you enable Real User Metrics for your site, data collection will start the next time your site is visited.
Real User Metrics data is populated in your charts in one hour increments.
Be aware that your data will not populate until people first visit your site. So if no one visits your site, then your charts will stay empty with no data.
Data is not backfilled, and is collected on production deploys only.
If you turn off Real User Metrics for your site, you lose the metrics on your Real User Metrics dashboard. If you turn Real User Metrics back on, you must wait for new data to update your dashboard.
#
Inspect a deploy on your chart
Expand details about a specific production deploy from your Real User Metrics Chart to understand how your deploy impacts the real-world experience of your site visitors.
To inspect a specific deploy from a chart:
Select a gray column (also called a deploy marker) in your chart.
Once you select a deploy, the deploy description appears based on a pull/merge request or commit message.
To open the deploy details page for your selected deploy, select the deploy description text. The deploy details page offers a deploy summary and your deploy log.
#
Review Real User Metrics for different sites
To quickly review Real User Metrics for different sites, use the site switcher to change site data for your Real User Metrics dashboard.
Note that Real User Metrics must be enabled for each site individually.
#
Filter your data
Find the specific events and performance metrics that matter most to you with the following filters:
Timeframe
Device type
Percentiles
#
Timeframe
By default, Real User Metrics charts are scoped to the last 7 days.
To review your metrics in a more granular timeframe, you can click and drag your desired time frame in a Real User Metrics chart.
#
Device types
By default, the Real User Metrics charts are scoped to an aggregate from all device types.
To understand how your site performs on different device types, use the device filter above your charts to scope data to mobile or desktop devices.
#
Percentiles
By default, the Real User Metrics charts will display scores for the 75th, 95th, and 99th percentiles of all of your site’s page loads. You can expand details for the minimum, average, and maximum metric results.
To focus on the percentiles that matter most to you, choose which percentiles to feature in all of your site’s Real User Metrics charts. To set your chart percentiles, select one or more percentiles at the bottom of any chart.
#
Understand your scores
Each Real User Metrics category (LCP, CLS, INP, FID, FCP) has a score range for acceptable performance.
To help you quickly gauge your site’s performance, we apply score status badges to each chart using
Good
,
Mid
,
Poor
, or
Needs improvement
.
When calculating the overall status of LCP, CLS, INP, FID, FCP for your production site, Netlify only considers metrics within the 75th percentile of all of your production site’s page loads.
Score category
Good range
Mid range
Poor range
Largest Contentful Paint (LCP)
< 2500 ms
2500 - 4000 ms
> 4000 ms
Cumulative Layout Shift (CLS)
< 0.1
0.1 - 0.25
> 0.25
Interaction to Next Paint (INP)
< 200 ms
200 - 500 ms
> 500 ms
First Input Delay (FID)
< 100 ms
100 - 300 ms
> 300 ms
First Contentful Paint (FCP)
< 1800 ms
1800 - 3000 ms
> 3000 ms
How is the layout shift score calculated?
The layout shift score is calculated using this formula:
Layout shift score = impact fraction x distance fraction
.
#
Improve your scores and your site’s user experience
Improve the user-centric Real User Metrics for your site by checking out these guidelines from
web.dev
.
#
Content Security Policy support
If your site is using a Content Security Policy (CSP), you must add
script-src netlify-rum.netlify.app
to your CSP rule in your
_headers
or
netlify.toml
file to ensure Real User Metrics can run for your site.
#
Example
_headers
file
/*
  Content-Security-Policy: [...] script-src https://netlify-rum.netlify.app
#
Example
netlify.toml
file
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
Content-Security-Policy
=
"[...] script-src https://netlify-rum.netlify.app"
Learn more about using the
Content Security Policy
.
#
Troubleshoot Real User Metrics
If you are not finding any Real User Metrics data for a site, consider the following:
Does your site have a Content Security Policy (CSP)? If so, you’ll need to make an
update to your CSP configuration
.
Does your site get very little traffic? If so, be aware that your data will not populate until people first visit your site.
#
Disable Real User Metrics
Once disabled, Real User Metrics charts for your site will no longer be available.
If you decide to turn Real User Metrics back on, you need to wait for new Real User Metrics data since your charts will not backfill data.
To disable the Real User Metrics service for a site, go to
Metrics
>
Real User Metrics
. At the bottom of the page, select
Disable Real User Metrics
.
Last updated: May 13, 2025
←
Project Analytics
Function Metrics
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- monitor-sites_status-badges.txt --------
Start of file
URL: https://docs.netlify.com/monitor-sites/status-badges/
Scraped_At: 2025-06-02T19:58:38.315014

Contact
Forums
Contact support
Status badges are visual representations of your site’s status, served as image files you can add to repository READMEs, documentation, or any other web page.
The
deploy status badge
automatically updates to show the status of a site’s most recent
production or branch deploy
:
#
Add status badges
Follow these steps to get a specific image URL for your site’s status badge and add it to a repository README, your documentation, or any other web page.
In the Netlify UI, select a specific site, then go to
Project configuration
>
General
>
Status badges
.
Copy the automatically generated markdown snippet and paste it into your repository README or markdown source for any website.
Optionally, to create a status badge for a deployed branch, add the
?branch=
query parameter to the badge image URL. For example, if the branch name is
dev
, the image URL would end with
/deploy-status?branch=dev
.
Commit the changes to your README or deploy the website containing the markdown snippet.
When a user encounters the status badge in your README or website, the badge will reflect the current status of your site’s most recent production or branch deploy. Selecting the status badge takes a user to your site’s
Deploys
page.
Last updated: May 13, 2025
←
Notifications
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_cache-api.txt --------
Start of file
URL: https://docs.netlify.com/platform/cache-api/
Scraped_At: 2025-06-02T19:58:39.614398

Contact
Forums
Contact support
This feature is in
Beta
.
Store responses from web requests made from
Functions
and
Edge Functions
, making your application more performant, resilient and cost-efficient.
The Cache API is a great companion to Netlify’s
fine-gained cache controls
, giving you the power to cache entire routes as well as their individual components.
Built entirely on web standards, it works seamless with any web framework — or without one.
#
Overview
The Cache API is a programmatic interface for reading and writing HTTP responses to a cache using the standard
CacheStorage
and
Cache
JavaScript APIs.
Just like
Functions
and
Edge Functions
, the Cache API operates on
Request
and
Response
objects and has first-class support for the
Fetch API
.
You can use the Cache API to cache any resource on the web, whether it's hosted on Netlify or any other provider.
#
Features
The Cache API uses standard
cache control headers
to determine the cache behavior for a response. This includes how long it can be cached for, how it's matched against a request and how it can be invalidated.
Responses are automatically invalidated once their expiration time (defined by the
max-age
or
s-maxage
directives) has elapsed
Responses can be manually invalidated by calling the
delete()
method
or by purging any
cache tags
set on the response
Responses stored with the Cache API are not replicated across regions, meaning that any functions and edge functions running on a given region all share the same cache data, but that data isn’t shared with any functions or edge functions running on a different region
Responses stored with the Cache API are automatically invalidated when your site is redeployed
Requests to the Cache API are automatically routed to the closest region for optimal performance
#
API reference
The Cache API offers the following methods, a subset of the standard
CacheStorage
and
Cache
APIs.
#
caches.match
Retrieves a response from any of the
Cache
instances, if found.
const
response
=
await
caches
.
match
(
request
)
;
#
Parameters
request
:
the request for which you are attempting to find responses in the caches; this can be a
Request
object or a URL string
#
Return value
A
Promise
that resolves to the
Response
associated with the first matching request in any of the caches. If no match is found, the
Promise
resolves to
undefined
.
#
caches.open
Opens a named cache instance where you can store and retrieve responses.
The name parameter defines a namespace for a specific set of cached responses. You should use something meaningful for your application context.
Keep in mind that responses aren't shared between caches, so using multiple names can fragment your cache and reduce your hit ratio.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
#
Parameters
name
:
name of the cache
#
Return value
A
Promise
that resolves with a
Cache
instance.
#
cache.add
Takes a URL, retrieves it, and adds the resulting response object to the given cache.
This is an instance method of a
Cache
object that must be created with
caches.open()
.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
await
cache
.
add
(
request
)
;
#
Parameters
request
:
a request for the resource you want to add to the cache; this can be a
Request
object or a URL string
#
Return value
A
Promise
that resolves with
undefined
.
#
cache.addAll
Takes an array of URLs, retrieves them, and adds the resulting response objects to the given cache.
This is an instance method of a
Cache
object that must be created with
caches.open()
.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
const
responses
=
await
cache
.
addAll
(
requests
)
;
#
Parameters
request
:
an array of requests for the resource you want to add to the cache; these can be a
Request
object or a URL string
#
Return value
A
Promise
that resolves with
undefined
.
#
cache.delete
Finds a response that matches the given request and deletes it from the cache.
This is an instance method of a
Cache
object that must be created with
caches.open()
.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
await
cache
.
delete
(
request
)
;
#
Parameters
request
:
the request you are looking to delete from the cache; this can be a
Request
object or a URL
#
Return value
A
Promise
that resolves with
true
.
#
cache.match
Retrieves a response from the cache, if found.
This is an instance method of a
Cache
object that must be created with
caches.open()
.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
const
response
=
await
cache
.
match
(
request
)
;
#
Parameters
request
:
the request for which you are attempting to find responses in the cache; this can be a
Request
object or a URL string
#
Return value
A
Promise
that resolves to the
Response
associated with the first matching request in the cache. If no match is found, the
Promise
resolves to
undefined
.
#
cache.put
Adds a response to the cache.
This is an instance method of a
Cache
object that must be created with
caches.open()
.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
await
cache
.
put
(
request
,
response
)
;
#
Parameters
request
:
the request to be added to the cache; this can be a
Request
object or a URL string
response
:
the
Response
you want to match up to the request
#
Return value
A
Promise
that resolves with
undefined
.
#
Utility methods
The
@netlify/cache
module offers a set of utility methods that you can use on top of the base API to perform common tasks more easily. To use them, start by adding the module to your project using the
package manager of your choice
:
npm install @netlify/cache
#
fetchWithCache
Returns a response for the given request if it's found in the cache. If not, a new request is made and the response is added to the cache.
It's a drop-in replacement for the
standard
fetch
method
with an additional optional parameter for configuring the cache settings of the response that is added to the cache. These options override any conflicting cache settings that the response may define.
fetchWithCache
(
resource
)
;
fetchWithCache
(
resource
,
cacheSettings
)
;
fetchWithCache
(
resource
,
options
)
;
fetchWithCache
(
resource
,
options
,
cacheSettings
)
;
#
Parameters
response
:
the resource that you wish to fetch; this can be either a string, a
URL
object
or a
Request
options
:
a standard
RequestInit
object
containing any custom settings that you want to apply to the request
cacheSettings
:
an object with the different cache settings to be set, with support for the following properties:
durable
: A boolean indicating whether to persist the response in the
durable cache
overrideDeployRevalidation
: Opts out of
automatic invalidation with atomic deploys
by specifying one or more cache tags that can be used for
on-demand invalidation
swr
: The value for
the
stale-while-revalidate
directive
, representing the amount of time (in seconds) after the response has expired during which it can still be served while it's revalidated in the background
tags
: List of
cache tags
to add to the response
ttl
: The value for the
s-maxage
directive, representing the maximum amount of time (in seconds) that Netlify will cache the response
vary
: An object containing the parts of the request
to vary on
, with support for one or more of the following properties:
cookie
: List of cookies to vary on
country
: List of countries to vary on, with nested arrays representing
or
conditions
header
: List of headers to vary on
language
: List of languages to vary on, with nested arrays representing
language combinations
query
: List of URL query parameters to vary on or
true
to vary on all query parameters
#
Return value
A
Promise
that resolves to a
Response
object.
#
Example
This example shows how you might use the
fetchWithCache
utility method to either retrieve a response from the cache or fetch it from the network. When the response is fetched from the network, it is then added to the cache with a set of options.
import
{
fetchWithCache
,
DAY
}
from
"@netlify/cache"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
response
=
await
fetchWithCache
(
"https://example.com/expensive-api"
,
{
ttl
:
2
*
DAY
,
// Two days
tags
:
[
"product"
,
"sale"
]
,
vary
:
{
cookie
:
[
"ab_test_name"
,
"ab_test_bucket"
]
,
query
:
[
"item_id"
,
"page"
]
}
}
)
;
return
response
;
}
;
export
const
config
:
Config
=
{
path
:
"/fetchwithcache-example"
}
;
#
getCacheStatus
Extracts information from the
Cache-Status
header about how the response has interacted with the different components of Netlify's global caching infrastructure.
The returned value makes it straightforward to differentiate cached and uncached responses, which is especially useful when measuring performance.
getCacheStatus
(
cacheStatusHeader
)
;
getCacheStatus
(
headers
)
;
getCacheStatus
(
response
)
;
#
Parameters
cacheStatusHeader
:
a string containing the values of the
Cache-Status
header you want to inspect
headers
:
a
Headers
object containing the
Cache-Status
header you want to inspect
response
:
the
Response
object containing the
Cache-Status
header you want to inspect
#
Return value
An object containing the following properties:
hit
: a boolean indicating whether the response has been served from a Netlify cache
caches
: an object with granular information about the different Netlify caches:
durable
: an object describing how the response has interacted with the
durable cache
:
hit
: a boolean indicating whether the response has been served by the durable cache
stale
: a boolean indicating whether the response matched a stale entry in the cache (i.e. older than the specified age settings)
stored
: a boolean indicating whether the response has just been stored in the durable cache
ttl
: the number of seconds left before the response's expiration date; a negative number represents how long ago the response has expired
edge
: an object describing how the response has interacted with the
edge cache
:
hit
: a boolean indicating whether the response has been served by the edge cache
stale
: a boolean indicating whether the response matched a stale entry in the cache (i.e. older than the specified age settings)
#
Example
This example shows how you might use the
getCacheStatus
utility method to determine whether a response was retrieved from the cache, including information about which of Netlify's caching layers has served the response.
import
{
fetchWithCache
,
getCacheStatus
}
from
"@netlify/cache"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
response
=
await
fetchWithCache
(
"https://example.com/expensive-api"
)
;
const
{
hit
,
edge
,
durable
}
=
getCacheStatus
(
response
)
;
if
(
hit
)
{
console
.
log
(
"Served from the cache:"
)
console
.
log
(
`
- Edge cache:
${
edge
?.
hit
?
"hit"
:
"miss"
}
`
)
;
console
.
log
(
`
- Durable cache:
${
durable
?.
hit
?
"hit"
:
"miss"
}
`
)
;
}
else
{
console
.
log
(
"Served from the network:"
)
console
.
log
(
`
- Edge cache:
${
edge
?.
stale
?
"stale"
:
"not found"
}
`
)
;
console
.
log
(
`
- Durable cache:
${
durable
?.
stale
?
"stale"
:
"not found"
}
`
)
;
}
return
response
;
}
;
export
const
config
:
Config
=
{
path
:
"/getcachestatus-example"
}
;
#
Usage with frameworks
The Cache API has been designed to work seamlessly with any web framework that deploys to Netlify. For the best development experience possible, that are a few important things to note.
The
CacheStorage API
is exposed through the
caches
global variable, as defined by the spec. The API isn't part of Node.js though, which means this variable usually isn't available in Node.js environments.
On Netlify, we expose it automatically in the Netlify Functions and Netlify Edge Functions runtimes, both on live sites and locally with
Netlify Dev
.
However, some frameworks have a setup where functions are not used in local development; or you might choose to run your framework's own development command and not use the Netlify CLI altogether. In those cases, the
caches
global will not be set and trying to access it will cause an error.
To get around that, you can import it from
the
@netlify/caches
package
.
import
{
caches
}
from
"@netlify/cache"
;
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
await
cache
.
set
(
"https://example.com"
,
new
Response
(
"Hello"
)
)
;
Using this import does not change the functionality in any way, and does not require any further code changes. It's only required for local development in certain setups.
We're working with framework maintainers to make this global variable part of their local development servers, at which point you'll be able to completely remove the import.
#
Limits
There is a limit to how many Cache API operations you can perform on a single serverless function or edge function invocation:
Maximum number of cache lookups per invocation: 100
Maximum number of cache insertions or deletions per invocation: 20
If you exceed any of these limits, any subsequent cache lookups will not return any response and any insertions or deletions will not actually modify the state of the cache.
When multiple edge functions run for a given request, these limits are shared by all the edge functions.
The limits are not shared between serverless functions and edge functions, which means that each group of functions will have their own quota.
#
Notes and limitations
Keep the following limitations in mind when working with the Cache API:
The
stale-while-revalidate
directive
is not supported and will be ignored if present on any of the
supported cache control headers
The Cache API is available in the
local development environment
when using version 20.0.3 or above of the Netlify CLI; note that no cached responses are actually persisted anywhere, which means that lookups will not return a response and insertions or deletions will not mutate any state
As per the
standard Cache API specification
, it is not possible to cache
partial responses
, responses with a
Vary
header set to
*
, or responses for a request with a method other than
GET
While the Netlify Cache API tries to follow the standard
CacheStorage
and
Cache
APIs as closely as possible, there are some implementation differences associated with operating a cache on a globally-distributed infrastructure instead of the browser:
The
keys()
method is not implemented and there is currently no way to list the contents of the cache
While
reads
and
writes
are strongly consistent,
deletions
are eventually consistent, so reading an entry after deleting it may still yield the cached response for a short period of time while the deletion is propagated across the network
#
Examples
Let's imagine a function that takes some input via a URL query parameter and uses it to make an HTTP request to an external API.
This fictional API is slow and expensive, so it's in our best interest to call it only when absolutely necessary. The following example shows how you might do this with the Cache API.
Loading error: Refresh the page to access this code sample
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
request
=
new
Request
(
"https://example.com/expensive-api"
)
;
// Call the external API. This will happen on every request.
const
response
=
await
fetch
(
request
)
;
return
response
;
}
;
export
const
config
:
Config
=
{
path
:
"/cache-api-example"
}
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
request
=
new
Request
(
"https://example.com/expensive-api"
)
;
// Look for the response in the cache.
const
cached
=
await
cache
.
match
(
request
)
;
if
(
cached
)
{
return
cached
;
}
// It's not in the cache, so let's fetch it.
const
fresh
=
await
fetch
(
request
)
;
// Store it in the cache for future invocations. The response must be cloned
// so that we can simultaneously stream it to the client and to the cache.
if
(
response
.
ok
)
{
cache
.
put
(
request
,
fresh
.
clone
(
)
)
.
catch
(
error
=>
{
console
.
error
(
"Failed to add to the cache:"
,
error
)
;
}
)
;
}
return
fresh
;
}
;
export
const
config
:
Config
=
{
path
:
"/cache-api-example"
}
;
import
{
fetchWithCache
}
from
"@netlify/cache"
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
const
request
=
new
Request
(
"https://example.com/expensive-api"
)
;
// Get the response from the cache if it's there. If not, fetch it
// and store in the cache. This is a convenience method, equivalent
// to the logic in the "Cache API" tab.
const
response
=
await
fetchWithCache
(
request
)
;
return
response
;
}
;
export
const
config
:
Config
=
{
path
:
"/cache-api-example"
}
;
#
Troubleshooting
#
Outside handler scope
While you can
open a cache instance
anywhere in your function code, you can only
read
,
write
or
delete
entries from the cache within the scope of your request handler.
Attempting to perform any of those operations in another scope (such as the global scope) will throw an error.
import
type
{
Config
,
Context
}
from
"@netlify/functions"
;
// ✅ This works.
const
cache
=
await
caches
.
open
(
"my-cache"
)
;
// ❌ This will throw an error.
const
cached
=
await
cache
.
match
(
"https://example.com"
)
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
// ✅ This works.
const
cached
=
await
cache
.
match
(
"https://example.com"
)
;
if
(
cached
)
{
return
cached
;
}
return
new
Response
(
"Not in the cache"
,
{
status
:
404
}
)
;
}
;
export
const
config
:
Config
=
{
path
:
"/cache-api-example"
}
;
#
Missing cache headers or directives
Responses must have
a cache control header
with caching directives.
If you are not in control of the server or you don't want to change the response headers it returns, consider using the
fetchWithCache
utility method to modify the response headers before the response is added to the Cache API.
#
Unsupported
Netlify-Vary
directives
Responses must not use unsupported directives of the
Netlify-Vary
header.
Please refer to the
cache key variation documentation
for the full list of supported directives, and the values they accept.
#
Unsupported
Cache-Control
directives
Responses must not set cache control headers with the
private
,
no-cache
or
no-store
directives, as these directives indicate that the response cannot be stored in a public cache without validating it with the origin server before each reuse.
Refer to the
Cache-Control
directives documentation
for more information on the different cache control directives.
Consider removing these directives from your response. If you are not in control of the server or you don't want to change the response headers it returns, consider using the
fetchWithCache
utility method to modify the response headers before the response is added to the Cache API.
#
Invalid maximum age
Responses must have a cache control header with a
max-age
or
s-maxage
directive of at least 1 second.
Consider updating the cache control headers to include this directive with a supported value. If you are not in control of the server or you don't want to change the response headers it returns, consider using the
fetchWithCache
utility method to modify the response headers before the response is added to the Cache API.
#
Missing status code
Responses must specify a status code. Please ensure you're passing a valid
Response
object
to the Cache API.
#
Invalid status code
Responses must have a status code between 200 and 299.
Consider checking the status of the response before storing it with the Cache API.
const
response
=
await
fetch
(
"https://example.com"
)
;
if
(
response
.
ok
)
{
await
cache
.
put
(
request
,
response
)
;
}
#
Internal error
There was an internal error that prevented your Cache API operation to be completed.
Please use
our support page
to report your problem.
Last updated: May 2, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_caching.txt --------
Start of file
URL: https://docs.netlify.com/platform/caching/
Scraped_At: 2025-06-02T19:58:40.447909

Contact
Forums
Contact support
Netlify’s global caching infrastructure is built to provide stellar performance without any stale pages or broken assets for your visitors.
#
Default caching behavior
Static asset responses on Netlify are cached on Netlify’s global edge nodes and
automatically invalidated
whenever a deploy changes the content. Static asset responses can only change with new deploys. So, unless there is a new deploy or
manual purge
, we treat static asset responses as fresh for up to one year and ignore any attempts to set cache control headers with a shorter
max-age
.
However, responses coming from
Netlify Functions
,
Edge Functions
, and
proxies
are not cached by default. Because these responses are dynamic, they may change without a new deploy and we don’t want to risk serving stale content. If you would like to cache responses from functions, edge functions, or proxies, you can
add cache control headers
to customize the caching.
When cached, different types of responses have different default cache key considerations that determine whether a request reuses an existing cache object or creates a new one.
values for header names sent with the
standard
Vary
HTTP response header
are factored into cache keys for all response types
query parameters are additionally factored into cache keys by default for the following:
responses from
serverless functions
except for
On-demand Builders
responses from
edge functions
when
opting into manual caching
static assets served from a
redirect with a query parameter condition
This default cache key behavior optimizes the cache hit rate for the majority of use cases. You can customize the behavior with
cache key variations
that take different aspects of a request into account.
#
Cache key variation
Cache keys determine whether a request reuses an existing cache object or creates a new one. Our defaults for creating cache keys optimize the cache hit rate for the majority of use cases. However, your particular use case may have opportunities for further improvement.
For example, if your site uses an edge function to
localize content
based on user location, you may want to cache responses based on location to balance the cache hit rate with accurate localization. Or, if your site uses a serverless function where the response depends on only one query parameter, you may want to cache responses based on just that one query parameter and ignore the others to increase the cache hit rate.
You can customize how cache key variations are created for your responses by
setting the
Netlify-Vary
response header
. This gives you fine-grained control over which parts of a request are taken into consideration for matching cache objects. The
Netlify-Vary
header takes a set of comma-delimited instructions for what parts of the request to vary cache keys on. Possible instructions are as follows:
query
:
vary by the value of some or all request URL query parameters
header
:
vary by the value of one or more request headers
language
:
vary by the languages from the
Accept-Language
request header
country
:
vary by the country inferred from a GeoIP lookup on the request IP address
cookie
:
vary by the value of one or more request cookie keys
On-demand Builders don’t support cache key variation
On-demand Builders don’t support the
Netlify-Vary
header. They use the request’s URL path to determine whether to create a new cache object or reuse an existing one. This approach can’t be customized.
Different cache objects are created for different matches to the instructions. A single additional cache object is created for all non-matches. For example, consider a response with
Netlify-Vary: query=style|season
.
All of the following matches are cached under different cache keys:
/shirts?style=casual&season=summer
/shirts?style=casual&season=winter
/shirts?style=casual
Meanwhile, all of the following non-matches are cached under the same cache key. Requests to these and any other non-matches return the same response:
/shirts
/shirts?price=low
/shirts?price=sale&delivery=true
Use the same
Netlify-Vary
header for all responses from a URL
Any given URL should return the same
Netlify-Vary
header across all responses. If different resources for the same URL return different
Netlify-Vary
settings, the instructions for the first resource cached for that URL are used and the subsequent instructions are ignored.
If a response includes both the
Netlify-Vary
and
Vary
headers, we respect both when creating cache keys and returning cached responses. In general, you should use
Netlify-Vary
for your custom business logic and
Vary
for content format and encoding negotiation. If you use a service like Cloudflare in front of Netlify, you should use the standard
Vary
header to pass any desired instructions to Cloudflare since
Netlify-Vary
is a Netlify-specific feature for increased customization of cache keys on Netlify.
#
Vary by query parameter
You can create cache key variations based on  a specific subset of query parameters included with a request or all request query parameters. The former is helpful when some query parameters do not affect the response or are unique for each request, such as analytics tracking parameters. The latter is helpful when all query parameters affect the response, such as query parameters that display variations of a product listing.
To create cache key variations for a subset of query parameters, specify one or more keys in a pipe-delimited list. For example:
Netlify-Vary: query=item_id|page|per_page
To create cache key variations for all query parameters, include the following response header:
Netlify-Vary: query
The query parameter instruction is case-sensitive. However, the order in which parameters are specified on a given request does not affect how they are matched. For example, consider a
/shirts
path with a
Netlify-Vary: query
header to vary on all query parameters. A response for
/shirts?color=red&size=large
is cached under the same key as
/shirts?size=large&color=red
but a different key than
/shirts?Color=Red&Size=Large
.
#
Vary by header
You can create cache key variations based on your custom request headers and most
standard request headers
. This is helpful for custom business logic like caching different responses based on which version of your app a visitor uses.
Standard request header limitations
The following standard request headers can not be used with
Netlify-Vary
because they either have high cardinality that risks degraded performance or are the basis of other caching features on Netlify.
Accept
Accept-Charset
Accept-Datetime
Accept-Encoding
Accept-Language
- use
Vary: Accept-Language
or
Netlify-Vary
with a list of specific languages instead.
Cache-Control
Connection
Content-Length
Cookie
- use
Vary: Cookie
or
Netlify-Vary
with a list of specific cookie keys instead.
Host
If-Match
If-Modified-Since
If-None-Match
If-Unmodified-Since
Range
Referer
Upgrade
User-Agent
To create cache key variations based on request headers, specify one or more headers in a pipe-delimited list. For example:
Netlify-Vary: header=Device-Type|App-Version
#
Vary by language
You can create cache key variations for one or more individual languages or custom language groups. These are checked against the
Accept-Language
header from the request using
standard browser language identification codes
. This can be helpful for caching localized content.
To create cache key variations based on one or more individual languages, use a pipe-delimited list. For example:
Netlify-Vary: language=en|de
To group multiple languages together, use
+
. For example:
Netlify-Vary: language=en|es+pt|da+nl+de
The language instruction respects the quality parameter from the
Accept-Language
header. This means, for example, that a request with
Accept-Language: fr-CH, fr;q=0.9, en;q=0.7, de;q=0.8, *;q=0.5
and a response with
Netlify-Vary: language=de+nl|en
use a cache object under the
de+nl
variation.
Use the standard
Vary
header to vary on all languages
To create cache key variations for all possible individual languages, you can use
Vary: Accept-Language
rather than listing all the options in a
Netlify-Vary: language
instruction.
#
Vary by country
You can create cache key variations based on the geographical origin of the request. You can specify individual countries or custom country groups. These are checked against a GeoIP lookup of the request IP address using
ISO 3166-1 two-letter codes
. This can be helpful for caching content about products whose availability varies by region.
To create cache key variations based on one or more individual countries, use a pipe-delimited list. For example:
Netlify-Vary: country=es|de
To group multiple countries together, use
+
. For example:
Netlify-Vary: country=us|es+pt|dk+nl+de
#
Vary by cookie
You can create cache key variations based on a subset of cookie keys. This is helpful for things like cookie-based A/B testing. It’s typically bad for cache hit rate to create variations based on the entirety of the
Cookie
header value as this may include authentication details that vary for each user. So, you should instead target specific cookie keys to vary on.
To create cache key variations based on one or more cookie keys, use a pipe-delimited list. For example:
Netlify-Vary: cookie=ab_test|is_logged_in
The cookie instruction is case-sensitive. However, the order that cookie keys are specified on a given response does not affect how they are matched. For example, consider a path with a
Netlify-Vary: cookie=ab_test|is_logged_in
header. A response with
Cookie: ab_test=new; is_logged_in=no
is cached under the same key as
Cookie: is_logged_in=no; ab_test=new
but a different key than
Cookie: AB_test=New; is_logged_in=NO
.
#
Combine variations
You can use any combination of the above instructions to vary your cached content.
To combine multiple instructions, separate them with a comma. For example:
Netlify-Vary: query,country=es+de|us
This tells Netlify to take both the entire query into account for cached objects, as well as the request’s country of origin.
#
Supported cache control headers
Netlify supports the
standard caching directives
with the following cache control headers:
Netlify-CDN-Cache-Control
:
targeted field that applies to only Netlify’s CDN
CDN-Cache-Control
:
targeted field that applies to all CDNs that support it
Cache-Control
:
general field that can apply to any CDN or a visitor’s browser
On-demand Builders use time to live
On-demand Builders don’t support these cache control headers. They instead support an optional
time to live (TTL)
pattern that allows you to set a fixed duration of time after which a cached builder response is invalidated.
The following directives affect response caching as described below.
public
: cache the response.
private
: Netlify’s cache is a shared cache, so using
private
means we don’t cache the response in our network and can’t reuse it for multiple clients. However, the response will be cached in the local cache for each client.
no-store
: do not cache the response.
s-maxage
: store and reuse the cached response in Netlify’s shared cache for this many seconds.
max-age
: store and reuse the cached response in any cache for this many seconds. If
s-maxage
is also set, Netlify’s shared cache will use
s-maxage
instead.
stale-while-revalidate
: keep serving a stale object out of the cache for this many seconds while the object is revalidated in the background.
durable
: for serverless functions only. Use to reduce function invocations and response latency. When a response is generated and cached for one edge node, store the response in Netlify’s durable cache so that other edge nodes can reuse it instead of invoking the function again.
#
Stale while revalidate directive
Stale while revalidate is a caching pattern that allows the cache to keep serving a stale object out of the cache while the object is revalidated in the background. This can be impactful for implementing API caching or patterns like incremental static regeneration (ISR).
As an example use case, imagine you have a slow API endpoint that takes 5 seconds to respond. You can wrap it in a function that adds the following cache header:
Netlify-CDN-Cache-Control: public, max-age=60, stale-while-revalidate=120
Here’s what this header does:
public
instructs Netlify’s edge to cache the first response.
max-age=60
instructs the cache to continue serving the cached response for 60 seconds after the initial request. After 60 seconds, the cache is considered stale.
stale-while-revalidate=120
instructs the cache how long it can serve stale content. If a request arrives within this specified duration after the content expired, the stale content is served while the cache revalidates the content in the background.
If there’s a steady stream of requests, visitors will get recently refreshed results from the API without having to wait 5 seconds for the API response.
Here’s a timeline to illustrate how this works:
An initial request generates a response that gets cached (consider this to be t = 0).
A new request is made 30 seconds later (t = 30). The cache is still fresh, so the edge serves the cached response.
Another request is made 100 seconds later (t = 130). The cache is now stale, but the time is within the 120
additional
seconds allotted to serve stale content. So, the edge serves the stale cached response while the cache revalidates the content in the background. Time is reset (t = 0) when the revalidated response is cached.
Another new request is made 4 minutes later (t = 240). The cache is stale again and the time is outside the allotment for serving stale content (which ended at t = 60 + 120 = 180). The edge waits for a new response to be generated before serving and caching it. Time is reset (t = 0) when the new response is cached.
#
Durable directive
By default, when a site visitor makes a request to Netlify for content that is generated by a function, the specific edge node the visitor connects to checks its own local cache. If fresh content is not found in that node’s cache, the node invokes the function to generate a new response. This means the function is typically invoked multiple times for the same content.
When you use the
durable
directive for a function’s response, that response is not only returned to the edge node that invoked the function but also stored in a shared cache called the
durable cache
. Whenever that content is requested, edge nodes that don’t have the response locally cached check the durable cache, and only invoke the function if the response is not found there.
You can expect the following benefits when you add the
durable
directive to your serverless functions:
Better response times and more reliable performance for edge cache misses.
Without the durable cache, an edge cache miss for a serverless function always leads to a function invocation. Function invocations have variable performance and increased latency because of factors like warm vs. cold starts, the time it takes the function logic to run, and calls to third-party APIs that have their own latency profile. With the
durable
directive, many of these edge cache misses are backed by a response stored in the durable cache, so an additional function invocation isn’t required. This can also mitigate issues related to high-volume function usage with third-party providers, such as rate-limiting.
Fewer function invocations, which can lead to a reduced bill.
The durable cache allows edge nodes to share a cached response, so edge nodes don’t have to invoke the function individually when they don’t already have a cached response. This reduces the number of function invocations, typically by a significant amount, and decreased usage can mean decreased costs. This can also mitigate issues with third-party providers that can occur with a high volume of function usage, such as third-party API quotas being exhausted. Note that while we aim to minimize function invocations, we do not guarantee that there’s always only a single function call for each version of a generated page. Multiple requests across different regions in a short time frame might invoke a function multiple times because the cache is eventually consistent.
Here’s an example of a serverless function using the
durable
directive:
import
type
{
Context
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
,
context
:
Context
)
=>
{
return
new
Response
(
"Hello world"
,
{
headers
:
{
'Netlify-CDN-Cache-Control'
:
'public, durable, max-age=60, stale-while-revalidate=120'
}
}
)
;
}
The durable cache is compatible with all other fine-grained cache controls including cache key variations, stale while revalidate, and on-demand invalidation. This means if you’re already using the edge cache to cache function responses, adding the durable cache requires minimal code changes. Using the durable cache doesn’t add significant latency to function invocations. This is because we automatically co-locate the durable cache for a site with the site’s
functions region
to minimize cross-region hops for a request.
Not yet supported on Edge Function responses
The durable cache is currently only compatible with Netlify Function responses.
The
durable
directive has no effect on responses from Netlify Edge Functions.
If you would like to see this feature added, please
tell us more about your use
case
.
#
Framework support
Your ability to control caching headers varies by web framework.
Some web frameworks give developers full control of caching headers. For example, check out our developer guides on how to use our caching primitives with the following frameworks:
Astro
Remix
However, other frameworks control some or all caching headers on behalf of developers. Note the following framework-specific limitations:
Next.js
On Netlify, cacheable responses on sites using the Next Runtime 5.5.0 or later automatically use
the durable cache
You can override this behavior in your
next config
file
, but note
that Next.js did not support this before 14.2.10.
Nuxt
v3 apps using the default
netlify
Nitro preset can’t set cache control headers on ISR routes.
Automatic durable cache for Nuxt and more coming soon
We are working on updating our framework support for Nuxt (and other frameworks powered by Nitro,
such as Analog, SolidStart, and TanStack Start) to automatically use the durable cache.
#
Default values
If you don’t specify any of the supported cache control headers, we use the following default values.
For static assets:
Netlify-CDN-Cache-Control: public, s-maxage=31536000, must-revalidate
Cache-Control: public, max-age=0, must-revalidate
For dynamic responses:
Cache-Control: public, max-age=0, must-revalidate
#
Header precedence
If you specify more than one of the supported headers, Netlify will respect the most specific one. Netlify always passes
CDN-Cache-Control
and
Cache-Control
downstream so that other caches can use them. Here are some examples:
Response includes both
Netlify-CDN-Cache-Control
and
CDN-Cache-Control
Netlify uses the settings from
Netlify-CDN-Cache-Control
CDN-Cache-Control
will be passed downstream for other caches to use
Response includes both
CDN-Cache-Control
and
Cache-Control
Netlify uses the settings from
CDN-Cache-Control
Both
CDN-Cache-Control
and
Cache-Control
are passed downstream for other caches to use
#
Automatic invalidation with atomic deploys
To support
atomic deploys
, all new deploys invalidate the cache for the given
deploy context
by default. For example, a new deploy of a Deploy Preview will invalidate the cache for that specific Deploy Preview number while all other Deploy Previews for the site will remain cached as is. This automation means that a cached asset may be invalidated despite the cache control headers indicating that the asset should still be considered fresh. This override guarantees that we never accidentally serve stale content.
Automatic invalidation relies on an internal cache ID that we apply automatically to all objects on our CDN. The ID indicates both the site and the deploy context that an object belongs to.
#
Opt out of automatic invalidation
If you want some of your cached responses from functions or proxies to persist across atomic deploys, you can opt them out of automatic invalidation.
As an example use case, imagine a site that proxies to a CMS server that has a weekly release cycle. Any site deploy in between the weekly CMS releases invalidates the whole cache for that deploy context causing Netlify to revalidate all objects. This includes assets cached from the CMS even though they haven’t changed. This can affect performance, increase bandwidth spend, and put unnecessary strain on the CMS server. In this scenario, you can opt out of automatic invalidation for responses proxied from the CMS server to avoid these issues.
To opt an object out of automatic cache invalidation, set the
Netlify-Cache-ID
response header with one or more custom cache IDs. To set multiple IDs, use a comma-separated list.
Loading error: Refresh the page to access this code sample
Netlify-Cache-ID: cms-proxy
Netlify-Cache-ID: cms-proxy,product,image
The custom cache ID overrides the internal cache ID making it so that automatic invalidation with atomic deploys does not apply to the object. However, any
Cache-Control
directives for an object are still respected so you can control how long the object stays cached.
To support granular
on-demand invalidation
of cached objects that are opted out of automatic invalidation, your custom
Netlify-Cache-ID
values are automatically registered as cache tags that you can use to purge the object by tag.
Keep the following in mind when setting
Netlify-Cache-ID
cache IDs are case insensitive
cache ID response headers must contain only UTF-8 encoded characters
a single cache ID can be up to 1024 characters long
a single response can have up to 500 cache IDs
#
Best practices
After you’ve opted out of automatic invalidation, some site updates might not propagate as you expect them to. This is more common when your
Cache-Control
configuration keeps assets fresh for a long time. If this happens, we recommend that you use
on-demand invalidation
to purge the cache so that you don’t have to wait for revalidation based on the
Cache-Control
directives to take effect. After a manual purge, your changes should propagate fully across our CDN as requests are made to your site.
Here are some scenarios where it’s a best practice to manually purge the cache after making changes:
Changing a redirect rule that configures a proxy to a page with a
Netlify-Cache-ID
header. The update might not propagate to all routes, since the proxied content stays in the cache.
Changing a function that generated a response with a
Netlify-Cache-ID
header. The updated function won’t run since the previously generated response stays in the cache.
If you have sensitive content, we recommend that you don’t opt out of automatic invalidation for it. This is because we don’t want to risk your sensitive content becoming more widely available than it should be. Take the following scenario for example:
A site with sensitive content is using
Firewall Traffic Rules
.
The sensitive content has been opted out of automatic invalidation.
A new deploy is made that doesn’t include the sensitive content.
Someone removes the Firewall Traffic Rules thinking the site doesn’t need them anymore now that the project no longer contains sensitive content.
However, the sensitive content remains cached. The cached content is publicly available to everyone until responses are revalidated based on
Cache-Control
directives which could potentially be long-lived.
#
On-demand invalidation
If you want to invalidate cached objects while their cache control headers indicate they’re still fresh, you can purge the cache by
site
or
cache tag
. These granular options for refreshing your cache without redeploying your entire site optimize developer productivity for your team and site performance for your customers. On-demand invalidation across the entire network takes just a few seconds, even if you’re purging a tag associated with thousands of cached objects.
You can use the following to invalidate cached objects:
a
serverless function
with the
purgeCache
helper
a direct call to the
purge
API endpoint
with a
personal access token
You can use either to purge by site or by tag as demonstrated in the examples in the next sections.
Extra step for Lambda-compatible serverless functions
To purge the cache from a
Lambda-compatible serverless function
, you must pass the
purge_api_token
value provided automatically by Netlify. This keeps your Lambda-compatible function secure.
// purge a cache tag passed by query parameter across all deploys of a site
// no need to specify site ID as it is passed automatically by the purgeCache helper
import
{
purgeCache
}
from
"@netlify/functions"
module
.
exports
.
handler
=
async
(
event
,
context
)
=>
{
const
token
=
context
.
clientContext
.
custom
.
purge_api_token
;
await
purgeCache
(
{
tags
:
[
"tag1"
,
"tag2"
]
,
token
}
)
return
{
body
:
"Purged!"
,
statusCode
:
202
}
}
#
Purge by site
Purging by site invalidates all cached assets across all deploys for the site.
As an example use case, imagine a site that uses branch deploys for A/B testing, is backed by a content API, and needs to be automatically refreshed every hour with new content. Purging the cache by site is useful in this scenario because it keeps the content refresh in sync across all branch deploys.
#
Use a function with the
purgeCache
helper to purge by site
When you use a function with the
purgeCache
helper, the site ID is passed automatically so you don’t need to specify the site.
// purge all objects across all deploys for this site
import
{
purgeCache
}
from
"@netlify/functions"
;
export
default
async
(
)
=>
{
console
.
log
(
"Purging everything"
)
;
await
purgeCache
(
)
;
return
new
Response
(
"Purged!"
,
{
status
:
202
}
)
}
;
#
Use a direct call to the
purge
API to purge by site
To purge by site with a direct API call, specify the site with one of the following
site_id
:
for example,
3970e0fe-8564-4903-9a55-c5f8de49fb8b
site_slug
:
for example,
mysitename
You can find these values for your site by visiting the Netlify UI at
Project configuration
>
General
>
Project details
>
Project information
and checking the
Project ID
or
Project name
(Also known as Site ID in the Netlify API and formerly as Site ID and Site name in the Netlify UI.)
curl
-X
POST
\
-H
"Content-Type: application/json"
\
-H
"Authorization: Bearer <personal_access_token>"
\
--data
'{"site_id": "3970e0fe-8564-4903-9a55-c5f8de49fb8b"}'
\
'https://api.netlify.com/api/v1/purge'
#
Purge by cache tag
Purging by cache tag invalidates specified cached assets. You can purge by tag across all deploys of a site or only within a specific deploy context.
As an example use case, imagine a high-traffic e-commerce site where products routinely sell out. You may want to purge promotions for products when they sell out so that customers aren’t disappointed when they follow an old cached promotion link only to find that the product isn’t currently available. Purging by cache tag is useful in this scenario because it can refresh assets related to the sold-out product without impacting performance for items that are still available.
To purge by cache tag you must first
add cache tag response headers
. Then you can
invalidate tagged objects
.
Keep the following in mind when purging by cache tag
cache tags are case insensitive
cache tag response headers must contain only UTF-8 encoded characters
a single tag can be up to 1024 characters long
a single response can have up to 500 cache tags
#
Add cache tags
Netlify supports the following cache tag response headers
Netlify-Cache-Tag
:
targeted field that applies to only Netlify’s CDN
Cache-Tag
:
general field that can apply to any CDN
You can specify one or more cache tags for a response. For multiple tags, use a comma-separated list:
Loading error: Refresh the page to access this code sample
Cache-Tag: tag1,tag2,tag3
Netlify-Cache-Tag: tag1,tag2,tag3
Additionally, if you’ve
opted out of automatic invalidation
for an object, any custom cache IDs you set with the
Netlify-Cache-ID
response header are registered as tags for that cached object. This prevents cached objects from getting stuck on our CDN with no way to purge them.
These 3 response headers work together in the following ways:
If you specify both
Netlify-Cache-Tag
and
Cache-Tag
, Netlify uses the values from
Netlify-Cache-Tag
. Netlify always passes
Cache-Tag
values downstream so other caches can use them.
Setting
Netlify-Cache-Tag
to a value already set for
Netlify-Cache-ID
is redundant and has no extra effect on your site. If however you want to send your custom
Netlify-Cache-ID
tags downstream so other caches can use them, you must set
Cache-Tag
with the same values you’ve set for
Netlify-Cache-ID
.
Tags automatically registered based on
Netlify-Cache-ID
values do not contribute to the limit of 500 cache tags per response. They have their own separate limit of 500 cache IDs per response.
Here are some examples:
Response includes
Netlify-Cache-Tag: cms-proxy
and
Cache-Tag: cms-asset
:
Netlify tags the cached object with the value from
Netlify-Cache-Tag
.
You can purge the object from Netlify’s cache using the
cms-proxy
tag.
Attempts to purge the
cms-asset
tag on Netlify’s CDN do not affect the cached object.
Cache-Tag: cms-asset
is passed downstream for other caches to use.
The cached object is automatically invalidated by new deploys.
Response includes
Netlify-Cache-ID: product
and
Cache-Tag: image
:
Netlify tags the cached object with both
product
and
image
.
You can purge the object from Netlify’s cache using either tag.
Cache-Tag: image
is passed downstream for other caches to use. However, the
product
tag is not sent downstream.
The cached object persists after new deploys until its
Cache-Control
directives indicate it’s stale or until you purge it manually.
Response includes
Netlify-Cache-ID
with 500 values and
Cache-Tag
with 500 different values:
Netlify tags the cached object with the values from both headers.
You can purge the object from Netlify’s cache with any of the 1000 different tags on the object.
Other providers may strip
Cache-Tag
before it reaches Netlify
Some providers remove
Cache-Tag
from their responses. If you are proxying to a provider that does this, you should use both
Netlify-Cache-Tag
and
Cache-Tag
so that your cache tags are applied to both Netlify and the proxy.
#
Invalidate tagged objects
As mentioned above, you can use either a function or a direct API call to invalidate cached objects by tag.
#
Use a function with the
purgeCache
helper to purge by cache tag
When you use a function with the
purgeCache
helper, the site ID is passed automatically so you don’t need to specify the site.
By default, tag-based purges apply to all of the site’s deploys. To target a specific deploy, specify one or more of the following
deployAlias
(optional)
:
for example,
deploy-preview-11
. On its own, targets the specified alias on the primary domain.
domain
(optional)
:
for example,
early-access.company.com
. On its own, targets the currently published production deploy on the specified domain.
// purge a cache tag passed by query parameter
// applies to a specific Deploy Preview of a specific subdomain
import
{
purgeCache
}
from
"@netlify/functions"
;
export
default
async
(
req
:
Request
)
=>
{
const
url
=
new
URL
(
req
.
url
)
;
const
cacheTag
=
url
.
searchParams
.
get
(
"tag"
)
;
if
(
!
cacheTag
)
{
return
;
}
const
deployAlias
=
"deploy-preview-11"
;
const
domain
=
"early-access.company.com"
;
console
.
log
(
"Purging tag: "
,
cacheTag
)
;
await
purgeCache
(
{
tags
:
[
cacheTag
]
,
deployAlias
,
domain
,
}
)
;
return
new
Response
(
"Purged!"
,
{
status
:
202
}
)
}
;
#
Use a direct call to the
purge
API to purge by cache tag
To purge by cache tag with a direct API call, specify the following
cache_tags
:
for example
news
or
blog,sale
. If you don’t specify a
list of
cache_tags
, the entire site will be purged. However, if you specify an empty
list of
cache_tags
, no purge will be applied.
the site with either of the following:
site_id
:
for example,
3970e0fe-8564-4903-9a55-c5f8de49fb8b
site_slug
:
for example,
mysitename
You can find these values for your site by visiting the Netlify UI at
Project configuration
>
General
>
Project details
>
Project information
and checking the
Project ID
or
Project name
(Also known as Site ID in the Netlify API and formerly as Site ID and Site name in the Netlify UI).
By default, tag-based purges apply to all of the site’s deploys. To target a specific deploy, specify one or more of the following
deploy_alias
(optional)
:
for example,
deploy-preview-11
. On its own, targets the specified alias on the primary domain.
domain
(optional)
:
for example,
early-access.company.com
. On its own, targets the currently published production deploy on the specified domain.
# applies to a specific Deploy Preview of a specific subdomain
curl
-X
POST
\
-H
"Content-Type: application/json"
\
-H
"Authorization: Bearer <personal_access_token>"
\
--data
'{"site_slug": "mysitename", "cache_tags": ["news"], "deploy_alias": "deploy-preview-11", "domain": "early-access.company.com"}'
\
'https://api.netlify.com/api/v1/purge'
Each cache tag or site can only be purged twice every 5 seconds. If you exceed
this rate limit, you will receive a
429
response code.
#
Debug with
Cache-Status
Netlify sets a
Cache-Status
header on all responses. This header contains information about how different cache layers handled each response and follows
RFC 9211
.
The
Cache-Status
header is useful for troubleshooting and monitoring. For example, you can use it for the following:
checking if you received a cached response
finding out why you received an uncached response
differentiating cached and uncached responses when measuring performance
To troubleshoot, examine the
Cache-Status
header on your responses and check how our network handled a request.
If you use a frontend monitoring tool to collect performance metrics, we recommend that you record this header so that you can differentiate cached and uncached responses when analyzing your site’s performance.
#
Example
Cache-Status
values
Here are some examples of common response patterns:
No response found in the cache:
Cache-Status: "Netlify Edge"; fwd=miss
Cached response found and served:
Cache-Status: "Netlify Edge"; hit
Outdated response found and not served:
Cache-Status: "Netlify Edge"; fwd=stale
Outdated response found and served while we refresh in the background because the
stale while revalidate
directive was used:
Cache-Status: "Netlify Edge"; hit; fwd=stale
For serverless functions with the
durable
directive
, some common response patterns include a
Cache-Status
from the durable cache.
No response found in the edge cache or durable cache for requested URI:
Cache-Status: "Netlify Edge"; fwd=miss
Cache-Status: "Netlify Durable"; fwd=uri-miss; stored=true; ttl=3600
No response found in the edge cache or durable cache for requested
variation (either due to Vary or Netlify-Vary mismatch):
Cache-Status: "Netlify Edge"; fwd=miss
Cache-Status: "Netlify Durable"; fwd=vary-miss; ttl=3600; stored=true
No response found in the edge cache; cached response found in the durable cache and served:
Cache-Status: "Netlify Edge"; fwd=miss
Cache-Status: "Netlify Durable"; hit; ttl=1234
Outdated response found in the edge cache and not served; fresh response found in the durable cache and served:
Cache-Status: "Netlify Edge"; fwd=stale
Cache-Status: "Netlify Durable"; hit; ttl=1234
No response found in the edge cache; outdated response found in the durable cache and not served:
Cache-Status: "Netlify Edge"; fwd=miss
Cache-Status: "Netlify Durable"; fwd=stale; stored=false; ttl=-600
No response found in the edge cache; outdated response found in the durable cache and served while we refresh in the background because the
stale while revalidate
directive was used:
Cache-Status: "Netlify Edge"; fwd=miss
Cache-Status: "Netlify Durable"; hit; ttl=-600; stored=true
#
Troubleshooting tips
A response might have multiple
Cache-Status
headers if multiple caches were involved in serving the response. For information about Netlify cache behavior, find values that start with
"Netlify Edge"
or
"Netlify Durable"
.
Each request you make could land on a different instance of the cache that has different content stored. If your site does not receive production traffic that warms the cache and you’re not using the
durable
directive
for serverless functions, you will likely land on multiple caches that don’t have a cached response before getting a cache hit. Try making multiple requests when debugging caching issues to ensure you make repeat requests to the same instance of the cache.
#
More resources
Refer to the following resources for how to set caching headers for different types of responses
Get started with functions
:
include caching headers in a function’s response object.
Optional configuration for edge functions
:
opt in to caching and customize cache behavior for an edge function.
Netlify Image CDN
:
set headers on source images to control caching for Netlify Image CDN.
Custom headers
:
set caching headers that are sent downstream for static assets.
Connect JavaScript client
:
use the Connect client to query your data layer and it will automatically add cache tags and manage invalidation for you.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_launch-checklist.txt --------
Start of file
URL: https://docs.netlify.com/platform/launch-checklist/
Scraped_At: 2025-06-02T19:58:41.212839

Contact
Forums
Contact support
After you
add a new site
on Netlify, but before you release it to your customers, consider the following recommendations for getting your project ready for production.
Note that not all recommendations apply to all sites. Some recommendations are specific to when certain features are in use. Also, some recommended tasks can be completed once at the team level and apply to future sites you launch. While your project might not warrant taking action on all the recommendations below, we suggest that you at least review them all to consider which recommended tasks would benefit your business.
Extra benefits for Pro and Enterprise teams
Some of the below recommendations involve features that aren’t available on all
plans
. Plan requirements are indicated below.
#
Finalize names
Make any desired edits to your
team name
and site name before configuring anything else since some configuration values may depend on these slugs.
#
Collaborate securely and efficiently
Configure
automatic deploy subdomains
for unified branded URLs across your Deploy Previews and branch deploys.
If you don’t intend for your branch deploys to be publicly searchable, use custom headers to
prevent branch deploys from being indexed by search engines
.
Invite reviewers
to get stakeholder sign-offs using
collaborative Deploy Previews
.
Send your stakeholders the
Reviewer quickstart
to teach them how to share feedback.
#
Pro and Enterprise teams
Set up
Slack notifications
for team awareness of deploy activity.
Protect non-production deploys
from unauthorized access.
Add team members
with the minimum level of
permissions
required for their work to enable collaboration while keeping your sites secure.
Add at least one other
Team Owner
so that while you’re away from work someone else can add team members, set user permissions, transfer projects, and more to keep things running smoothly.
#
Enterprise teams only
Enable and enforce
SAML single sign-on for your team
(or
organization
if applicable).
#
Optimize performance and ensure quality
Optimize your
build performance
and
build time
so your team can spend more time creating and less time waiting.
Optimize the size and format of your images with
Netlify Image CDN
to improve the runtime performance and reliability of your site.
Optimize the number of files updated for your deploys
to reduce deploy times and make the most of Netlify’s CDN cache.
Create
cache key variations
to optimize cache performance.
Opt out of automatic cache invalidation
for proxied responses to optimize cache performance.
Add the durable cache for serverless function responses
to reduce response times and variability in performance.
Cache edge function responses
for even faster response times.
Customize edge function error handling
to fail closed or open depending on your audience and content.
Configure your
serverless functions region
to the closest to your data sources.
Add
unit testing and integration testing
to your site builds.
Plan
synthetic performance testing
to optimize your site performance before your initial launch and avoid performance regressions in the future.
For example,
set up embedded Lighthouse scores
.
Enable
Project Analytics
to monitor trends in site activity.
If you want to monitor production traffic only, make
Project Analytics distinguish between deployed branches
.
#
Pro and Enterprise teams
Enable
Real User Metrics
to monitor your site’s usability and performance.
#
Enterprise teams only
Integrate content from multiple sources into a single data unification layer with
Netlify Connect
to ensure your sites and other web properties always have access to the latest content.
Use the
Connect JavaScript client
to query your data layer’s GraphQL API and benefit from efficient caching of data for sites that use server-side rendering (SSR) with caching.
Configure Log Drains
to pipe data from Netlify’s CDN to third-party monitoring services for analysis, alerting, and data persistence.
#
Secure your information
If your site is connected to a public repository, review the following settings to make sure they balance your needs for protecting security and welcoming contributions:
Sensitive variable policy
.
Deploy log visibility
.
Flag your most sensitive environment variable values with
Secrets Controller
to apply stricter security measures and perform secrets scanning of your code and build output files.
Import
.env
file variables
for security and consistency between local and remote builds.
Confirm that you
haven’t committed any sensitive environment variables
to your repository.
#
Pro and Enterprise teams
Make variables available to only the
scopes
that need them for tighter control of your sensitive data.
If you have multiple sites, use
shared environment variables
for non-sensitive values where possible for dev productivity.
#
Enterprise teams only
Configure
Private Connectivity
to reduce the risk to your backend environment.
#
Prepare for production traffic
Configure your site for
HSTS preload
to enhance performance and security.
Check for
consistent trailing slashes for SEO
and
enable pretty URLs
if needed.
Set up a
custom 404 page
in line with your branding.
Work with your legal representation to make sure your site is following all privacy regulations that apply to your site. Then use country-based redirects to
show appropriate disclosures and get the appropriate consent per location
.
Add a
custom domain
and
configure DNS
.
If you’re using external DNS, confirm that your
primary domain is
www
or another subdomain
instead of an apex domain  to optimize your use of our CDN.
If you plan to have more than 5 domain aliases that are subdomains of the same domain, manage your HTTPS certificates to
avoid rate limiting for subdomains
.
#
Enterprise teams only
Set up
Firewall Traffic Rules
to permit or block access to your site based on IP address or geographic location.
Set up
rate limiting rules
to protect against API abuse, authentication attacks, and more.
If you’re migrating an existing domain you’ve already used, and you have access to premium support, reach out to your dedicated account support team for help working through our Enterprise domain migration launch checklist.
If you’re using external DNS,
configure your domains
to use the High-Performance Edge to benefit from proactive DDoS mitigation and optimize response times and cache hits.
If your site will handle HIPAA-regulated data, visit our
Trust Center
to download our reference architecture for HIPAA-compliant composable sites on Netlify.
#
Communicate with customers
If your business involves emails:
Set up the
Netlify Email Integration
to send emails and keep your templates version controlled alongside the rest of your project.
Set up your domain to
receive emails
.
If you’re using Netlify Forms:
Add
extra spam prevention
.
Add an
<input>
with
name="email"
to
streamline replying to form submitters
.
Create a
custom success page
in line with your branding.
Create a process for
managing sensitive form data
.
#
Expect the unexpected
Plan a
maintenance page process
.
Familiarize your team with the following tools and resources:
Rollbacks
in case they need to revert site changes quickly.
Manual deploy deletion
in case they ever need to remove accidentally deployed sensitive information.
Fix failed deploys and build errors with
Netlify’s AI-enabled suggested solutions
#
Pro and Enterprise teams
Familiarize your team with our tips for
requesting support by email
.
#
Enterprise teams only
Familiarize your team with the following tools and resources:
Build prioritization
to reduce wait times for important builds in your team build queue.
If you have
Premium Support
, your dedicated Slack channel and phone number for support.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_netlify-labs_experimental-features.txt --------
Start of file
URL: https://docs.netlify.com/platform/netlify-labs/experimental-features/
Scraped_At: 2025-06-02T19:58:42.081131

Contact
Forums
Contact support
Netlify Labs
provides a way to try out new features while they’re being finalized. We believe that the best way to release new features that will directly address your needs is by allowing you to check them out and provide feedback along the way.
We
announced Netlify Labs
with a goal of improving your overall experience in the Netlify app. The program allows us to collect feedback early on and validate assumptions we may have made along the way.
#
Use Netlify Labs
You can turn experimental features on and off by visiting
Netlify Labs
in the Netlify app. While logged in, select your avatar (labeled “User” for screen readers) in the navigation, then select
Netlify Labs
.
Because these features are works in progress, they’re meant for testing and may not always work as expected. Features in Netlify Labs aren’t recommended for production use. Depending on the feedback we get, they may not be released and may be removed completely.
#
Join our research program
There are more ways to contribute your opinions and insights to the Netlify team besides providing feedback on features in Netlify Labs. Our research team continues their work to better understand your needs through regular research calls. Join our
research program
to participate. Our team is excited to learn your thoughts on Netlify and advocate for you in product and design decisions.
Last updated: November 21, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_primitives.txt --------
Start of file
URL: https://docs.netlify.com/platform/primitives/
Scraped_At: 2025-06-02T19:58:42.997217

Functions resources
Refer to the following resources to learn more about Netlify Functions:
Introduction to Functions
Getting started with Functions
Functions API reference
Or start building with
one of our platform starters
.
###End of file##

-------- platform_release-phases.txt --------
Start of file
URL: https://docs.netlify.com/platform/release-phases/
Scraped_At: 2025-06-02T19:58:43.623214

Contact
Forums
Contact support
As part of the product lifecycle, Netlify offers features and functionality at different stages of development. Features may go through all phases or just some. The product lifecycle covers everything from significant new services on our platform to minor updates like a new flag in our command line interface (CLI). This page serves as a reference to define each release phase.
#
Beta
Beta features are still under development. They are ready for testing and use in projects that are not mission critical. Netlify uses two beta release phases: private and public.
#
Private beta
Private beta features are enabled individually for selected users or teams with internal approval. Netlify uses this phase to gather qualitative feedback to guide development. Certain private beta features may use
Netlify Labs
to enable access. Outages within the feature or sites using the feature are possible, but these should not impact other sites or systems. Breaking changes are likely to occur.
#
Public beta
Features in public beta are available to all users, although certain features or functionality may be available only for teams on specific
pricing plans
. Netlify uses the public beta phase to gather higher-volume qualitative feedback, aggregate usage data, and perform error monitoring. Features in public beta may be automatically enabled for all users, or they may require opting in through
Netlify Labs
or another mechanism. Although we aim for production quality and stability, they aren’t guaranteed at this release phase. Bugs are expected, and breaking changes are possible.
#
Early access
When we’re making significant changes and improvements to an existing feature, we may make an Early Access version of the feature available for users to opt-in and start using early. Each Early Access feature may have its own specific opt-in or rollout process.
#
General availability
At the general availability phase, features are production-ready for mission critical applications. They meet Netlify standards for production quality and stability and abide by our service-level agreements. Breaking changes are unlikely and require significant prior notice.
Versioned services such as Netlify CLI, Netlify REST API, and related clients and SDKs follow
semantic versioning
. While there are multiple releases available for these services, we recommend that you use the latest version.
#
Deprecated
A feature or functionality marked as deprecated is still available, but we don’t recommend its continued use or adoption for new use cases. Before any deprecated feature reaches end of service, Netlify provides time and guidance to migrate off. While breaking changes are unlikely until a service is shut down, there may be degraded quality and stability during a deprecation period.
#
End of service
A feature at the end of service phase is no longer available or supported.
Last updated: April 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_request-chain.txt --------
Start of file
URL: https://docs.netlify.com/platform/request-chain/
Scraped_At: 2025-06-02T19:58:44.550957

Contact
Forums
Contact support
Each request served by Netlify goes through a series of steps and transformations until a response is delivered back to the client.
That sequence of steps varies with the type of request, the site configuration, any web frameworks being used as well as their own configuration.
The diagram below is a representation of what those steps are, what order they run in and under what conditions.
You can expand each of the steps for more details, including links to the relevant documentation. They are divided into four categories:
Security
Compute
Caching
Static routing
Firewall Traffic Rules
When a request hits Netlify, it first goes through any
Firewall Traffic Rules
. These rules let you control who can access a site based on their IP address or geographic location, including granular targeting by country or region.
You can define rules for a specific site or for all sites on your team. Site-level rules take precedence.
If the request matches a block rule, a Netlify-branded 404 page is served and the request chain is stopped.
Otherwise, it continues down the request chain.
Web Application Firewall
The request then goes through the
Web Application Firewall (WAF)
, another enterprise-grade security feature that protects your site from common attacks.
Netlify offers a managed ruleset so you can benefit from best-in-class protection with minimal setup. You can
configure the behavior for each rule
based on the specific traffic patterns of your site, to ensure no legitimate requests are unintentionally blocked.
If the request is not blocked, it continues on.
Rate Limiting
Whereas the last two stages let you specify requests to always block, the rate limiting stage lets you set a limit to certain requests that you generally allow.
You can specify
highly-customizable rate limiting rules
to mitigate DDoS attacks, protect your backend, reduce bot traffic, prevent web scraping, optimize bandwidth usage, and
more
. These rules can be defined in the UI, in the
netlify.toml
file or directly in the functions or edge functions files they are protecting.
If the request doesn't exceed the threshold of rate limiting rules, it continues down the request chain.
Site Protection
Site Protection
offers a turn-key solution for gating access to your site, so that only authorized users can visit it. You can set up a
basic password
or an advanced team login protection, which includes support for
single sign-on (SSO)
.
When enabled, access to the site will be validated at this point. Unauthorized requests will be blocked and the request chain will stop.
Otherwise, the request continues on.
Edge Functions
By default, Edge Functions are evaluated immediately after a request has passed the security checks and is matched against the request based on their their
path and method configuration
. By acting as the the entry point to a Netlify site, they allow developers to implement bespoke routing logic and
advanced edge caching patterns
.
If multiple edge functions match the incoming request, they will be invoked one after the other, according to
the declaration order rules
. If an edge function returns a
Response
object, that will be served to the client and the request chain is stopped. If an edge function returns
undefined
, the execution moves on to the next matching edge function (if applicable) or to the next element on the request chain.
At any point during its execution, an edge function can
retrieve the contents of the next element on the request chain
by calling
context.next()
.
If no edge functions match the request, or if no edge functions have returned a response, the request continues on.
Edge Cache
The Netlify CDN is comprised of many servers distributed across different regions throughout the globe. This infrastructure ensures that clients always connect to a server that is close to them, reducing the network latency.
Each one of those servers has an HTTP cache, which is the next element on the request chain. If the request matches any response that has been previously stored in the cache, we serve it immediately and the request chain is stopped.
Leveraging our Edge Cache is a great way to achieve the best possible performance and reduce costs. Our caching infrastructure is framework-agnostic and works with
standard cache control headers
, so anyone can take full advantage of it regardless of their tech stack.
If the request doesn't match any response in the cache, it continues on.
Edge Functions
We have established how edge functions, by default, run immediately after a request has passed security checks and before any caching layer. This is ideal in a lot of scenarios, but other use cases would benefit from leveraging the Edge Cache and skip the invocation of the edge function entirely if it matches something that has been generated before.
You can change this behavior by
configuring the edge function for caching
, which under the hood changes the place in our request chain where the invocation takes place.
Typically, you will benefit from running an edge function before the cache if you want to run any middleware-type workload, like modifying a request on the way in or transforming a response on its way out. You might want to run an edge function after the cache if the edge function is responsible for generating the final response.
You can have both types of edge functions running for the same request.
If no edge functions are matched, the request continues on.
If the request doesn't match any response in the cache, it continues on.
Durable Cache
While Netlify Serverless Functions are the next primitive that we try to match, before actually invoking anything, we have one additional caching layer to check. As a rule of thumb, serving something from a cache is always faster than computing a fresh response, no matter how streamlined and optimized your code is.
If we're this far down on the request chain, it means the request didn't match anything in the Edge Cache. But we saw how that cache is local to each of the CDN servers, so the fact that we didn't match doesn't necessarily mean that we never cached a response from the function we're about to invoke — it could just mean that it was cached on a different server.
This is where the Durable Cache comes in. When you return a response with
the
durable
directive
in the cache control headers, we'll propagate that response across our CDN to ensure that we can serve it regardless of which server picks up the request.
If there is no entry in the durable cache that matches the request, we continue on.
Serverless Functions
At this point, we'll check whether the request matches a serverless function. Just like edge functions, you can configure serverless functions to
match requests on a specific path or a range of paths
.
If the request matches, there's one last check we'll do before invoking the function. If you want your function to act as a fallback or a "catch-all" handler, you can configure it so that any static file that also matches the request will be served, running the function only if no matching static file exists.
To opt-in to this behavior, you must set
preferStatic: true
in your function configuration. Unless you enable this configuration, any matching function is always invoked.
If we didn't match any functions, the request continues on.
Redirects
Next up, we evaluate any
redirects and rewrites
. These are a simple yet powerful way of creating custom routing rules, based on different types of conditions, to any type of destination (the same site, a different Netlify site, or any site on the web).
When you target the same site, we employ some special rules that are important to know. By default, redirects behave as fallbacks, which means that a redirect rule from
/foo
to
/bar
actually means
serve
/bar
if
/foo
doesn't match anything
. This is typically known as
shadowing
and it's equivalent to the
preferStatic
configuration we saw earlier.
If you'd like to opt out of this behavior and always serve the redirect destination regardless of whether the source matches something else, you can set the
force
property to
true
for redirects declared in
netlify.toml
, or use an exclamation mark in the
_redirects
file.
If the redirect matches a function, we'll follow the same evaluation logic covered in the previous step, including the check for
preferStatic
, so you can think of it as going back one step in the request chain. It's important to note that this is not a recursive operation, as we won't evaluate redirects again.
When no redirect rules match, the request continues on.
Static files
Now we try to match any static files that you or your framework have placed in the
publish directory
during the build process.
We match the request's URL path against filenames, so
<your-site>.netlify.app/about
matches files like
about.html
or
about/index.html
.
This is typically how static assets like HTML pages, images or fonts are served.
404 handler
If the request didn't match anything up until this point, it means we don't have anything to serve. This can happen if the client requests a path that doesn't exist.
You can provide your own 404 page. If you don't, we'll serve a generic one.
Last updated: May 29, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_security-checklist.txt --------
Start of file
URL: https://docs.netlify.com/platform/security-checklist/
Scraped_At: 2025-06-02T19:58:45.423448

Contact
Forums
Contact support
Netlify’s platform allows teams to securely build, collaborate on, deploy, and monitor websites, e-commerce stores, and web applications. This guide provides an overview of the inherent security benefits of composable application architecture and built-in Netlify platform security. It also outlines additional steps you should take to protect your company’s assets.
#
Composable architecture advantages
As opposed to monolithic applications, which expose more of your site functionality to attack, sites built with composable application architecture don’t depend on a traditional model of web servers and load balancers. Instead, these types of sites leverage pre-built assets deployed to a content delivery network (CDN), with a layer of serverless runtimes that run operations on a cloud-based server environment. The web server is abstracted away, and any remaining proprietary backend functionality is provided using serverless functions.
Building a site with composable application architecture allows you to decouple the site’s frontend from its backend and rely on services and their APIs to provide specific functionality. This can prevent attackers from moving laterally throughout an application because functionality is segmented by third-party services and APIs.
#
Netlify’s secure platform
The Netlify platform is built and monitored with security in mind. Read more about how our
isolated build and rendering environments
,
encryption
, active
attack mitigation
, up-to-date
compliance and certifications
, and
sensible limitations and defaults
contribute to this baseline security.
#
Isolated environments
Netlify’s containerized build environment spins up new, temporary containers just long enough to execute their tasks. Pages rendered through serverless functions similarly execute their rendering in a secure, temporary environment, ensuring that sensitive data is not exposed to potential attackers. No idle environments are there to exploit, and there is limited exposure to public networks.
#
Encryption
Netlify provides secure communication through HTTPS encryption. SSL/TLS certificates are provisioned automatically through Let’s Encrypt, or you can bring your own certificate.
#
Attack mitigation
Netlify’s DDoS protections work to prevent malicious traffic from disrupting site access. We use various techniques to mitigate DDoS attacks: monitoring traffic pattern anomalies, identifying and blocking malicious traffic, and ensuring that sites and apps remain available on our global CDN. We also automatically block and prevent many common attacks such as directory traversal.
#
Compliance and certifications
Netlify undergoes yearly penetration testing and maintains certifications for SOC 2 type 2 and ISO 27001 compliance through annual third-party auditing. Our platform complies with GDPR, CCPA, and PCI-DSS, so data is handled securely and according to regulations.
#
Sensible limitations and defaults
Netlify makes it easier to do the right thing in terms of security. For example,
netlify.app
is on Mozilla Foundation’s
Public Suffix List
, which prevents setting cookies across subdomains. This means that developers can’t accidentally expose sensitive cookie data with a
.netlify.app
cookie.
We’ve set another guardrail to ensure that Netlify websites have HTTPS connections by default through our automatically provisioned TLS certificates.
As a default behavior, Netlify detects and masks out sensitive environment variable values in deploy logs. In addition, our
sensitive variable policy
default setting for public repositories prevents untrusted pull/merge requests from building with sensitive variable values. When there are potentially sensitive environment variables in your site configuration, untrusted deploys require approval.
Plus, all requests to the data layer GraphQL APIs in Netlify Connect
require an API token
to ensure that only authorized users have access to your data. You can also restrict access to specific data types and fields using API scopes. These types of limitations and defaults set teams up for more secure development.
#
Recommended security measures
Along with the built-in platform security measures mentioned above, your team can manage security controls that provide a multi-layered approach to web app and data protection. We recommend that you consider the following security measures:
Manage and monitor access to Netlify
Build securely
Keep secrets safe
Protect your sites
Implement a Content Security Policy
Monitor site activity
#
1. Manage and monitor access to Netlify
You can take steps to secure and monitor access to Netlify at an organization level or team level.
#
Organization-level controls
If you have an
organization
set up to manage your Netlify teams, we recommend configuring
SAML single sign-on (SSO)
for all of the teams in your organization at the same time, using your preferred identity provider. We also recommend
enforcing SSO login
for all team members in your organization.
Once you’ve got SAML SSO enabled for your organization, use
Directory Sync
to automatically provision Netlify users. Directory Sync leverages the System for Cross-domain Identity Management (SCIM) to assign your teammates to Netlify teams and user roles based on directory group mappings in your preferred identity provider.
We recommend setting up two-factor authentication (2FA) to further secure your organization. You can set up 2FA through your identity provider or
within Netlify
.
#
Team-level controls
If you don’t have an organization to manage your Netlify teams, you can still configure
SAML SSO
on each of your teams for secure Netlify access. We recommend
enforcing SSO login
for all team members.
Keep track of actions made by members of your team by using the
team audit log
to monitor activity across all of your team’s sites and settings. You can use this detailed record of system activity to identify and investigate security incidents or other issues.
We recommend setting up two-factor authentication (2FA) to further secure your organization. You can configure and enforce 2FA through your identity provider or
within Netlify
.
#
2. Build securely
As your team builds your websites, e-commerce stores, or web apps, they can take advantage of several Netlify integrations to build out your codebase with security in mind.
#
Snyk integration
Use our
integration with Snyk
to find security issues and address them before deploying. Snyk helps to detect security concerns in your production dependencies or in your serverless functions. Snyk can also help you to build a software bill of materials (SBOM) to list out all software components used across your sites.
#
Very Good Security integration
Take advantage of our
integration with Very Good Security
, which provides end-to-end encryption and tokenization of sensitive data such as personally identifiable information (PII). For example, you can use it to
manage sensitive data in form uploads
.
#
3. Keep secrets safe
Sites using composable architecture are likely to integrate with third-party services, so it’s important to keep secrets associated with those services safe and secure. Use
environment variables
to securely store and manage sensitive data like API keys, secrets, or configuration values. Take the following steps to keep your environment variables secure.
#
Control secrets with strict security measures
For your most sensitive environment variable values, use Netlify
Secrets Controller
to apply stricter security measures and perform secrets scanning of your code and build output files.
#
Limit secret access and exposure
Only use environment variables
at the team level
for pure configuration of a non-sensitive nature, as opposed to setting them for individual sites. Best practice is to generate a unique secret for each site to minimize the impact if a secret is leaked.
Avoid storing sensitive variable values in a
netlify.toml
or
.env
file in your project as these files may be committed to your repository. Instead, create and store your environment variables securely on Netlify
using the Netlify UI, CLI, or API
.
To narrow the scope of exposure of a site’s secret, use
scopes
. Scopes enable you to limit environment variables so that they can only be accessed by builds, functions, other runtime features, or post-processing. This helps you control where Netlify uses your sensitive data and limits your risk exposure.
#
Manage compromised secrets
Rotate secrets as needed by
modifying existing environment variables
.
Although Netlify masks out sensitive environment variable values in deploy logs, you can also
manually delete a deploy
should you need to.
#
Consider secrets in public repositories
We recommend that you do not deploy sensitive sites from public repositories. However, you can familiarize yourself with our
sensitive variable policy
to consider the best setting for deploying from any public repositories your team owns.
#
4. Protect your sites
These recommendations help you keep sites secure, either by limiting who can access a site or by using more robust measures to protect your sites from attack.
#
Control site access with rate limiting or Firewall Traffic Rules
Set up highly-customizable rate limits for your sites. Learn more about
rate limiting
.
Or block site traffic by IP address or geographic location with Firewall Traffic Rules. Learn more about
setting up Firewall Traffic rules
.
#
Limit production site access
If your production site is internal-facing or if you have private content that’s shared with a certain set of users, set up
Site Protection
to provide appropriate access to your production site. Site Protections options include
team login protection and basic password protection
, configurable for every site on your team or on a per-site level.
You can also restrict access to parts of your production site or permit content for a subset of users with
role-based access control
using
Netlify Identity
or external third party providers like Auth0 or Okta.
#
Limit non-production site access
We recommend using
Site Protection with team login
to keep non-production preview environments such as Deploy Previews and branch deploys locked down so that only members of your Netlify team can access them.
#
Add best practice security headers
To ensure secure communication over HTTPS (including all subdomains), set up
HSTS preload
to force HTTPS connections for your custom domains.
#
Restrict who can generate Let’s Encrypt certificates
Add a Certificate Authority Authorization (CAA) record to your DNS provider to specify that only Netlify can
generate Let’s Encrypt certificates
for your custom domain.
#
Protect your backend
Configure
Private Connectivity
to reduce the risk to your backend environment and improve compliance. With Private Connectivity, your builds and serverless functions will contact your backend from a specific set of IP addresses that you can allowlist so that you don’t have to open up your backend to the whole internet.
#
5. Implement a Content Security Policy
A
Content Security Policy
(CSP) allows you to control scripts, content, and other resources from fetching or executing on your site. By defining an allowlist of domains, content hashes, and/or cryptographic nonces, you can prevent the user’s browser from requesting resources from malicious actors.
When you set up a hardened CSP, you make it much more difficult for malicious actors to perform cross-site scripting (XSS) attacks, exfiltrate user data, and deface the frontend of your website.
To learn more, check out our
CSP configuration docs
or follow a
tutorial
from our blog.
#
6. Monitor site activity
Use
Project Analytics
to keep a pulse on how many people are visiting which pages in your site, from where. This enables you to notice unusual patterns of site activity.
Set up
Log Drains
to providers such as Datadog, New Relic, and others. With Log Drains, you can monitor site traffic logs, function logs, and edge function logs for analysis, alerting, and data persistence.
Check the
Site audit log
to investigate actions taken for a specific site.
#
More Netlify security resources
Netlify Blog: Security posts
Security at Netlify
Trust Center
, where you can download our reference architecture for HIPAA-compliant composable sites on Netlify
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- platform_what-is-netlify.txt --------
Start of file
URL: https://docs.netlify.com/platform/what-is-netlify/
Scraped_At: 2025-06-02T19:58:46.044241

Try Netlify
Deploy to Netlify
Deploy a demo project on Netlify to make it available on the web. Get to know some key features including Deploy Previews, rollbacks, Netlify Functions, environment variables, redirects, and Netlify Forms.
Follow our tutorial
Demo repo
Demo site
Deploy from your own GPT
###End of file##

-------- platform_who-is-netlify-for.txt --------
Start of file
URL: https://docs.netlify.com/platform/who-is-netlify-for/
Scraped_At: 2025-06-02T19:58:46.643384

Start building 🚀
Check out our Get started guides:
Get started with Netlify
Add a site or use a template site
Deploy to Netlify from your own GPT
Get started with Connect and managing data sources
Get started with the visual editor for sites
###End of file##

-------- routing_headers.txt --------
Start of file
URL: https://docs.netlify.com/routing/headers/
Scraped_At: 2025-06-02T19:58:47.493520

Contact
Forums
Contact support
With custom headers, you can make custom adjustments or additions to the default
HTTP headers
that Netlify serves with your site when a client makes a request.
You can configure custom headers for your Netlify site in two ways:
Save a plain text file called
_headers
to the
publish directory
of your site. You can find
_headers
file syntax
details below.
Add one or more
headers
tables to your
Netlify configuration file
. This method allows for more structured configuration and additional capabilities, as described in the
Netlify configuration file syntax
section below.
#
Limitations
Custom headers apply only to files Netlify serves from our own backing store. If you are
proxying content to your site
or dealing with a URL handled by a
function
or
edge function
such as a server-side rendered (SSR) page, custom headers won’t be applied to that content. In those cases, the site being proxied to or the function should return any required headers instead. Visit our docs on edge functions to learn how to
configure
cache-control
headers for edge functions
.
When you declare headers in a
_headers
file stored in the publish directory or a Netlify configuration file, the headers are global for all builds and cannot be scoped for specific branches or deploy contexts. However, there is a workaround you can use to
set unique headers for each deploy context
.
You can set most
HTTP response fields
using custom headers. The following header names are exceptions. Custom headers for these are typically ignored because Netlify’s web servers need to set these headers to work properly.
Accept-Ranges
Age
Allow
Alt-Svc
Connection
Content-Encoding
Content-Length
Content-Range
Date
Location
- use
redirects
instead
Server
Set-Cookie
- may be overridden by Netlify cookie handling
Trailer
Transfer-Encoding
Upgrade
Setting cookies across subdomains only works for custom domains
netlify.app
is listed in the Mozilla Foundation’s
Public Suffix List
, which prevents setting cookies across subdomains. You can only set a cookie for all subdomains if your site uses a
custom domain
instead of
yoursitename.netlify.app
.
#
Syntax for the
_headers
file
In a
_headers
file, you can specify one or several URL paths with their additional headers indented below them:
Any line beginning with
#
will be ignored as a comment.
Header field names are case insensitive.
Paths can contain
wildcards and placeholders
.
Here is an example of a
_headers
file with two URL paths:
# a path:
/templates/index.html
  # headers for that path:
  X-Frame-Options: DENY
# another path:
/templates/index2.html
  # headers for that path:
  X-Frame-Options: SAMEORIGIN
Here’s an example of setting the
X-Frame-Options
header for all pages on your site:
/*
  X-Frame-Options: DENY
Make sure we can access the file
If you’re running a build command or site generator, the
_headers
file should end up in the folder you’re deploying. Some generators, like Jekyll, may also require additional configuration to avoid exclusion of files that begin with
_
. (For Jekyll, this requires
adding an
include
parameter
to
_config.yml
.)
#
Syntax for the Netlify configuration file
If you specify your header rules in your
Netlify configuration file
, you can use a more structured configuration format with additional capabilities such as
headers for proxy redirects
:
We use
TOML’s array of tables
to specify each individual header rule.
The following keywords are available:
for
: the path or URL where the headers will be added.
values
: a map of values to add to the response headers.
Header field names are case insensitive.
Paths can contain
wildcards and placeholders
.
Here’s an example:
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
X-Frame-Options
=
"DENY"
#
Wildcards and placeholders in paths
Whether you declare headers in a dedicated
_headers
file or using the
[[headers]]
section of
netlify.toml
, you can take advantage of wildcards and placeholders in URL path segments:
Wildcards (
*
) can be used at any place inside of a path segment to match any character.
Placeholders (
:placeholders
) can only be used at the start of a path segment to match any character except
/
.
Wildcards and placeholders cannot be within the same path segment.
For example,
/templates/:placeholder*
won’t work as the wildcard is considered part of the placeholder name.
/templates/*:placeholder
won’t work as the placeholder needs to be at the beginning of the path segment, right after the
/
.
Note that Netlify processes wildcards and placeholders in redirects differently than those used in headers. Learn more about the options and limitations for
wildcards in splats
and
placeholders
in the
redirect options
doc.
#
Multi-value headers
Some header fields can accept multiple values.
In a
_headers
file, you can configure multi-value headers by listing multiple headers with the same field name. Netlify will concatenate the values of those headers into a single header as described in the
RFC 7230
.
For example, you can include several
cache-control
header fields in the file, like this:
/*
  cache-control: max-age=0
  cache-control: no-cache
  cache-control: no-store
  cache-control: must-revalidate
In a
netlify.toml
, multi-value headers are expressed with multiline strings:
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
cache-control
=
'''
  max-age=0,
  no-cache,
  no-store,
  must-revalidate'''
In both cases, the values will be collapsed into one header following the HTTP 1.1 specification:
cache-control: max-age=0,no-cache,no-store,must-revalidate
#
Custom headers for different branch or deploy contexts
By default, when you declare headers in a
_headers
file stored in the publish directory or in a Netlify configuration file (
netlify.toml
), the headers are global for all builds and cannot be scoped for specific branches or
deploy contexts
.
To set custom headers for a specific branch or deploy context:
Remove any global header declarations from
netlify.toml
and, if you have one, remove the
_headers
file from the publish directory.
Create a new custom directory to store your deploy context-specific header files, such as
/custom-headers
.
Create header files for each custom configuration you require and store them in the custom directory. While you can use any file name for each custom file, the files must still follow the
syntax for headers files
outlined above.
In
netlify.toml
, modify the build command for each deploy context that requires headers. Add the following script to the end of the build command:
&& cp path-to-your-header-file path-to-your-publish-dir/_headers
When the build command for the deploy context runs, Netlify will copy the custom header file to a new file named
_headers
in the publish directory for use.
For example, if the custom headers folder is
custom-headers
and you want to apply a specific header file
_stagingHeaders
to your
staging
branch deploys, you would add the following to your
netlify.toml
:
# Configuration for branch deploys for the branch named `staging`.
# Remember to replace `npm run build` with your site's build command
# and replace `dist` with your site's publish directory.
[
context.staging
]
command
=
"npm run build && cp ./custom-headers/_stagingHeaders ./dist/_headers"
Note that in this example, the site uses
npm run build
as the build command and
dist
as the publish directory. You should replace those with the appropriate values for your site.
#
Basic authentication headers
This feature is available on
Pro
and
Enterprise
plans.
You can configure Netlify to provide
basic authentication
headers on paths you want to hide behind a password.
Visit the
basic authentication
page for more information.
Last updated: February 28, 2025
←
Static routing
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- routing_overview.txt --------
Start of file
URL: https://docs.netlify.com/routing/overview/
Scraped_At: 2025-06-02T19:58:48.078761

Contact
Forums
Contact support
Routing allows you to manage the traffic to and from your Netlify site.
You can enable powerful static routing features like
redirects
,
rewrites
, and
proxies
by defining rules in a site’s
_redirects
file or
Netlify configuration file
. As requests come in from site visitors, our CDN edge nodes evaluate these rules, pointing visitors to different paths or rewriting paths based on options or conditions like preferred language or current location. Rules can proxy an incoming request to another website or to execute a serverless function.
You can also define
custom headers
sent in response to site requests. These are controlled in a
_headers
file or
Netlify configuration file
for each Netlify site.
Build Plugins can dynamically access and modify a site’s redirects, headers, and other build configuration options
during the build
.
Last updated: October 2, 2024
Redirects & rewrites
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- routing_redirects.txt --------
Start of file
URL: https://docs.netlify.com/routing/redirects/
Scraped_At: 2025-06-02T19:58:48.697101

Contact
Forums
Contact support
You can configure redirect and rewrite rules for your Netlify site in two ways:
Save a plain text file called
_redirects
without a file extension to the
publish directory
of your site. You can find
_redirects
file syntax
details below.
Add one or more
redirects
tables to your
Netlify configuration file
. This method allows for more structured configuration and additional capabilities, as described in the
Netlify configuration file syntax
section below.
Framework considerations
If your site uses a specific framework, there may be additional redirect options or caveats for you to consider. Learn more in our
framework
docs.
Netlify processes and serializes your redirect rules across the
_redirects
and
netlify.toml
files. If the size of this output is too large, the deploy might fail.
If you need to set up 10,000 redirects or more, we recommend using
wildcards or placeholders
as much as possible. For a more complex redirect setup,
Edge Functions
can be a better option.
#
Syntax for the
_redirects
file
In a
_redirects
file, each redirect rule must be listed on a separate line, with the original path followed by the new path or URL. Any line beginning with
#
will be ignored as a comment. Paths are case-sensitive and special characters in paths must be url-encoded.
Here is an example:
# Redirects from what the browser requests to what we serve
/home                /
/blog/my-post.php    /blog/my-post
/news                /blog
/cuties              https://www.petsofnetlify.com
/authors/c%C3%A9line /authors/about-c%C3%A9line
You can customize and alter the redirect behavior by adding options to the end of each line such as HTTP status code, country conditions, or language conditions. Visit the
redirect options
doc for more details on these and other configuration options including query parameters,
forced redirects with
!
, domain-level redirects, and more. You can also use redirects for
rewrites and proxies
.
Make sure we can access the file
If you’re running a build command or site generator, the
_redirects
file should end up in the folder you’re deploying. Some generators, like Jekyll, may also require additional configuration to avoid exclusion of files that begin with
_
. (For Jekyll, this requires
adding an
include
parameter
to
_config.yml
.)
#
Syntax for the Netlify configuration file
If you specify your redirect rules in your
Netlify configuration file
, you can use a more structured configuration format with additional capabilities such as
signed proxy redirects
. In a
netlify.toml
file, we use
TOML’s array of tables
to specify each individual redirect rule. The following keywords are available:
from
: The case-sensitive path you want to redirect. Special characters must be url-encoded.
to
: The URL or path you want to redirect to. Special characters must be url-encoded.
status
: The
HTTP status code
you want to use in that redirect;
301
by default.
force
: Whether to override any existing content in the path or not;
false
by default. Visit the
shadowing
instructions for more details.
query
: Query string parameters REQUIRED to match the redirect. Visit the
query parameters
instructions for more details.
conditions
: Conditions to match the redirect, including
country
,
role
, and
cookie presence
conditions.
headers
: Additional request headers to send in
proxy redirects
.
signed
: Name of an environment variable for
signed proxy redirects
.
You can specify any number of rules in your
netlify.toml
following that format:
[
[
redirects
]
]
from
=
"/old-path"
to
=
"/new-path"
status
=
301
force
=
false
query
=
{
path
=
":path"
}
conditions
=
{
Language
=
[
"en"
]
,
Country
=
[
"US"
]
,
Role
=
[
"admin"
]
}
## This rule redirects to an external API, signing requests with a secret
[
[
redirects
]
]
from
=
"/search"
to
=
"https://api.mysearch.com"
status
=
200
force
=
true
# COMMENT: ensure that we always redirect
headers
=
{
X-From
=
"Netlify"
}
signed
=
"API_SIGNATURE_TOKEN"
Visit the
redirect options
doc for more details on configuration options including placeholders, trailing slashes, and more. Check out the
rewrites and proxies
doc for details on rewrite-specific options.
#
Rule processing order
The redirects engine will process the first matching rule it finds, reading from top to bottom. Rules in the
_redirects
file are always processed first, followed by rules in the Netlify configuration file.
The following example uses
_redirects
file syntax:
# This rule will trigger at /blog/my-old-title
/blog/my-old-title   /blog/my-new-title

# This rule will never trigger because the previous rule triggers first
/blog/my-old-title   /blog/an-even-better-title
Note that for each request, Netlify processes
edge functions
before redirects. For more information, visit our docs about the
edge function declaration processing order
.
Last updated: March 12, 2024
←
Static routing
Redirect options
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- routing_redirects_redirect-options.txt --------
Start of file
URL: https://docs.netlify.com/routing/redirects/redirect-options/
Scraped_At: 2025-06-02T19:58:49.437164

Contact
Forums
Contact support
Netlify’s redirect rules accept a number of options to customize how the paths are matched and redirected. Most of the examples on this page use the
_redirects
file syntax
, but all of these options are available in the
Netlify configuration file syntax
as well.
#
HTTP status codes
HTTP status codes are sent in server responses to the client or browser. The code gives information about the type of response.
You can specify the HTTP status code for any redirect rule. If left unspecified, the default is
301
.
Here are some examples of status codes you might use:
301
(default)
:
permanent redirect code. Tells the client that the address for this resource has permanently changed, and any indexes using the old address should start using the new one. The URL in the browser address bar will display the new address.
302
:
temporary redirect code. Use this status code instead of
307
, which is currently unsupported. Tells the client that the current address change is temporary. The URL in the browser address bar will display the new address.
404
:
not found code. You can use this status code to present
custom 404 pages
when visitors access paths on your site that don’t exist. With this status code, the page content will change, but the URL in the browser address bar will not.
200
:
OK code. Redirects with this status code will change the server response without changing the URL in the browser address bar. This is used for
rewrites and proxying
.
Here are some example redirect rules with status codes:
Loading error: Refresh the page to access this code sample
# Redirect with a 301
/home         /              301

# Redirect with a 302
/my-redirect  /              302

# Show a custom 404 for this path
/ecommerce    /store-closed  404

# Rewrite a path
/pass-through /index.html    200
# Redirect with a 301
[
[
redirects
]
]
from
=
"/home"
to
=
"/"
status
=
301
# Redirect with a 302
[
[
redirects
]
]
from
=
"/my-redirect"
to
=
"/"
status
=
302
# Show a custom 404 for this path
[
[
redirects
]
]
from
=
"/ecommerce"
to
=
"/store-closed"
status
=
404
# Rewrite a path
[
[
redirects
]
]
from
=
"/pass-through"
to
=
"/index.html"
status
=
200
#
Custom 404 page handling
You can set up a custom 404 page for all paths that don’t resolve to a static file. This doesn’t require any redirect rules. If you add a
404.html
page to your site, it will be picked up and displayed automatically for any failed paths.
You can also use this in combination with other features of our redirects by creating explicit entries for different paths:
Loading error: Refresh the page to access this code sample
/en/* /en/404.html 404
/de/* /de/404.html 404
[
[
redirects
]
]
from
=
"/en/*"
to
=
"/en/404.html"
status
=
404
[
[
redirects
]
]
from
=
"/de/*"
to
=
"/de/404.html"
status
=
404
Due to
the shadowing behavior
in our redirects system, the 404 pages will only be returned for nonexistent assets under the above paths.
#
Force redirects
There are times where a redirect will not happen because a file will match a URL path. In these cases, you can force the redirect to happen with either a
!
appended to your status code (for
_redirects
) or setting the
force
attribute to be true (on
netlify.toml
).
For example:
Loading error: Refresh the page to access this code sample
/best-pets/dogs  /best-pets/cats.html 200!
[
[
redirects
]
]
from
=
"/best-pets/dogs"
to
=
"/best-pets/cats.html"
status
=
200
force
=
true
In this forced redirect example,
/best-pets/dogs
will always display the content in
/best-pets/cats.html
even if there is a file at
/best-pets/dogs/index.html
.
Learn more in our docs on
shadowing
.
#
Splats
An asterisk indicates a
splat
that will match anything that follows it.
You can use the splat in your rewrites or redirects like this:
Loading error: Refresh the page to access this code sample
/news/*  /blog/:splat
[
[
redirects
]
]
from
=
"/news/*"
to
=
"/blog/:splat"
This would redirect paths like
/news/2004/01/10/my-story
to
/blog/2004/01/10/my-story
.
The redirect engine processes the
first matching rule
it finds, so more specific rules should be listed before more general ones:
Loading error: Refresh the page to access this code sample
# This will redirect /jobs/customer-ninja-rockstar
/jobs/customer-ninja-rockstar  /careers/support-engineer

# This will redirect all paths under /jobs except the path above
/jobs/*                        /careers/:splat

# This will never trigger, because the rule above will trigger first
/jobs/outdated-job-link        /careers/position-filled
# This will redirect /jobs/customer-ninja-rockstar
[
[
redirects
]
]
from
=
"/jobs/customer-ninja-rockstar"
to
=
"/careers/support-engineer"
# This will redirect all paths under /jobs except the path above
[
[
redirects
]
]
from
=
"/jobs/*"
to
=
"/careers/:splat"
# This will never trigger, because the rule above will trigger first
[
[
redirects
]
]
from
=
"/jobs/outdated-job-link"
to
=
"/careers/position-filled"
There are two limitations to be aware of when you use splats:
It’s not possible to use an asterisk as a wildcard in the middle of a path, for example
/jobs/*.html
. You can only use asterisks at the end of the path segment, such as
/jobs/*
.
It’s not possible to indicate a path to exclude from a splat redirect rule. Instead, we recommend that you take advantage of the
rule processing order
to set a more specific rule for the path that you want to exclude.
Note that Netlify processes wildcards (
*
) in headers differently than those used in redirects. Learn more about
how to use wildcards in headers
.
#
Placeholders
You can use placeholders in the origin and target paths:
/news/:month/:date/:year/:slug  /blog/:year/:month/:date/:slug
This would redirect a URL like
/news/02/12/2004/my-story
to
/blog/2004/02/12/my-story
. A placeholder either matches a path segment from one
/
to the next
/
or matches a final path segment including a file extension but excluding a query string.
Note that Netlify processes placeholders in headers differently than those used in redirects. Learn more about
how to use placeholders in headers
.
#
Query parameters
You can also use query parameters to more finely control your URL matches.
While our service automatically passes on all query string parameters to destination paths for redirects with
200
,
301
, and
302
HTTP status, you can also choose to define a redirect path based on a specific parameter or combination of parameters.
The following match redirects a URL like:
/store?id=my-blog-post
to
/blog/my-blog-post
with a
301
redirect. This affects request URLs with an
id
query parameter only.
/store id=:id  /blog/:id  301
Note that this rule matches only URLs that have only the
id
parameter and no others. If the URL contains other parameters in addition to or instead of
id
, the request doesn’t match that rule.
To match more than one query parameter, add separate key/value pairs separated by space:
/articles id=:id tag=:tag /posts/:tag/:id 301
If you have multiple parameters, some of which are optional, this is the pattern to follow to ensure that we are prepared to handle all possibilities. Note that the most general redirect is
after
the more specific ones:
# Both values - ordering from the browser doesn’t matter; this will cover either.
/path/* param1=:value1 param2=:value2 /otherpath/:value1/:value2/:splat 301

# One value or the other.  Must match exactly.
/path/* param1=:value1 /otherpath/:value1/:splat 301
/path/* param2=:value2 /otherpath/:value2/:splat 301

# Base case, when no params are passed.  
# Our system forwards all query params to the /otherpath URL if this is the only rule.  
# Otherwise it matches all requests not matched in a prior rule for the same path such as the ones above.
/path/* /otherpath/:splat 301
#
Trailing slash
Our CDN edge nodes do URL normalization before the redirect rules kick in. This happens to make sure we can guarantee the highest possible cache hit rate and the absolute best performance for your site.
What this means for your redirect rules is that Netlify will match paths to rules regardless of whether or not they contain a trailing slash.
# These rules are effectively the same:
# either rule alone would trigger on both paths
/blog/title-with-a-typo    /blog/typo-free-title
/blog/title-with-a-typo/   /blog/typo-free-title

# This rule will cause an infinite redirect
# because the paths are effectively the same
/blog/remove-my-slashes/   /blog/remove-my-slashes  301!
Using a proxy?
Netlify normalizes URLs by removing the trailing slash but not for internal rewrites. For example, if your route is handled by Site B but is requested as a rewrite on Site A, such as with
/old-path https://siteb.netlify.app/new-path 200
in your
_redirects
file, then normalization will not necessarily be applied.
You cannot use a redirect rule to add or remove a trailing slash. However, you
can
rely on Netlify’s
Pretty URLs
feature, which is enabled by default for sites and standardizes your URLs.
When Pretty URLs are enabled, Netlify forwards paths like
/about
to
/about/
(a common practice in static sites and single-page apps) and rewrites paths like
/about.html
to
/about/
.
Learn more about using Pretty URLs in this
official Support Guide
.
To check if Pretty URLs are enabled for your site go to
Project configuration
>
Build & deploy
>
Post processing
>
Pretty URLs
.
#
Domain-level redirects
All of the examples so far assume configuration for all domains assigned to the site, using the specified paths. If instead you need to do something special for a specific domain alias or protocol (HTTP vs HTTPS), you’ll want a pattern more like this one:
# http and https need separate rules if you don’t force_ssl!
http://blog.yoursite.com/* https://www.yoursite.com/blog/:splat 301!
https://blog.yoursite.com/* https://www.yoursite.com/blog/:splat 301!


# other URLS might proxy or redirect offsite
https://frontend.yoursite.com/login/* https://backend.yoursite.com/:splat 200
Refer to the
note on shadowing
for the reasoning behind the
!
— it is presumably the case that you have a
/blog/index.html
that you’d rather serve than your site’s main
index.html
in this case!
Domains must be assigned to the site
For Netlify to redirect from a domain that is not the site’s main custom domain, the domain must be assigned to the site — probably as a
domain alias
or a
branch subdomain
.
#
Redirect by country or language
For large multi-regional or multi-lingual sites, you may want to send site visitors to different content based on their location (by country GeoIP data) or their browser’s language configuration.
Netlify can handle these requests with GeoIP- and language-based redirects directly from our CDN nodes.
Both the language and the country can be specified in a cookie as well (
nf_lang
and
nf_country
respectively), so you can override the default behavior with JavaScript.
When you add these redirect rules, Netlify automatically creates alternate headers to enable the redirection in our CDN nodes. This removes the need for a round trip to our origin servers and ensures that normal pages, besides country or language based redirects, are cached on the CDN nodes.
Here are some examples:
# Redirect users in Australia or New Zealand to /anz.
# There CANNOT be spaces in the last parameter: Country=x,y,z or Language=xx,yy
/  /anz     302  Country=au,nz
# Redirect users in israel to /israel
/  /israel  302  Country=il

# Redirect users with Hebrew language preference from /israel to /israel/he
/israel/*  /israel/he/:splat  302  Language=he
The system is smart enough to flatten chains of redirect. In the above case, if a user in Israel with Hebrew language preference visits
/
, they’ll get redirected directly to
/israel/he
in one step. Our cache server will cache this redirect for any other users that would match the same country and language rules.
The
Country
attribute accepts
ISO 3166-1 alpha-2 country codes
.
The
Language
attribute accepts
standard browser language identification codes
and locale codes that combine language and country. Here is an example that uses both:
/products /en-us/products 301! Language=en-us
/products /en/products 301! Language=en
Users with
en-us
preference for English United States match the first rule and get redirected to
/en-us/products
. Users with any other
en-*
English language preference, such as
en-au
for English Australia, match the second rule and get redirected to
/en/products
. Users with non-English language preference, such as no language preference or
he
for Hebrew, get served the originally requested page
/products
.
Language quality values ignored
Language-based redirects always match against the first language reported by the browser in the
Accept-Language
header regardless of quality value weighting.
For more examples and guidance on setting redirects by country or language, check out our blog post on
country-based redirects
.
#
Redirect by role
Role-based redirects let you restrict access to certain paths of your application to logged-in visitors with certain roles, as authorized by Netlify Identity or any authentication provider that supports JSON Web Tokens (JWT). (Role-based redirects using external authentication providers is available on Enterprise
plans
.)
This access control is implemented at our CDN edge, removing the need for a round trip to our origin servers.
For more information, visit the page on
Role-based access control
.
#
Redirect by cookie presence
You may want to send site visitors to different content based on the HTTP cookies included in their incoming request.
Cookie-based redirects allow you to send visitors content based on whether a specific HTTP cookie exists in the request or not, regardless of its value. This condition checks the cookie name in a case-insensitive way. To match multiple cookies, include them in a list separated by commas.
For example:
Loading error: Refresh the page to access this code sample
# Forward requests to /legacy if the browser sends a cookie 
# named `is_legacy` or `my_other_cookie`
/* /legacy/:splat 200 Cookie=is_legacy,my_other_cookie
# Forward requests to /legacy if the browser sends a cookie
# named `is_legacy` or `my_other_cookie`
[
[
redirects
]
]
from
=
"/*"
to
=
"/legacy/:splat"
status
=
200
conditions
=
{
Cookie
=
[
"is_legacy"
,
"my_other_cookie"
]
}
Edge Functions
Last updated: May 13, 2025
←
Redirects & rewrites
Rewrites & proxies
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- routing_redirects_rewrites-proxies.txt --------
Start of file
URL: https://docs.netlify.com/routing/redirects/rewrites-proxies/
Scraped_At: 2025-06-02T19:58:50.273489

Contact
Forums
Contact support
When you assign an
HTTP status code
of
200
to a redirect rule, it becomes a
rewrite
. This means that the URL in the visitor’s address bar remains the same, while Netlify’s servers fetch the new location behind the scenes.
This can be useful for single page apps, proxying to other services, proxying to other Netlify sites (internal rewrites), or transitioning for legacy content.
Except where noted, the examples on this page use the
_redirects
file syntax
, but all of these options are available in the
Netlify configuration file syntax
as well.
#
Limitations
Rewrites can be very powerful, but there are a few things they cannot do:
For security reasons, rewrites between Netlify sites belonging to different teams are not allowed.
Infinitely looping rules, where the “from” and “to” resolve to the same location, are incorrect and will be ignored.
By default, we limit internal rewrites to one “hop” — you cannot proxy from Netlify SiteA to Netlify SiteB to Netlify SiteC in a single request. This limitation may be amended for customers on a case-by-case basis.
Contact support
for more information.
Proxy rewrite requests will time out after 26 seconds. If you are proxying to a longer-running process, we recommend making an asynchronous request rather than waiting for a response.
Rewrites can cause pages that use assets specified through relative paths to load incorrectly. To make sure your site’s proxied content is displayed as expected, use absolute paths for your assets or a
<base>
tag.
Paths handled by
proxies
or
functions
may not redirect from HTTP to HTTPS URLs as expected. If you’re working with proxies or functions, we recommend only publishing HTTPS URLs for your visitors to use.
While rewrites within the same password-protected site are supported, rewrites to separate password protected sites are not allowed.
#
History
pushState
and single-page apps
If you’re developing a single page app and want the history
pushState
method to work so you get clean URLs, you’ll want to add the following rewrite rule. If you have other redirect or rewrite rules, this is typically the last rule listed.
Loading error: Refresh the page to access this code sample
/*  /index.html  200
[
[
redirects
]
]
from
=
"/*"
to
=
"/index.html"
status
=
200
This will effectively serve the
index.html
instead of giving a
404
no matter what URL the browser requests.
#
Shadowing
By default, you can’t shadow a URL that actually exists within the site. This applies to rewrites using a
splat
or dynamic path segment as well as rewrites for individual routes or files. This means that even if you’ve setup the following rewrite rule:
/*   /index.html   200
The path
/partials/chat.html
would still render the contents of that file, if that file actually exists. This tends to be the preferred behavior when setting up rewrite rules for single page apps, etc.
If you’re 100% sure that you’ll always want to redirect, even when the URL matches a static file, you can append an exclamation mark to the rule:
/app/*  /app/index.html  200!
This will rewrite everything within
/app/*
to
/app/index.html
even if a file matches the URL.
This method can also be applied to individual routes or files:
/best-pets/dogs  /best-pets/cats.html 200!
With the rule above,
/best-pets/dogs
will always display the content in
/best-pets/cats.html
even if there is a file at
/best-pets/dogs/index.html
.
#
Proxy to another service
Similar to how you can rewrite paths like
/*
to
/index.html
, you can also set up rules to let parts of your site proxy to external services. Let’s say you need to communicate from a single-page app with an API on
https://api.example.com
that doesn’t support CORS requests. The following rule will let you use
/api/
from your JavaScript client:
/api/*  https://api.example.com/:splat  200
Now all requests to
/api/...
will be proxied through to
https://api.example.com
straight from our CDN servers without an additional connection from the browser. If the API supports standard HTTP caching mechanisms like ETags or
Last-Modified
headers, the responses will even get cached by our CDN nodes.
#
Custom headers in proxy redirects
For redirect rules specified in the
Netlify configuration file
, you can add a map with custom headers for your proxy redirects, and Netlify will send the custom headers to another website with every request:
[
[
redirects
]
]
from
=
"/search"
to
=
"https://api.mysearch.com"
status
=
200
force
=
true
headers
=
{
X-From
=
"Netlify"
}
Custom headers apply to the request, not the response
If you are proxying content to your site, custom headers will not be applied to that content.
#
Signed proxy redirects
You can use a
JSON Web Signature
(JWS) to sign all proxy requests to an external URL.
To enable JWS on your requests, Netlify requires a secret token. You can set the token in your
site’s environment variables
and indicate the variable name as the
signed
value in the redirect rule. Note that if you have the option to set specific
scopes
for your environment variables, the scope must include
Runtime
to be available for signed proxy redirects.
Netlify will inject the environment variable value automatically, so you don’t need to take extra steps to
substitute the variable value
in the configuration file. Once proxy redirects are added, Netlify will send the JWS as an HMAC HS256 encoded
x-nf-sign
header to another, non-Netlify website with every proxied request.
Signed proxy redirects must be specified in the
Netlify configuration file
.
[
[
redirects
]
]
from
=
"/search"
to
=
"https://api.mysearch.com"
status
=
200
force
=
true
signed
=
"API_SIGNATURE_TOKEN_PLACEHOLDER"
The JSON document we sign with this JWS header has this format:
{
"deploy_context"
:
"production"
,
"exp"
:
1623876755
,
"iss"
:
"netlify"
,
"netlify_id"
:
"1be0f471-6532-45ff-b1b1-f9c66ea24dc1"
,
"site_url"
:
"https://mysitename.netlify.app"
}
Signed proxy redirects for external sites only
When proxying from one Netlify application to another, using JWS to sign requests isn’t supported.
#
Proxy to another Netlify site
With internal rewrites, you can proxy from one Netlify site to another. If you want to proxy to another Netlify site, we recommend using the site’s
.netlify.app
subdomain instead of the custom domain in your rewrite rule:
/netlify-site/*  https://my-other-site.netlify.app/:splat  200
Last updated: May 15, 2023
←
Redirect options
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- scraping_log.txt --------
Start of file
2025-06-02 19:56:14,451 - INFO - [Beautiful_soup_text.py:40] - Session logging initialized. Log file: Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\scraping_log.txt
2025-06-02 19:56:14,961 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/
2025-06-02 19:56:15,037 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/ (Status: 200)
2025-06-02 19:56:15,101 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/ using selector: 'main'
2025-06-02 19:56:15,141 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\index.txt
2025-06-02 19:56:15,649 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/accounts-and-billing/team-management/roles-and-permissions/
2025-06-02 19:56:15,970 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/accounts-and-billing/team-management/roles-and-permissions/ (Status: 200)
2025-06-02 19:56:16,054 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/accounts-and-billing/team-management/roles-and-permissions/ using selector: 'main'
2025-06-02 19:56:16,090 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/accounts-and-billing/team-management/roles-and-permissions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\accounts-and-billing_team-management_roles-and-permissions.txt
2025-06-02 19:56:16,594 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/ai-assisted-publishing/
2025-06-02 19:56:16,879 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/ai-assisted-publishing/ (Status: 200)
2025-06-02 19:56:16,916 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/ai-assisted-publishing/ using selector: 'article'
2025-06-02 19:56:16,921 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/ai-assisted-publishing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\ai-assisted-publishing.txt
2025-06-02 19:56:17,431 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/api/get-started/
2025-06-02 19:56:20,424 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/api/get-started/ (Status: 200)
2025-06-02 19:56:20,630 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/api/get-started/ using selector: 'main'
2025-06-02 19:56:20,705 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/api/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\api_get-started.txt
2025-06-02 19:56:21,208 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/ask-netlify/
2025-06-02 19:56:21,238 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/ask-netlify/ (Status: 200)
2025-06-02 19:56:21,270 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/ask-netlify/ using selector: 'main'
2025-06-02 19:56:21,289 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/ask-netlify/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\ask-netlify.txt
2025-06-02 19:56:21,799 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/blobs/overview/
2025-06-02 19:56:22,060 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/blobs/overview/ (Status: 200)
2025-06-02 19:56:22,740 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/blobs/overview/ using selector: 'main'
2025-06-02 19:56:23,008 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/blobs/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\blobs_overview.txt
2025-06-02 19:56:23,512 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/build-plugins/
2025-06-02 19:56:24,083 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/build-plugins/ (Status: 200)
2025-06-02 19:56:24,163 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/build-plugins/ using selector: 'main'
2025-06-02 19:56:24,193 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/build-plugins/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\build-plugins.txt
2025-06-02 19:56:24,695 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/build-plugins/create-plugins/
2025-06-02 19:56:24,725 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/build-plugins/create-plugins/ (Status: 200)
2025-06-02 19:56:25,062 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/build-plugins/create-plugins/ using selector: 'main'
2025-06-02 19:56:25,193 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/build-plugins/create-plugins/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\build-plugins_create-plugins.txt
2025-06-02 19:56:25,699 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/build-plugins/share-plugins/
2025-06-02 19:56:25,983 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/build-plugins/share-plugins/ (Status: 200)
2025-06-02 19:56:26,028 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/build-plugins/share-plugins/ using selector: 'main'
2025-06-02 19:56:26,048 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/build-plugins/share-plugins/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\build-plugins_share-plugins.txt
2025-06-02 19:56:26,553 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/cli/debug-with-vscode/
2025-06-02 19:56:26,849 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/cli/debug-with-vscode/ (Status: 200)
2025-06-02 19:56:26,909 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/cli/debug-with-vscode/ using selector: 'main'
2025-06-02 19:56:26,933 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/cli/debug-with-vscode/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\cli_debug-with-vscode.txt
2025-06-02 19:56:27,449 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/cli/get-started/
2025-06-02 19:56:27,669 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/cli/get-started/ (Status: 200)
2025-06-02 19:56:27,771 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/cli/get-started/ using selector: 'main'
2025-06-02 19:56:27,822 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/cli/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\cli_get-started.txt
2025-06-02 19:56:28,333 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/cli/local-development/
2025-06-02 19:56:28,362 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/cli/local-development/ (Status: 200)
2025-06-02 19:56:28,423 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/cli/local-development/ using selector: 'main'
2025-06-02 19:56:28,446 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/cli/local-development/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\cli_local-development.txt
2025-06-02 19:56:28,951 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/cli/manage-functions
2025-06-02 19:56:29,414 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/cli/manage-functions (Status: 200)
2025-06-02 19:56:29,463 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/cli/manage-functions using selector: 'main'
2025-06-02 19:56:29,491 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/cli/manage-functions to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\cli_manage-functions.txt
2025-06-02 19:56:30,005 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/cli/manage-functions/
2025-06-02 19:56:30,031 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/cli/manage-functions/ (Status: 200)
2025-06-02 19:56:30,090 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/cli/manage-functions/ using selector: 'main'
2025-06-02 19:56:30,125 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/cli/manage-functions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\cli_manage-functions.txt
2025-06-02 19:56:30,642 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/available-software-at-build-time/
2025-06-02 19:56:30,783 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/available-software-at-build-time/ (Status: 200)
2025-06-02 19:56:30,843 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/available-software-at-build-time/ using selector: 'main'
2025-06-02 19:56:30,887 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/available-software-at-build-time/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_available-software-at-build-time.txt
2025-06-02 19:56:31,405 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/build-hooks/
2025-06-02 19:56:31,637 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/build-hooks/ (Status: 200)
2025-06-02 19:56:31,744 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/build-hooks/ using selector: 'main'
2025-06-02 19:56:31,771 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/build-hooks/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_build-hooks.txt
2025-06-02 19:56:32,285 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/environment-variables
2025-06-02 19:56:32,687 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/environment-variables (Status: 200)
2025-06-02 19:56:32,784 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/environment-variables using selector: 'main'
2025-06-02 19:56:32,835 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/environment-variables to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_environment-variables.txt
2025-06-02 19:56:33,353 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/environment-variables/
2025-06-02 19:56:33,417 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/environment-variables/ (Status: 200)
2025-06-02 19:56:33,526 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/environment-variables/ using selector: 'main'
2025-06-02 19:56:33,585 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/environment-variables/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_environment-variables.txt
2025-06-02 19:56:34,112 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/file-based-configuration/
2025-06-02 19:56:34,343 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/file-based-configuration/ (Status: 200)
2025-06-02 19:56:34,515 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/file-based-configuration/ using selector: 'main'
2025-06-02 19:56:34,617 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/file-based-configuration/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_file-based-configuration.txt
2025-06-02 19:56:35,135 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/ignore-builds/
2025-06-02 19:56:35,490 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/ignore-builds/ (Status: 200)
2025-06-02 19:56:35,572 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/ignore-builds/ using selector: 'main'
2025-06-02 19:56:35,616 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/ignore-builds/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_ignore-builds.txt
2025-06-02 19:56:36,188 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/javascript-spas/
2025-06-02 19:56:36,431 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/javascript-spas/ (Status: 200)
2025-06-02 19:56:36,490 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/javascript-spas/ using selector: 'main'
2025-06-02 19:56:36,532 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/javascript-spas/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_javascript-spas.txt
2025-06-02 19:56:37,058 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/manage-dependencies/
2025-06-02 19:56:37,287 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/manage-dependencies/ (Status: 200)
2025-06-02 19:56:37,379 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/manage-dependencies/ using selector: 'main'
2025-06-02 19:56:37,421 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/manage-dependencies/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_manage-dependencies.txt
2025-06-02 19:56:37,938 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/monorepos
2025-06-02 19:56:38,199 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/monorepos (Status: 200)
2025-06-02 19:56:38,274 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/monorepos using selector: 'main'
2025-06-02 19:56:38,311 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/monorepos to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_monorepos.txt
2025-06-02 19:56:38,814 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/monorepos/
2025-06-02 19:56:38,867 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/monorepos/ (Status: 200)
2025-06-02 19:56:38,935 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/monorepos/ using selector: 'main'
2025-06-02 19:56:38,980 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/monorepos/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_monorepos.txt
2025-06-02 19:56:39,491 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/on-demand-builders/
2025-06-02 19:56:39,757 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/on-demand-builders/ (Status: 200)
2025-06-02 19:56:39,897 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/on-demand-builders/ using selector: 'main'
2025-06-02 19:56:39,950 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/on-demand-builders/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_on-demand-builders.txt
2025-06-02 19:56:40,471 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/overview/
2025-06-02 19:56:40,502 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/overview/ (Status: 200)
2025-06-02 19:56:40,588 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/overview/ using selector: 'main'
2025-06-02 19:56:40,624 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_overview.txt
2025-06-02 19:56:41,137 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/stop-or-activate-builds/
2025-06-02 19:56:41,375 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/stop-or-activate-builds/ (Status: 200)
2025-06-02 19:56:41,427 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/stop-or-activate-builds/ using selector: 'main'
2025-06-02 19:56:41,457 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/stop-or-activate-builds/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_stop-or-activate-builds.txt
2025-06-02 19:56:41,976 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/configure-builds/troubleshooting-tips/
2025-06-02 19:56:42,160 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/configure-builds/troubleshooting-tips/ (Status: 200)
2025-06-02 19:56:42,242 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/configure-builds/troubleshooting-tips/ using selector: 'main'
2025-06-02 19:56:42,274 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/configure-builds/troubleshooting-tips/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\configure-builds_troubleshooting-tips.txt
2025-06-02 19:56:42,795 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/access-data/
2025-06-02 19:56:43,187 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/access-data/ (Status: 200)
2025-06-02 19:56:43,362 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/access-data/ using selector: 'main'
2025-06-02 19:56:43,464 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/access-data/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_access-data.txt
2025-06-02 19:56:43,992 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/api-authentication/
2025-06-02 19:56:44,292 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/api-authentication/ (Status: 200)
2025-06-02 19:56:44,366 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/api-authentication/ using selector: 'main'
2025-06-02 19:56:44,402 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/api-authentication/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_api-authentication.txt
2025-06-02 19:56:44,921 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/data-revisions/
2025-06-02 19:56:45,267 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/data-revisions/ (Status: 200)
2025-06-02 19:56:45,358 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/data-revisions/ using selector: 'main'
2025-06-02 19:56:45,384 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/data-revisions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_data-revisions.txt
2025-06-02 19:56:45,894 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/get-started/
2025-06-02 19:56:46,137 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/get-started/ (Status: 200)
2025-06-02 19:56:46,278 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/get-started/ using selector: 'main'
2025-06-02 19:56:46,347 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_get-started.txt
2025-06-02 19:56:46,862 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/manage-data-layers/manage-cross-references/
2025-06-02 19:56:47,150 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/manage-data-layers/manage-cross-references/ (Status: 200)
2025-06-02 19:56:47,207 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/manage-data-layers/manage-cross-references/ using selector: 'main'
2025-06-02 19:56:47,231 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/manage-data-layers/manage-cross-references/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_manage-data-layers_manage-cross-references.txt
2025-06-02 19:56:47,746 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/manage-data-layers/manage-data-sources/
2025-06-02 19:56:47,998 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/manage-data-layers/manage-data-sources/ (Status: 200)
2025-06-02 19:56:48,148 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/manage-data-layers/manage-data-sources/ using selector: 'main'
2025-06-02 19:56:48,414 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/manage-data-layers/manage-data-sources/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_manage-data-layers_manage-data-sources.txt
2025-06-02 19:56:48,923 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/monitor-activity/
2025-06-02 19:56:49,228 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/monitor-activity/ (Status: 200)
2025-06-02 19:56:49,287 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/monitor-activity/ using selector: 'main'
2025-06-02 19:56:49,317 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/monitor-activity/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_monitor-activity.txt
2025-06-02 19:56:49,823 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/overview/
2025-06-02 19:56:49,851 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/overview/ (Status: 200)
2025-06-02 19:56:49,911 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/overview/ using selector: 'main'
2025-06-02 19:56:49,936 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_overview.txt
2025-06-02 19:56:50,442 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/sync-events/
2025-06-02 19:56:50,768 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/sync-events/ (Status: 200)
2025-06-02 19:56:50,815 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/sync-events/ using selector: 'main'
2025-06-02 19:56:50,837 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/sync-events/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_sync-events.txt
2025-06-02 19:56:51,343 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/troubleshooting-tips/
2025-06-02 19:56:51,557 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/troubleshooting-tips/ (Status: 200)
2025-06-02 19:56:51,639 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/troubleshooting-tips/ using selector: 'main'
2025-06-02 19:56:51,669 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/troubleshooting-tips/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_troubleshooting-tips.txt
2025-06-02 19:56:52,183 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/connect/usage-and-billing/
2025-06-02 19:56:52,497 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/connect/usage-and-billing/ (Status: 200)
2025-06-02 19:56:52,565 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/connect/usage-and-billing/ using selector: 'main'
2025-06-02 19:56:52,585 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/connect/usage-and-billing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\connect_usage-and-billing.txt
2025-06-02 19:56:53,095 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/create/get-started/
2025-06-02 19:56:53,414 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/create/get-started/ (Status: 200)
2025-06-02 19:56:53,484 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/create/get-started/ using selector: 'main'
2025-06-02 19:56:53,522 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/create/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\create_get-started.txt
2025-06-02 19:56:54,026 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/create/overview
2025-06-02 19:56:54,073 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/create/overview (Status: 200)
2025-06-02 19:56:54,131 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/create/overview using selector: 'main'
2025-06-02 19:56:54,158 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/create/overview to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\create_overview.txt
2025-06-02 19:56:54,673 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/create/overview/
2025-06-02 19:56:54,731 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/create/overview/ (Status: 200)
2025-06-02 19:56:54,784 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/create/overview/ using selector: 'main'
2025-06-02 19:56:54,804 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/create/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\create_overview.txt
2025-06-02 19:56:55,320 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/create/visual-editing/
2025-06-02 19:56:55,388 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/create/visual-editing/ (Status: 200)
2025-06-02 19:56:55,463 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/create/visual-editing/ using selector: 'main'
2025-06-02 19:56:55,490 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/create/visual-editing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\create_visual-editing.txt
2025-06-02 19:56:56,003 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/add-a-domain-alias/
2025-06-02 19:56:56,318 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/add-a-domain-alias/ (Status: 200)
2025-06-02 19:56:56,368 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/add-a-domain-alias/ using selector: 'main'
2025-06-02 19:56:56,385 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/add-a-domain-alias/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_add-a-domain-alias.txt
2025-06-02 19:56:56,888 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/bring-a-domain-to-netlify/
2025-06-02 19:56:59,894 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/bring-a-domain-to-netlify/ (Status: 200)
2025-06-02 19:56:59,942 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/bring-a-domain-to-netlify/ using selector: 'main'
2025-06-02 19:57:00,080 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/bring-a-domain-to-netlify/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_bring-a-domain-to-netlify.txt
2025-06-02 19:57:00,581 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/configure-an-automatic-subdomain-for-deploys/
2025-06-02 19:57:00,888 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/configure-an-automatic-subdomain-for-deploys/ (Status: 200)
2025-06-02 19:57:00,961 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/configure-an-automatic-subdomain-for-deploys/ using selector: 'main'
2025-06-02 19:57:01,215 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/configure-an-automatic-subdomain-for-deploys/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_configure-an-automatic-subdomain-for-deploys.txt
2025-06-02 19:57:01,728 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/configure-external-dns/
2025-06-02 19:57:01,922 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/configure-external-dns/ (Status: 200)
2025-06-02 19:57:01,989 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/configure-external-dns/ using selector: 'main'
2025-06-02 19:57:02,012 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/configure-external-dns/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_configure-external-dns.txt
2025-06-02 19:57:02,527 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain
2025-06-02 19:57:02,572 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain (Status: 200)
2025-06-02 19:57:02,646 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain using selector: 'main'
2025-06-02 19:57:02,669 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_delegate-a-standalone-subdomain.txt
2025-06-02 19:57:03,189 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain/
2025-06-02 19:57:03,225 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain/ (Status: 200)
2025-06-02 19:57:03,297 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain/ using selector: 'main'
2025-06-02 19:57:03,321 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/delegate-a-standalone-subdomain/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_delegate-a-standalone-subdomain.txt
2025-06-02 19:57:03,830 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/dns-records/
2025-06-02 19:57:04,029 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/dns-records/ (Status: 200)
2025-06-02 19:57:04,109 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/dns-records/ using selector: 'main'
2025-06-02 19:57:04,137 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/dns-records/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_dns-records.txt
2025-06-02 19:57:04,647 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/enable-ipv6/
2025-06-02 19:57:04,906 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/enable-ipv6/ (Status: 200)
2025-06-02 19:57:04,964 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/enable-ipv6/ using selector: 'main'
2025-06-02 19:57:04,981 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/enable-ipv6/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_enable-ipv6.txt
2025-06-02 19:57:05,486 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/netlify-name-servers/
2025-06-02 19:57:05,741 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/netlify-name-servers/ (Status: 200)
2025-06-02 19:57:05,821 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/netlify-name-servers/ using selector: 'main'
2025-06-02 19:57:05,839 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/netlify-name-servers/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_netlify-name-servers.txt
2025-06-02 19:57:06,351 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/configure-domains/register-and-buy-a-domain/
2025-06-02 19:57:06,544 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/configure-domains/register-and-buy-a-domain/ (Status: 200)
2025-06-02 19:57:06,658 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/configure-domains/register-and-buy-a-domain/ using selector: 'main'
2025-06-02 19:57:06,709 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/configure-domains/register-and-buy-a-domain/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_configure-domains_register-and-buy-a-domain.txt
2025-06-02 19:57:07,223 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/domains-fundamentals/domains-glossary/
2025-06-02 19:57:07,257 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/domains-fundamentals/domains-glossary/ (Status: 200)
2025-06-02 19:57:07,309 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/domains-fundamentals/domains-glossary/ using selector: 'main'
2025-06-02 19:57:07,335 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/domains-fundamentals/domains-glossary/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_domains-fundamentals_domains-glossary.txt
2025-06-02 19:57:07,838 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/domains-fundamentals/understand-domains/
2025-06-02 19:57:08,099 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/domains-fundamentals/understand-domains/ (Status: 200)
2025-06-02 19:57:08,163 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/domains-fundamentals/understand-domains/ using selector: 'main'
2025-06-02 19:57:08,208 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/domains-fundamentals/understand-domains/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_domains-fundamentals_understand-domains.txt
2025-06-02 19:57:08,716 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/get-started-with-domains/
2025-06-02 19:57:08,748 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/get-started-with-domains/ (Status: 200)
2025-06-02 19:57:08,796 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/get-started-with-domains/ using selector: 'main'
2025-06-02 19:57:08,820 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/get-started-with-domains/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_get-started-with-domains.txt
2025-06-02 19:57:09,333 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/add-domain-redirect/
2025-06-02 19:57:09,364 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/add-domain-redirect/ (Status: 200)
2025-06-02 19:57:09,410 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/add-domain-redirect/ using selector: 'main'
2025-06-02 19:57:09,429 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/add-domain-redirect/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_add-domain-redirect.txt
2025-06-02 19:57:09,932 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/assign-a-domain-to-your-site-app/
2025-06-02 19:57:10,135 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/assign-a-domain-to-your-site-app/ (Status: 200)
2025-06-02 19:57:10,175 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/assign-a-domain-to-your-site-app/ using selector: 'main'
2025-06-02 19:57:10,197 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/assign-a-domain-to-your-site-app/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_assign-a-domain-to-your-site-app.txt
2025-06-02 19:57:10,705 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/automatic-deploy-subdomains/
2025-06-02 19:57:10,876 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/automatic-deploy-subdomains/ (Status: 200)
2025-06-02 19:57:10,944 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/automatic-deploy-subdomains/ using selector: 'main'
2025-06-02 19:57:10,984 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/automatic-deploy-subdomains/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_automatic-deploy-subdomains.txt
2025-06-02 19:57:11,490 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/manage-domains-for-a-site-app/
2025-06-02 19:57:11,785 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-a-site-app/ (Status: 200)
2025-06-02 19:57:11,862 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/manage-domains-for-a-site-app/ using selector: 'main'
2025-06-02 19:57:11,902 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/manage-domains-for-a-site-app/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_manage-domains-for-a-site-app.txt
2025-06-02 19:57:12,416 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/manage-domains-for-branch-deploys/
2025-06-02 19:57:15,045 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-branch-deploys/ (Status: 200)
2025-06-02 19:57:15,121 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/manage-domains-for-branch-deploys/ using selector: 'main'
2025-06-02 19:57:15,158 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/manage-domains-for-branch-deploys/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_manage-domains-for-branch-deploys.txt
2025-06-02 19:57:15,663 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/manage-domains-for-deploy-previews/
2025-06-02 19:57:15,968 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/manage-domains-for-deploy-previews/ (Status: 200)
2025-06-02 19:57:16,018 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/manage-domains-for-deploy-previews/ using selector: 'main'
2025-06-02 19:57:16,041 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/manage-domains-for-deploy-previews/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_manage-domains-for-deploy-previews.txt
2025-06-02 19:57:16,543 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/manage-multiple-domains/
2025-06-02 19:57:16,842 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/manage-multiple-domains/ (Status: 200)
2025-06-02 19:57:16,886 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/manage-multiple-domains/ using selector: 'main'
2025-06-02 19:57:16,907 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/manage-multiple-domains/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_manage-multiple-domains.txt
2025-06-02 19:57:17,410 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/overview/
2025-06-02 19:57:20,041 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/overview/ (Status: 200)
2025-06-02 19:57:20,092 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/overview/ using selector: 'main'
2025-06-02 19:57:20,120 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_overview.txt
2025-06-02 19:57:20,623 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/manage-domains/transfer-a-domain/
2025-06-02 19:57:20,952 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/manage-domains/transfer-a-domain/ (Status: 200)
2025-06-02 19:57:20,990 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/manage-domains/transfer-a-domain/ using selector: 'main'
2025-06-02 19:57:21,011 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/manage-domains/transfer-a-domain/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_manage-domains_transfer-a-domain.txt
2025-06-02 19:57:21,521 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/secure-domains-with-https/https-ssl/
2025-06-02 19:57:21,739 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/secure-domains-with-https/https-ssl/ (Status: 200)
2025-06-02 19:57:21,793 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/secure-domains-with-https/https-ssl/ using selector: 'main'
2025-06-02 19:57:21,815 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/secure-domains-with-https/https-ssl/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_secure-domains-with-https_https-ssl.txt
2025-06-02 19:57:22,328 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/set-up-netlify-dns/
2025-06-02 19:57:22,356 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/set-up-netlify-dns/ (Status: 200)
2025-06-02 19:57:22,403 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/set-up-netlify-dns/ using selector: 'main'
2025-06-02 19:57:22,424 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/set-up-netlify-dns/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_set-up-netlify-dns.txt
2025-06-02 19:57:22,932 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/troubleshooting-tips/
2025-06-02 19:57:23,253 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/troubleshooting-tips/ (Status: 200)
2025-06-02 19:57:23,301 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/troubleshooting-tips/ using selector: 'main'
2025-06-02 19:57:23,320 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/troubleshooting-tips/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_troubleshooting-tips.txt
2025-06-02 19:57:23,834 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/why-netlify-dns
2025-06-02 19:57:24,125 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/why-netlify-dns (Status: 200)
2025-06-02 19:57:24,170 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/why-netlify-dns using selector: 'main'
2025-06-02 19:57:24,188 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/why-netlify-dns to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_why-netlify-dns.txt
2025-06-02 19:57:24,696 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/domains/why-netlify-dns/
2025-06-02 19:57:24,727 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/domains/why-netlify-dns/ (Status: 200)
2025-06-02 19:57:24,783 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/domains/why-netlify-dns/ using selector: 'main'
2025-06-02 19:57:24,799 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/domains/why-netlify-dns/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\domains_why-netlify-dns.txt
2025-06-02 19:57:25,302 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/api/
2025-06-02 19:57:25,701 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/api/ (Status: 200)
2025-06-02 19:57:25,863 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/api/ using selector: 'main'
2025-06-02 19:57:25,982 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/api/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_api.txt
2025-06-02 19:57:26,493 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/create-integration/
2025-06-02 19:57:26,811 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/create-integration/ (Status: 200)
2025-06-02 19:57:26,876 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/create-integration/ using selector: 'main'
2025-06-02 19:57:26,917 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/create-integration/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_create-integration.txt
2025-06-02 19:57:27,429 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/declarations/
2025-06-02 19:57:27,456 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/declarations/ (Status: 200)
2025-06-02 19:57:27,536 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/declarations/ using selector: 'main'
2025-06-02 19:57:27,573 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/declarations/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_declarations.txt
2025-06-02 19:57:28,081 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/get-started/
2025-06-02 19:57:28,113 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/get-started/ (Status: 200)
2025-06-02 19:57:28,198 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/get-started/ using selector: 'main'
2025-06-02 19:57:28,228 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_get-started.txt
2025-06-02 19:57:28,734 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/limits/
2025-06-02 19:57:29,051 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/limits/ (Status: 200)
2025-06-02 19:57:29,090 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/limits/ using selector: 'main'
2025-06-02 19:57:29,109 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/limits/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_limits.txt
2025-06-02 19:57:29,620 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/optional-configuration/
2025-06-02 19:57:29,905 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/optional-configuration/ (Status: 200)
2025-06-02 19:57:30,010 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/optional-configuration/ using selector: 'main'
2025-06-02 19:57:30,042 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/optional-configuration/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_optional-configuration.txt
2025-06-02 19:57:30,552 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/overview/
2025-06-02 19:57:30,754 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/overview/ (Status: 200)
2025-06-02 19:57:30,802 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/overview/ using selector: 'main'
2025-06-02 19:57:30,824 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_overview.txt
2025-06-02 19:57:31,328 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/edge-functions/usage-and-billing/
2025-06-02 19:57:31,492 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/edge-functions/usage-and-billing/ (Status: 200)
2025-06-02 19:57:31,531 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/edge-functions/usage-and-billing/ using selector: 'main'
2025-06-02 19:57:31,548 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/edge-functions/usage-and-billing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\edge-functions_usage-and-billing.txt
2025-06-02 19:57:32,060 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/environment-variables/get-started/
2025-06-02 19:57:32,335 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/environment-variables/get-started/ (Status: 200)
2025-06-02 19:57:32,432 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/environment-variables/get-started/ using selector: 'main'
2025-06-02 19:57:32,469 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/environment-variables/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\environment-variables_get-started.txt
2025-06-02 19:57:32,985 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/environment-variables/overview/
2025-06-02 19:57:33,058 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/environment-variables/overview/ (Status: 200)
2025-06-02 19:57:33,141 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/environment-variables/overview/ using selector: 'main'
2025-06-02 19:57:33,172 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/environment-variables/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\environment-variables_overview.txt
2025-06-02 19:57:33,683 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/environment-variables/secrets-controller/
2025-06-02 19:57:33,976 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/environment-variables/secrets-controller/ (Status: 200)
2025-06-02 19:57:34,032 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/environment-variables/secrets-controller/ using selector: 'main'
2025-06-02 19:57:34,054 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/environment-variables/secrets-controller/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\environment-variables_secrets-controller.txt
2025-06-02 19:57:34,555 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/notifications/
2025-06-02 19:57:34,602 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/notifications/ (Status: 200)
2025-06-02 19:57:34,684 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/notifications/ using selector: 'main'
2025-06-02 19:57:34,725 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/notifications/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_notifications.txt
2025-06-02 19:57:35,242 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/setup/
2025-06-02 19:57:35,491 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/setup/ (Status: 200)
2025-06-02 19:57:35,679 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/setup/ using selector: 'main'
2025-06-02 19:57:35,758 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/setup/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_setup.txt
2025-06-02 19:57:36,270 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/spam-filters/
2025-06-02 19:57:36,623 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/spam-filters/ (Status: 200)
2025-06-02 19:57:36,758 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/spam-filters/ using selector: 'main'
2025-06-02 19:57:36,854 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/spam-filters/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_spam-filters.txt
2025-06-02 19:57:37,371 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/submissions/
2025-06-02 19:57:37,589 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/submissions/ (Status: 200)
2025-06-02 19:57:37,648 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/submissions/ using selector: 'main'
2025-06-02 19:57:37,679 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/submissions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_submissions.txt
2025-06-02 19:57:38,195 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/troubleshooting-tips/
2025-06-02 19:57:38,408 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/troubleshooting-tips/ (Status: 200)
2025-06-02 19:57:38,455 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/troubleshooting-tips/ using selector: 'main'
2025-06-02 19:57:38,473 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/troubleshooting-tips/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_troubleshooting-tips.txt
2025-06-02 19:57:38,983 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/forms/usage-and-billing/
2025-06-02 19:57:39,168 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/forms/usage-and-billing/ (Status: 200)
2025-06-02 19:57:39,212 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/forms/usage-and-billing/ using selector: 'main'
2025-06-02 19:57:39,236 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/forms/usage-and-billing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\forms_usage-and-billing.txt
2025-06-02 19:57:39,740 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks-api/
2025-06-02 19:57:40,046 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks-api/ (Status: 200)
2025-06-02 19:57:40,201 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks-api/ using selector: 'main'
2025-06-02 19:57:40,323 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks-api/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks-api.txt
2025-06-02 19:57:40,853 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/
2025-06-02 19:57:40,885 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/ (Status: 200)
2025-06-02 19:57:40,987 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/ using selector: 'main'
2025-06-02 19:57:41,032 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks.txt
2025-06-02 19:57:41,549 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/angular/
2025-06-02 19:57:41,617 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/angular/ (Status: 200)
2025-06-02 19:57:41,706 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/angular/ using selector: 'main'
2025-06-02 19:57:41,741 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/angular/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_angular.txt
2025-06-02 19:57:42,248 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/astro/
2025-06-02 19:57:42,281 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/astro/ (Status: 200)
2025-06-02 19:57:42,360 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/astro/ using selector: 'article'
2025-06-02 19:57:42,364 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/astro/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_astro.txt
2025-06-02 19:57:42,871 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/eleventy/
2025-06-02 19:57:42,921 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/eleventy/ (Status: 200)
2025-06-02 19:57:42,982 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/eleventy/ using selector: 'main'
2025-06-02 19:57:43,007 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/eleventy/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_eleventy.txt
2025-06-02 19:57:43,509 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/environment-variables/
2025-06-02 19:57:43,815 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/environment-variables/ (Status: 200)
2025-06-02 19:57:43,953 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/environment-variables/ using selector: 'main'
2025-06-02 19:57:44,012 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/environment-variables/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_environment-variables.txt
2025-06-02 19:57:44,525 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/express/
2025-06-02 19:57:44,558 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/express/ (Status: 200)
2025-06-02 19:57:44,666 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/express/ using selector: 'main'
2025-06-02 19:57:44,702 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/express/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_express.txt
2025-06-02 19:57:45,208 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/gatsby/
2025-06-02 19:57:45,236 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/gatsby/ (Status: 200)
2025-06-02 19:57:45,313 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/gatsby/ using selector: 'main'
2025-06-02 19:57:45,351 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/gatsby/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_gatsby.txt
2025-06-02 19:57:45,860 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/gatsby/?gatsby-version=adapters
2025-06-02 19:57:45,910 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/gatsby/?gatsby-version=adapters (Status: 200)
2025-06-02 19:57:45,994 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/gatsby/?gatsby-version=adapters using selector: 'main'
2025-06-02 19:57:46,038 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/gatsby/?gatsby-version=adapters to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_gatsby.txt
2025-06-02 19:57:46,545 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/hugo/
2025-06-02 19:57:46,738 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/hugo/ (Status: 200)
2025-06-02 19:57:46,789 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/hugo/ using selector: 'main'
2025-06-02 19:57:46,811 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/hugo/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_hugo.txt
2025-06-02 19:57:47,321 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/hydrogen/
2025-06-02 19:57:47,608 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/hydrogen/ (Status: 200)
2025-06-02 19:57:47,751 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/hydrogen/ using selector: 'article'
2025-06-02 19:57:47,770 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/hydrogen/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_hydrogen.txt
2025-06-02 19:57:48,283 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/overview
2025-06-02 19:57:48,326 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/overview (Status: 200)
2025-06-02 19:57:48,400 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/overview using selector: 'main'
2025-06-02 19:57:48,426 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/overview to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_overview.txt
2025-06-02 19:57:48,935 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/overview/
2025-06-02 19:57:48,967 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/overview/ (Status: 200)
2025-06-02 19:57:49,023 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/overview/ using selector: 'main'
2025-06-02 19:57:49,050 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_overview.txt
2025-06-02 19:57:49,555 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/adapter-upgrade/
2025-06-02 19:57:49,617 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/adapter-upgrade/ (Status: 200)
2025-06-02 19:57:49,666 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/adapter-upgrade/ using selector: 'main'
2025-06-02 19:57:49,688 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/adapter-upgrade/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_adapter-upgrade.txt
2025-06-02 19:57:50,193 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/advanced-api-routes/
2025-06-02 19:57:50,470 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/advanced-api-routes/ (Status: 200)
2025-06-02 19:57:50,533 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/advanced-api-routes/ using selector: 'main'
2025-06-02 19:57:50,571 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/advanced-api-routes/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_advanced-api-routes.txt
2025-06-02 19:57:51,079 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/middleware/
2025-06-02 19:57:51,121 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/middleware/ (Status: 200)
2025-06-02 19:57:51,246 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/middleware/ using selector: 'main'
2025-06-02 19:57:51,323 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/middleware/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_middleware.txt
2025-06-02 19:57:51,839 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/overview/
2025-06-02 19:57:51,871 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/overview/ (Status: 200)
2025-06-02 19:57:51,934 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/overview/ using selector: 'main'
2025-06-02 19:57:51,971 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_overview.txt
2025-06-02 19:57:52,474 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/redirects-and-rewrites/
2025-06-02 19:57:52,664 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/redirects-and-rewrites/ (Status: 200)
2025-06-02 19:57:52,724 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/redirects-and-rewrites/ using selector: 'main'
2025-06-02 19:57:52,749 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/redirects-and-rewrites/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_redirects-and-rewrites.txt
2025-06-02 19:57:53,264 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/next-js/runtime-v4/troubleshooting/
2025-06-02 19:57:53,477 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/next-js/runtime-v4/troubleshooting/ (Status: 200)
2025-06-02 19:57:53,549 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/next-js/runtime-v4/troubleshooting/ using selector: 'main'
2025-06-02 19:57:53,584 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/next-js/runtime-v4/troubleshooting/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_next-js_runtime-v4_troubleshooting.txt
2025-06-02 19:57:54,089 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/nuxt/
2025-06-02 19:57:54,309 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/nuxt/ (Status: 200)
2025-06-02 19:57:54,412 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/nuxt/ using selector: 'main'
2025-06-02 19:57:54,438 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/nuxt/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_nuxt.txt
2025-06-02 19:57:54,943 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/react-router/
2025-06-02 19:57:55,242 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/react-router/ (Status: 200)
2025-06-02 19:57:55,295 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/react-router/ using selector: 'article'
2025-06-02 19:57:55,298 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/react-router/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_react-router.txt
2025-06-02 19:57:55,802 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/react/
2025-06-02 19:57:56,172 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/react/ (Status: 200)
2025-06-02 19:57:56,235 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/react/ using selector: 'main'
2025-06-02 19:57:56,259 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/react/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_react.txt
2025-06-02 19:57:56,765 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/remix/
2025-06-02 19:57:57,100 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/remix/ (Status: 200)
2025-06-02 19:57:57,165 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/remix/ using selector: 'main'
2025-06-02 19:57:57,190 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/remix/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_remix.txt
2025-06-02 19:57:57,699 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/sveltekit/
2025-06-02 19:57:58,001 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/sveltekit/ (Status: 200)
2025-06-02 19:57:58,073 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/sveltekit/ using selector: 'main'
2025-06-02 19:57:58,106 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/sveltekit/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_sveltekit.txt
2025-06-02 19:57:58,617 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/tanstack-start/
2025-06-02 19:57:58,846 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/tanstack-start/ (Status: 200)
2025-06-02 19:57:58,893 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/tanstack-start/ using selector: 'article'
2025-06-02 19:57:58,896 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/tanstack-start/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_tanstack-start.txt
2025-06-02 19:57:59,409 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/vite/
2025-06-02 19:57:59,437 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/vite/ (Status: 200)
2025-06-02 19:57:59,497 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/vite/ using selector: 'main'
2025-06-02 19:57:59,523 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/vite/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_vite.txt
2025-06-02 19:58:00,029 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/frameworks/vue-cli/
2025-06-02 19:58:00,344 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/frameworks/vue-cli/ (Status: 200)
2025-06-02 19:58:00,387 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/frameworks/vue-cli/ using selector: 'main'
2025-06-02 19:58:00,805 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/frameworks/vue-cli/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\frameworks_vue-cli.txt
2025-06-02 19:58:01,319 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/api/
2025-06-02 19:58:01,346 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/api/ (Status: 200)
2025-06-02 19:58:01,433 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/api/ using selector: 'main'
2025-06-02 19:58:01,460 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/api/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_api.txt
2025-06-02 19:58:01,971 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/background-functions/
2025-06-02 19:58:02,188 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/background-functions/ (Status: 200)
2025-06-02 19:58:02,252 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/background-functions/ using selector: 'main'
2025-06-02 19:58:02,320 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/background-functions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_background-functions.txt
2025-06-02 19:58:02,838 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/deploy/
2025-06-02 19:58:03,053 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/deploy/ (Status: 200)
2025-06-02 19:58:03,126 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/deploy/ using selector: 'main'
2025-06-02 19:58:03,169 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/deploy/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_deploy.txt
2025-06-02 19:58:03,676 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/deploy/?fn-language=go
2025-06-02 19:58:03,706 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/deploy/?fn-language=go (Status: 200)
2025-06-02 19:58:03,803 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/deploy/?fn-language=go using selector: 'main'
2025-06-02 19:58:03,844 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/deploy/?fn-language=go to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_deploy.txt
2025-06-02 19:58:04,354 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/deploy/?fn-language=js
2025-06-02 19:58:04,383 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/deploy/?fn-language=js (Status: 200)
2025-06-02 19:58:04,470 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/deploy/?fn-language=js using selector: 'main'
2025-06-02 19:58:04,506 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/deploy/?fn-language=js to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_deploy.txt
2025-06-02 19:58:05,020 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/deploy/?fn-language=ts
2025-06-02 19:58:05,069 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/deploy/?fn-language=ts (Status: 200)
2025-06-02 19:58:05,178 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/deploy/?fn-language=ts using selector: 'main'
2025-06-02 19:58:05,255 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/deploy/?fn-language=ts to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_deploy.txt
2025-06-02 19:58:05,759 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/environment-variables/
2025-06-02 19:58:06,068 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/environment-variables/ (Status: 200)
2025-06-02 19:58:06,150 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/environment-variables/ using selector: 'main'
2025-06-02 19:58:06,185 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/environment-variables/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_environment-variables.txt
2025-06-02 19:58:06,700 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/functions-and-identity/
2025-06-02 19:58:06,913 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/functions-and-identity/ (Status: 200)
2025-06-02 19:58:06,980 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/functions-and-identity/ using selector: 'main'
2025-06-02 19:58:07,017 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/functions-and-identity/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_functions-and-identity.txt
2025-06-02 19:58:07,527 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/get-started/
2025-06-02 19:58:07,565 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/get-started/ (Status: 200)
2025-06-02 19:58:07,917 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/get-started/ using selector: 'main'
2025-06-02 19:58:08,028 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_get-started.txt
2025-06-02 19:58:08,532 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/get-started/?fn-language=ts
2025-06-02 19:58:08,570 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/get-started/?fn-language=ts (Status: 200)
2025-06-02 19:58:08,930 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/get-started/?fn-language=ts using selector: 'main'
2025-06-02 19:58:09,027 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/get-started/?fn-language=ts to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_get-started.txt
2025-06-02 19:58:09,536 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/lambda-compatibility/
2025-06-02 19:58:09,575 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/lambda-compatibility/ (Status: 200)
2025-06-02 19:58:10,189 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/lambda-compatibility/ using selector: 'main'
2025-06-02 19:58:10,348 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/lambda-compatibility/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_lambda-compatibility.txt
2025-06-02 19:58:10,857 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=go
2025-06-02 19:58:10,896 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=go (Status: 200)
2025-06-02 19:58:11,214 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/lambda-compatibility/?fn-language=go using selector: 'main'
2025-06-02 19:58:11,347 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/lambda-compatibility/?fn-language=go to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_lambda-compatibility.txt
2025-06-02 19:58:11,862 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=js
2025-06-02 19:58:11,916 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=js (Status: 200)
2025-06-02 19:58:12,209 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/lambda-compatibility/?fn-language=js using selector: 'main'
2025-06-02 19:58:12,359 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/lambda-compatibility/?fn-language=js to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_lambda-compatibility.txt
2025-06-02 19:58:12,869 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=ts
2025-06-02 19:58:14,740 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/lambda-compatibility/?fn-language=ts (Status: 200)
2025-06-02 19:58:15,038 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/lambda-compatibility/?fn-language=ts using selector: 'main'
2025-06-02 19:58:15,178 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/lambda-compatibility/?fn-language=ts to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_lambda-compatibility.txt
2025-06-02 19:58:15,691 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/logs/
2025-06-02 19:58:15,977 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/logs/ (Status: 200)
2025-06-02 19:58:16,023 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/logs/ using selector: 'main'
2025-06-02 19:58:16,042 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/logs/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_logs.txt
2025-06-02 19:58:16,545 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/optional-configuration/
2025-06-02 19:58:16,849 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/optional-configuration/ (Status: 200)
2025-06-02 19:58:16,924 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/optional-configuration/ using selector: 'main'
2025-06-02 19:58:16,959 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/optional-configuration/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_optional-configuration.txt
2025-06-02 19:58:17,461 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/optional-configuration/?fn-language=ts
2025-06-02 19:58:20,069 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/optional-configuration/?fn-language=ts (Status: 200)
2025-06-02 19:58:20,150 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/optional-configuration/?fn-language=ts using selector: 'main'
2025-06-02 19:58:20,186 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/optional-configuration/?fn-language=ts to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_optional-configuration.txt
2025-06-02 19:58:20,691 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/overview/
2025-06-02 19:58:20,721 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/overview/ (Status: 200)
2025-06-02 19:58:20,832 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/overview/ using selector: 'main'
2025-06-02 19:58:20,858 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_overview.txt
2025-06-02 19:58:21,360 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/scheduled-functions/
2025-06-02 19:58:21,665 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/scheduled-functions/ (Status: 200)
2025-06-02 19:58:21,759 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/scheduled-functions/ using selector: 'main'
2025-06-02 19:58:21,799 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/scheduled-functions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_scheduled-functions.txt
2025-06-02 19:58:22,316 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/trigger-on-events/
2025-06-02 19:58:22,598 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/trigger-on-events/ (Status: 200)
2025-06-02 19:58:22,647 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/trigger-on-events/ using selector: 'main'
2025-06-02 19:58:22,667 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/trigger-on-events/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_trigger-on-events.txt
2025-06-02 19:58:23,179 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/functions/usage-and-billing/
2025-06-02 19:58:23,342 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/functions/usage-and-billing/ (Status: 200)
2025-06-02 19:58:23,392 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/functions/usage-and-billing/ using selector: 'main'
2025-06-02 19:58:23,426 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/functions/usage-and-billing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\functions_usage-and-billing.txt
2025-06-02 19:58:23,932 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/get-started/
2025-06-02 19:58:23,965 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/get-started/ (Status: 200)
2025-06-02 19:58:24,118 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/get-started/ using selector: 'article'
2025-06-02 19:58:24,121 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/get-started/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\get-started.txt
2025-06-02 19:58:24,637 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/git/repo-permissions-linking/
2025-06-02 19:58:24,789 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/git/repo-permissions-linking/ (Status: 200)
2025-06-02 19:58:24,869 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/git/repo-permissions-linking/ using selector: 'main'
2025-06-02 19:58:24,903 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/git/repo-permissions-linking/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\git_repo-permissions-linking.txt
2025-06-02 19:58:25,418 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/image-cdn/overview/
2025-06-02 19:58:25,613 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/image-cdn/overview/ (Status: 200)
2025-06-02 19:58:25,697 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/image-cdn/overview/ using selector: 'main'
2025-06-02 19:58:25,740 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/image-cdn/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\image-cdn_overview.txt
2025-06-02 19:58:26,254 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/images/connect-how-connect-works-diagram-1.png
2025-06-02 19:58:26,546 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/images/connect-how-connect-works-diagram-1.png (Status: 200)
2025-06-02 19:58:27,157 - WARNING - [Beautiful_soup_text.py:219] - No primary content element found for URL: https://docs.netlify.com/images/connect-how-connect-works-diagram-1.png. Text might be incomplete.
2025-06-02 19:58:27,163 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/images/connect-how-connect-works-diagram-1.png to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\images_connect-how-connect-works-diagram-1.png.txt
2025-06-02 19:58:27,673 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/images/connect-syncing-data.png
2025-06-02 19:58:28,079 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/images/connect-syncing-data.png (Status: 200)
2025-06-02 19:58:28,203 - WARNING - [Beautiful_soup_text.py:219] - No primary content element found for URL: https://docs.netlify.com/images/connect-syncing-data.png. Text might be incomplete.
2025-06-02 19:58:28,205 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/images/connect-syncing-data.png to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\images_connect-syncing-data.png.txt
2025-06-02 19:58:28,711 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/integrations/contentful-integration/
2025-06-02 19:58:28,993 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/integrations/contentful-integration/ (Status: 200)
2025-06-02 19:58:29,141 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/integrations/contentful-integration/ using selector: 'main'
2025-06-02 19:58:29,217 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/integrations/contentful-integration/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\integrations_contentful-integration.txt
2025-06-02 19:58:29,727 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/integrations/extend-netlify/
2025-06-02 19:58:30,023 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/integrations/extend-netlify/ (Status: 200)
2025-06-02 19:58:30,062 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/integrations/extend-netlify/ using selector: 'main'
2025-06-02 19:58:30,091 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/integrations/extend-netlify/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\integrations_extend-netlify.txt
2025-06-02 19:58:30,607 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/integrations/overview/
2025-06-02 19:58:30,939 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/integrations/overview/ (Status: 200)
2025-06-02 19:58:31,002 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/integrations/overview/ using selector: 'main'
2025-06-02 19:58:31,026 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/integrations/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\integrations_overview.txt
2025-06-02 19:58:31,529 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/function-metrics/
2025-06-02 19:58:31,816 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/function-metrics/ (Status: 200)
2025-06-02 19:58:31,873 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/function-metrics/ using selector: 'main'
2025-06-02 19:58:31,896 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/function-metrics/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_function-metrics.txt
2025-06-02 19:58:32,407 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/lighthouse/
2025-06-02 19:58:32,638 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/lighthouse/ (Status: 200)
2025-06-02 19:58:32,718 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/lighthouse/ using selector: 'main'
2025-06-02 19:58:32,739 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/lighthouse/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_lighthouse.txt
2025-06-02 19:58:33,255 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/log-drains/
2025-06-02 19:58:33,596 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/log-drains/ (Status: 200)
2025-06-02 19:58:33,894 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/log-drains/ using selector: 'main'
2025-06-02 19:58:34,018 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/log-drains/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_log-drains.txt
2025-06-02 19:58:34,534 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/monitor-builds/
2025-06-02 19:58:34,868 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/monitor-builds/ (Status: 200)
2025-06-02 19:58:34,973 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/monitor-builds/ using selector: 'main'
2025-06-02 19:58:35,004 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/monitor-builds/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_monitor-builds.txt
2025-06-02 19:58:35,507 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/notifications/
2025-06-02 19:58:35,805 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/notifications/ (Status: 200)
2025-06-02 19:58:35,854 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/notifications/ using selector: 'main'
2025-06-02 19:58:35,872 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/notifications/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_notifications.txt
2025-06-02 19:58:36,381 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/project-analytics/
2025-06-02 19:58:36,532 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/project-analytics/ (Status: 200)
2025-06-02 19:58:36,619 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/project-analytics/ using selector: 'main'
2025-06-02 19:58:36,657 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/project-analytics/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_project-analytics.txt
2025-06-02 19:58:37,170 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/real-user-metrics/
2025-06-02 19:58:37,209 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/real-user-metrics/ (Status: 200)
2025-06-02 19:58:37,325 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/real-user-metrics/ using selector: 'main'
2025-06-02 19:58:37,399 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/real-user-metrics/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_real-user-metrics.txt
2025-06-02 19:58:37,915 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/monitor-sites/status-badges/
2025-06-02 19:58:38,197 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/monitor-sites/status-badges/ (Status: 200)
2025-06-02 19:58:38,286 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/monitor-sites/status-badges/ using selector: 'main'
2025-06-02 19:58:38,315 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/monitor-sites/status-badges/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\monitor-sites_status-badges.txt
2025-06-02 19:58:38,826 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/cache-api/
2025-06-02 19:58:39,243 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/cache-api/ (Status: 200)
2025-06-02 19:58:39,517 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/cache-api/ using selector: 'main'
2025-06-02 19:58:39,615 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/cache-api/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_cache-api.txt
2025-06-02 19:58:40,144 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/caching/
2025-06-02 19:58:40,195 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/caching/ (Status: 200)
2025-06-02 19:58:40,341 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/caching/ using selector: 'main'
2025-06-02 19:58:40,448 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/caching/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_caching.txt
2025-06-02 19:58:40,962 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/launch-checklist/
2025-06-02 19:58:41,122 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/launch-checklist/ (Status: 200)
2025-06-02 19:58:41,187 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/launch-checklist/ using selector: 'main'
2025-06-02 19:58:41,213 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/launch-checklist/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_launch-checklist.txt
2025-06-02 19:58:41,717 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/netlify-labs/experimental-features/
2025-06-02 19:58:42,025 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/netlify-labs/experimental-features/ (Status: 200)
2025-06-02 19:58:42,063 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/netlify-labs/experimental-features/ using selector: 'main'
2025-06-02 19:58:42,081 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/netlify-labs/experimental-features/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_netlify-labs_experimental-features.txt
2025-06-02 19:58:42,590 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/primitives/
2025-06-02 19:58:42,910 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/primitives/ (Status: 200)
2025-06-02 19:58:42,994 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/primitives/ using selector: 'article'
2025-06-02 19:58:42,997 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/primitives/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_primitives.txt
2025-06-02 19:58:43,498 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/release-phases/
2025-06-02 19:58:43,527 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/release-phases/ (Status: 200)
2025-06-02 19:58:43,587 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/release-phases/ using selector: 'main'
2025-06-02 19:58:43,624 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/release-phases/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_release-phases.txt
2025-06-02 19:58:44,131 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/request-chain/
2025-06-02 19:58:44,445 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/request-chain/ (Status: 200)
2025-06-02 19:58:44,507 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/request-chain/ using selector: 'main'
2025-06-02 19:58:44,551 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/request-chain/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_request-chain.txt
2025-06-02 19:58:45,058 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/security-checklist/
2025-06-02 19:58:45,345 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/security-checklist/ (Status: 200)
2025-06-02 19:58:45,398 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/security-checklist/ using selector: 'main'
2025-06-02 19:58:45,424 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/security-checklist/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_security-checklist.txt
2025-06-02 19:58:45,936 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/what-is-netlify/
2025-06-02 19:58:45,986 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/what-is-netlify/ (Status: 200)
2025-06-02 19:58:46,040 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/what-is-netlify/ using selector: 'article'
2025-06-02 19:58:46,045 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/what-is-netlify/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_what-is-netlify.txt
2025-06-02 19:58:46,559 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/platform/who-is-netlify-for/
2025-06-02 19:58:46,593 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/platform/who-is-netlify-for/ (Status: 200)
2025-06-02 19:58:46,640 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/platform/who-is-netlify-for/ using selector: 'article'
2025-06-02 19:58:46,643 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/platform/who-is-netlify-for/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\platform_who-is-netlify-for.txt
2025-06-02 19:58:47,155 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/routing/headers/
2025-06-02 19:58:47,407 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/routing/headers/ (Status: 200)
2025-06-02 19:58:47,468 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/routing/headers/ using selector: 'main'
2025-06-02 19:58:47,494 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/routing/headers/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\routing_headers.txt
2025-06-02 19:58:48,002 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/routing/overview/
2025-06-02 19:58:48,027 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/routing/overview/ (Status: 200)
2025-06-02 19:58:48,062 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/routing/overview/ using selector: 'main'
2025-06-02 19:58:48,079 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/routing/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\routing_overview.txt
2025-06-02 19:58:48,592 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/routing/redirects/
2025-06-02 19:58:48,621 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/routing/redirects/ (Status: 200)
2025-06-02 19:58:48,675 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/routing/redirects/ using selector: 'main'
2025-06-02 19:58:48,697 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/routing/redirects/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\routing_redirects.txt
2025-06-02 19:58:49,203 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/routing/redirects/redirect-options/
2025-06-02 19:58:49,319 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/routing/redirects/redirect-options/ (Status: 200)
2025-06-02 19:58:49,399 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/routing/redirects/redirect-options/ using selector: 'main'
2025-06-02 19:58:49,438 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/routing/redirects/redirect-options/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\routing_redirects_redirect-options.txt
2025-06-02 19:58:49,947 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/routing/redirects/rewrites-proxies/
2025-06-02 19:58:50,182 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/routing/redirects/rewrites-proxies/ (Status: 200)
2025-06-02 19:58:50,247 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/routing/redirects/rewrites-proxies/ using selector: 'main'
2025-06-02 19:58:50,274 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/routing/redirects/rewrites-proxies/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\routing_redirects_rewrites-proxies.txt
2025-06-02 19:58:50,784 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/content-security-policy/
2025-06-02 19:58:51,128 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/content-security-policy/ (Status: 200)
2025-06-02 19:58:51,209 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/content-security-policy/ using selector: 'main'
2025-06-02 19:58:51,244 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/content-security-policy/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_content-security-policy.txt
2025-06-02 19:58:51,759 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/overview/
2025-06-02 19:58:51,808 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/overview/ (Status: 200)
2025-06-02 19:58:51,863 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/overview/ using selector: 'main'
2025-06-02 19:58:51,888 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_overview.txt
2025-06-02 19:58:52,398 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/private-connectivity/
2025-06-02 19:58:52,713 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/private-connectivity/ (Status: 200)
2025-06-02 19:58:52,754 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/private-connectivity/ using selector: 'main'
2025-06-02 19:58:52,774 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/private-connectivity/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_private-connectivity.txt
2025-06-02 19:58:53,289 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/
2025-06-02 19:58:53,484 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/ (Status: 200)
2025-06-02 19:58:53,561 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/ using selector: 'main'
2025-06-02 19:58:53,599 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites.txt
2025-06-02 19:58:54,110 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/rate-limiting
2025-06-02 19:58:54,525 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/rate-limiting (Status: 200)
2025-06-02 19:58:54,737 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/rate-limiting using selector: 'main'
2025-06-02 19:58:54,804 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/rate-limiting to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites_rate-limiting.txt
2025-06-02 19:58:55,317 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/rate-limiting/
2025-06-02 19:58:55,346 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/rate-limiting/ (Status: 200)
2025-06-02 19:58:55,462 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/rate-limiting/ using selector: 'main'
2025-06-02 19:58:55,511 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/rate-limiting/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites_rate-limiting.txt
2025-06-02 19:58:56,016 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/site-protection/
2025-06-02 19:58:56,214 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/site-protection/ (Status: 200)
2025-06-02 19:58:56,273 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/site-protection/ using selector: 'main'
2025-06-02 19:58:56,303 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/site-protection/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites_site-protection.txt
2025-06-02 19:58:56,807 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/traffic-rules/
2025-06-02 19:58:57,020 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/traffic-rules/ (Status: 200)
2025-06-02 19:58:57,114 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/traffic-rules/ using selector: 'main'
2025-06-02 19:58:57,160 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/traffic-rules/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites_traffic-rules.txt
2025-06-02 19:58:57,670 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-access-to-sites/web-application-firewall/
2025-06-02 19:58:57,895 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-access-to-sites/web-application-firewall/ (Status: 200)
2025-06-02 19:58:57,960 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-access-to-sites/web-application-firewall/ using selector: 'main'
2025-06-02 19:58:57,997 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-access-to-sites/web-application-firewall/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-access-to-sites_web-application-firewall.txt
2025-06-02 19:58:58,500 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-netlify-access/
2025-06-02 19:58:58,783 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-netlify-access/ (Status: 200)
2025-06-02 19:58:58,871 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-netlify-access/ using selector: 'main'
2025-06-02 19:58:58,895 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-netlify-access/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-netlify-access.txt
2025-06-02 19:58:59,400 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/secure-netlify-access/enforce-2fa
2025-06-02 19:58:59,862 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/secure-netlify-access/enforce-2fa (Status: 200)
2025-06-02 19:58:59,944 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/secure-netlify-access/enforce-2fa using selector: 'main'
2025-06-02 19:58:59,964 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/secure-netlify-access/enforce-2fa to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_secure-netlify-access_enforce-2fa.txt
2025-06-02 19:59:00,471 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/security/security-scorecard/
2025-06-02 19:59:00,678 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/security/security-scorecard/ (Status: 200)
2025-06-02 19:59:00,756 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/security/security-scorecard/ using selector: 'main'
2025-06-02 19:59:00,790 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/security/security-scorecard/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\security_security-scorecard.txt
2025-06-02 19:59:01,306 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/collaborate-on-deploys/
2025-06-02 19:59:01,567 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/collaborate-on-deploys/ (Status: 200)
2025-06-02 19:59:01,684 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/collaborate-on-deploys/ using selector: 'main'
2025-06-02 19:59:01,724 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/collaborate-on-deploys/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_collaborate-on-deploys.txt
2025-06-02 19:59:02,228 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/create-deploys/
2025-06-02 19:59:02,430 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/create-deploys/ (Status: 200)
2025-06-02 19:59:02,504 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/create-deploys/ using selector: 'main'
2025-06-02 19:59:02,575 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/create-deploys/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_create-deploys.txt
2025-06-02 19:59:03,092 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/deploy-previews/
2025-06-02 19:59:03,135 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/deploy-previews/ (Status: 200)
2025-06-02 19:59:03,214 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/deploy-previews/ using selector: 'main'
2025-06-02 19:59:03,248 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/deploy-previews/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_deploy-previews.txt
2025-06-02 19:59:03,756 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/disable-projects/
2025-06-02 19:59:03,948 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/disable-projects/ (Status: 200)
2025-06-02 19:59:03,993 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/disable-projects/ using selector: 'main'
2025-06-02 19:59:04,011 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/disable-projects/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_disable-projects.txt
2025-06-02 19:59:04,519 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/fix-a-failed-deploy/
2025-06-02 19:59:04,843 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/fix-a-failed-deploy/ (Status: 200)
2025-06-02 19:59:04,890 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/fix-a-failed-deploy/ using selector: 'main'
2025-06-02 19:59:04,912 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/fix-a-failed-deploy/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_fix-a-failed-deploy.txt
2025-06-02 19:59:05,430 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/heads-up-display/
2025-06-02 19:59:05,676 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/heads-up-display/ (Status: 200)
2025-06-02 19:59:05,723 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/heads-up-display/ using selector: 'main'
2025-06-02 19:59:05,745 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/heads-up-display/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_heads-up-display.txt
2025-06-02 19:59:06,247 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/manage-deploys/
2025-06-02 19:59:06,461 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/manage-deploys/ (Status: 200)
2025-06-02 19:59:06,548 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/manage-deploys/ using selector: 'main'
2025-06-02 19:59:06,597 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/manage-deploys/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_manage-deploys.txt
2025-06-02 19:59:07,119 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/netlify-reviewer-quickstart/
2025-06-02 19:59:07,401 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/netlify-reviewer-quickstart/ (Status: 200)
2025-06-02 19:59:07,451 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/netlify-reviewer-quickstart/ using selector: 'main'
2025-06-02 19:59:07,481 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/netlify-reviewer-quickstart/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_netlify-reviewer-quickstart.txt
2025-06-02 19:59:07,983 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/notifications/
2025-06-02 19:59:08,287 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/notifications/ (Status: 200)
2025-06-02 19:59:08,528 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/notifications/ using selector: 'main'
2025-06-02 19:59:08,640 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/notifications/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_notifications.txt
2025-06-02 19:59:09,164 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/overview/
2025-06-02 19:59:09,347 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/overview/ (Status: 200)
2025-06-02 19:59:09,435 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/overview/ using selector: 'main'
2025-06-02 19:59:09,478 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_overview.txt
2025-06-02 19:59:09,988 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/split-testing/
2025-06-02 19:59:10,056 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/split-testing/ (Status: 200)
2025-06-02 19:59:10,129 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/split-testing/ using selector: 'main'
2025-06-02 19:59:10,157 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/split-testing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_split-testing.txt
2025-06-02 19:59:10,668 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer
2025-06-02 19:59:11,066 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer (Status: 200)
2025-06-02 19:59:11,130 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer using selector: 'main'
2025-06-02 19:59:11,159 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_troubleshoot-the-netlify-drawer.txt
2025-06-02 19:59:11,665 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer/
2025-06-02 19:59:11,720 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer/ (Status: 200)
2025-06-02 19:59:11,810 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer/ using selector: 'main'
2025-06-02 19:59:11,835 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\site-deploys_troubleshoot-the-netlify-drawer.txt
2025-06-02 19:59:12,346 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/slack-app/
2025-06-02 19:59:14,909 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/slack-app/ (Status: 200)
2025-06-02 19:59:14,972 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/slack-app/ using selector: 'main'
2025-06-02 19:59:14,999 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/slack-app/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\slack-app.txt
2025-06-02 19:59:15,514 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/terraform-provider/
2025-06-02 19:59:15,811 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/terraform-provider/ (Status: 200)
2025-06-02 19:59:15,847 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/terraform-provider/ using selector: 'main'
2025-06-02 19:59:15,864 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/terraform-provider/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\terraform-provider.txt
2025-06-02 19:59:16,379 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/analytics/
2025-06-02 19:59:16,702 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/analytics/ (Status: 200)
2025-06-02 19:59:16,746 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/analytics/ using selector: 'main'
2025-06-02 19:59:16,766 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/analytics/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_analytics.txt
2025-06-02 19:59:17,279 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/automatic-content-reload/
2025-06-02 19:59:20,221 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/automatic-content-reload/ (Status: 200)
2025-06-02 19:59:20,290 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/automatic-content-reload/ using selector: 'main'
2025-06-02 19:59:20,319 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/automatic-content-reload/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_automatic-content-reload.txt
2025-06-02 19:59:20,829 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/content-driven-development/
2025-06-02 19:59:21,070 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/content-driven-development/ (Status: 200)
2025-06-02 19:59:21,126 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/content-driven-development/ using selector: 'main'
2025-06-02 19:59:21,146 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/content-driven-development/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_content-driven-development.txt
2025-06-02 19:59:21,651 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/how-visual-editor-works/
2025-06-02 19:59:21,983 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/how-visual-editor-works/ (Status: 200)
2025-06-02 19:59:22,046 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/how-visual-editor-works/ using selector: 'main'
2025-06-02 19:59:22,081 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/how-visual-editor-works/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_how-visual-editor-works.txt
2025-06-02 19:59:22,587 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/overview/
2025-06-02 19:59:22,827 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/overview/ (Status: 200)
2025-06-02 19:59:22,944 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/overview/ using selector: 'main'
2025-06-02 19:59:23,366 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_overview.txt
2025-06-02 19:59:23,869 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/reusable-content/
2025-06-02 19:59:24,154 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/reusable-content/ (Status: 200)
2025-06-02 19:59:24,203 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/reusable-content/ using selector: 'main'
2025-06-02 19:59:24,223 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/reusable-content/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_reusable-content.txt
2025-06-02 19:59:24,740 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/structured-content/
2025-06-02 19:59:25,066 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/structured-content/ (Status: 200)
2025-06-02 19:59:25,117 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/structured-content/ using selector: 'main'
2025-06-02 19:59:25,141 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/structured-content/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_structured-content.txt
2025-06-02 19:59:25,642 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/concepts/two-way-content-sync/
2025-06-02 19:59:25,971 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/concepts/two-way-content-sync/ (Status: 200)
2025-06-02 19:59:26,072 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/concepts/two-way-content-sync/ using selector: 'main'
2025-06-02 19:59:26,125 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/concepts/two-way-content-sync/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_concepts_two-way-content-sync.txt
2025-06-02 19:59:26,634 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/content-presets/
2025-06-02 19:59:26,860 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/content-presets/ (Status: 200)
2025-06-02 19:59:26,937 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/content-presets/ using selector: 'main'
2025-06-02 19:59:26,964 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/content-presets/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_content-presets.txt
2025-06-02 19:59:27,471 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/content-sources/overview
2025-06-02 19:59:27,596 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/content-sources/overview (Status: 200)
2025-06-02 19:59:27,680 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/content-sources/overview using selector: 'main'
2025-06-02 19:59:27,723 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/content-sources/overview to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_content-sources_overview.txt
2025-06-02 19:59:28,232 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/content-sources/overview/
2025-06-02 19:59:28,276 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/content-sources/overview/ (Status: 200)
2025-06-02 19:59:28,372 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/content-sources/overview/ using selector: 'main'
2025-06-02 19:59:28,411 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/content-sources/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_content-sources_overview.txt
2025-06-02 19:59:28,941 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/custom-actions/
2025-06-02 19:59:29,154 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/custom-actions/ (Status: 200)
2025-06-02 19:59:29,379 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/custom-actions/ using selector: 'main'
2025-06-02 19:59:29,452 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/custom-actions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_custom-actions.txt
2025-06-02 19:59:29,955 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/document-hooks/
2025-06-02 19:59:30,288 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/document-hooks/ (Status: 200)
2025-06-02 19:59:30,401 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/document-hooks/ using selector: 'main'
2025-06-02 19:59:30,466 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/document-hooks/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_document-hooks.txt
2025-06-02 19:59:30,975 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/editorial-permissions/
2025-06-02 19:59:31,329 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/editorial-permissions/ (Status: 200)
2025-06-02 19:59:31,402 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/editorial-permissions/ using selector: 'main'
2025-06-02 19:59:31,439 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/editorial-permissions/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_editorial-permissions.txt
2025-06-02 19:59:31,949 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/frameworks/overview/
2025-06-02 19:59:32,258 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/frameworks/overview/ (Status: 200)
2025-06-02 19:59:32,316 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/frameworks/overview/ using selector: 'main'
2025-06-02 19:59:32,348 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/frameworks/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_frameworks_overview.txt
2025-06-02 19:59:32,862 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/get-started/get-started-overview/
2025-06-02 19:59:32,894 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/get-started/get-started-overview/ (Status: 200)
2025-06-02 19:59:32,947 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/get-started/get-started-overview/ using selector: 'main'
2025-06-02 19:59:32,970 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/get-started/get-started-overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_get-started_get-started-overview.txt
2025-06-02 19:59:33,482 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/global-styles/
2025-06-02 19:59:33,676 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/global-styles/ (Status: 200)
2025-06-02 19:59:33,824 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/global-styles/ using selector: 'main'
2025-06-02 19:59:33,866 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/global-styles/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_global-styles.txt
2025-06-02 19:59:34,381 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/local-development/
2025-06-02 19:59:34,498 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/local-development/ (Status: 200)
2025-06-02 19:59:34,573 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/local-development/ using selector: 'main'
2025-06-02 19:59:34,604 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/local-development/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_local-development.txt
2025-06-02 19:59:35,108 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/localization/
2025-06-02 19:59:35,321 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/localization/ (Status: 200)
2025-06-02 19:59:35,401 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/localization/ using selector: 'main'
2025-06-02 19:59:35,456 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/localization/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_localization.txt
2025-06-02 19:59:35,959 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/overview/
2025-06-02 19:59:35,987 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/overview/ (Status: 200)
2025-06-02 19:59:36,034 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/overview/ using selector: 'main'
2025-06-02 19:59:36,056 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/overview/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_overview.txt
2025-06-02 19:59:36,565 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/personalization/
2025-06-02 19:59:36,889 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/personalization/ (Status: 200)
2025-06-02 19:59:36,959 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/personalization/ using selector: 'article'
2025-06-02 19:59:36,964 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/personalization/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_personalization.txt
2025-06-02 19:59:37,478 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/preview-controls/
2025-06-02 19:59:37,796 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/preview-controls/ (Status: 200)
2025-06-02 19:59:37,881 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/preview-controls/ using selector: 'main'
2025-06-02 19:59:37,916 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/preview-controls/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_preview-controls.txt
2025-06-02 19:59:38,433 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/sitemap-navigator/
2025-06-02 19:59:38,653 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/sitemap-navigator/ (Status: 200)
2025-06-02 19:59:38,750 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/sitemap-navigator/ using selector: 'main'
2025-06-02 19:59:38,787 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/sitemap-navigator/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_sitemap-navigator.txt
2025-06-02 19:59:39,299 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/tree-view/
2025-06-02 19:59:39,510 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/tree-view/ (Status: 200)
2025-06-02 19:59:39,632 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/tree-view/ using selector: 'main'
2025-06-02 19:59:39,682 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/tree-view/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_tree-view.txt
2025-06-02 19:59:40,193 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/troubleshoot/
2025-06-02 19:59:40,508 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/troubleshoot/ (Status: 200)
2025-06-02 19:59:40,592 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/troubleshoot/ using selector: 'main'
2025-06-02 19:59:40,621 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/troubleshoot/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_troubleshoot.txt
2025-06-02 19:59:41,123 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/version-control/
2025-06-02 19:59:41,424 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/version-control/ (Status: 200)
2025-06-02 19:59:41,562 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/version-control/ using selector: 'main'
2025-06-02 19:59:41,635 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/version-control/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_version-control.txt
2025-06-02 19:59:42,149 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/
2025-06-02 19:59:42,178 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/ (Status: 200)
2025-06-02 19:59:42,251 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/ using selector: 'main'
2025-06-02 19:59:42,274 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing.txt
2025-06-02 19:59:42,782 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/content-editor
2025-06-02 19:59:43,259 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/content-editor (Status: 200)
2025-06-02 19:59:43,330 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/content-editor using selector: 'main'
2025-06-02 19:59:43,360 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/content-editor to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_content-editor.txt
2025-06-02 19:59:43,879 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/content-editor/
2025-06-02 19:59:43,918 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/content-editor/ (Status: 200)
2025-06-02 19:59:43,999 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/content-editor/ using selector: 'main'
2025-06-02 19:59:44,032 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/content-editor/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_content-editor.txt
2025-06-02 19:59:44,542 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/custom-fields
2025-06-02 19:59:45,011 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/custom-fields (Status: 200)
2025-06-02 19:59:45,197 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/custom-fields using selector: 'main'
2025-06-02 19:59:45,283 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/custom-fields to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_custom-fields.txt
2025-06-02 19:59:45,788 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/custom-fields/
2025-06-02 19:59:45,818 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/custom-fields/ (Status: 200)
2025-06-02 19:59:46,072 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/custom-fields/ using selector: 'main'
2025-06-02 19:59:46,162 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/custom-fields/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_custom-fields.txt
2025-06-02 19:59:46,678 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/field-controls
2025-06-02 19:59:47,169 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/field-controls (Status: 200)
2025-06-02 19:59:47,279 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/field-controls using selector: 'main'
2025-06-02 19:59:47,305 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/field-controls to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_field-controls.txt
2025-06-02 19:59:47,817 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/field-controls/
2025-06-02 19:59:47,850 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/field-controls/ (Status: 200)
2025-06-02 19:59:47,916 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/field-controls/ using selector: 'main'
2025-06-02 19:59:47,947 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/field-controls/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_field-controls.txt
2025-06-02 19:59:48,463 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/field-groups
2025-06-02 19:59:48,844 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/field-groups (Status: 200)
2025-06-02 19:59:48,916 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/field-groups using selector: 'main'
2025-06-02 19:59:48,957 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/field-groups to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_field-groups.txt
2025-06-02 19:59:49,473 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/field-groups/
2025-06-02 19:59:49,503 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/field-groups/ (Status: 200)
2025-06-02 19:59:49,559 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/field-groups/ using selector: 'main'
2025-06-02 19:59:49,586 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/field-groups/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_field-groups.txt
2025-06-02 19:59:50,088 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/inline-editor
2025-06-02 19:59:50,599 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/inline-editor (Status: 200)
2025-06-02 19:59:50,809 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/inline-editor using selector: 'main'
2025-06-02 19:59:50,906 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/inline-editor to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_inline-editor.txt
2025-06-02 19:59:51,411 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/inline-editor/
2025-06-02 19:59:51,440 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/inline-editor/ (Status: 200)
2025-06-02 19:59:51,673 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/inline-editor/ using selector: 'main'
2025-06-02 19:59:51,768 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/inline-editor/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_inline-editor.txt
2025-06-02 19:59:52,273 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/page-editor
2025-06-02 19:59:52,732 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/page-editor (Status: 200)
2025-06-02 19:59:52,798 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/page-editor using selector: 'main'
2025-06-02 19:59:52,826 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/page-editor to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_page-editor.txt
2025-06-02 19:59:53,334 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/page-editor/
2025-06-02 19:59:53,378 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/page-editor/ (Status: 200)
2025-06-02 19:59:53,439 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/page-editor/ using selector: 'main'
2025-06-02 19:59:53,488 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/page-editor/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_page-editor.txt
2025-06-02 19:59:53,991 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons
2025-06-02 19:59:54,350 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons (Status: 200)
2025-06-02 19:59:54,419 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons using selector: 'main'
2025-06-02 19:59:54,465 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_sidebar-buttons.txt
2025-06-02 19:59:54,972 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons/
2025-06-02 19:59:55,000 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons/ (Status: 200)
2025-06-02 19:59:55,072 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons/ using selector: 'main'
2025-06-02 19:59:55,102 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_sidebar-buttons.txt
2025-06-02 19:59:55,607 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/status-labels
2025-06-02 19:59:56,084 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/status-labels (Status: 200)
2025-06-02 19:59:56,136 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/status-labels using selector: 'main'
2025-06-02 19:59:56,161 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/status-labels to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_status-labels.txt
2025-06-02 19:59:56,664 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/visual-editor/visual-editing/status-labels/
2025-06-02 19:59:56,713 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/visual-editor/visual-editing/status-labels/ (Status: 200)
2025-06-02 19:59:56,785 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/visual-editor/visual-editing/status-labels/ using selector: 'main'
2025-06-02 19:59:56,807 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/visual-editor/visual-editing/status-labels/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\visual-editor_visual-editing_status-labels.txt
2025-06-02 19:59:57,317 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/welcome/add-new-project/
2025-06-02 19:59:57,345 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/welcome/add-new-project/ (Status: 200)
2025-06-02 19:59:57,392 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/welcome/add-new-project/ using selector: 'article'
2025-06-02 19:59:57,394 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/welcome/add-new-project/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\welcome_add-new-project.txt
2025-06-02 19:59:57,902 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/welcome/command-palette/
2025-06-02 19:59:58,217 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/welcome/command-palette/ (Status: 200)
2025-06-02 19:59:58,287 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/welcome/command-palette/ using selector: 'main'
2025-06-02 19:59:58,322 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/welcome/command-palette/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\welcome_command-palette.txt
2025-06-02 19:59:58,840 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/welcome/get-help/ask-netlify/
2025-06-02 19:59:58,868 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/welcome/get-help/ask-netlify/ (Status: 200)
2025-06-02 19:59:58,937 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/welcome/get-help/ask-netlify/ using selector: 'main'
2025-06-02 19:59:58,955 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/welcome/get-help/ask-netlify/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\welcome_get-help_ask-netlify.txt
2025-06-02 19:59:59,470 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/welcome/get-help/resources-and-tips
2025-06-02 19:59:59,529 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/welcome/get-help/resources-and-tips (Status: 200)
2025-06-02 19:59:59,586 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/welcome/get-help/resources-and-tips using selector: 'article'
2025-06-02 19:59:59,598 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/welcome/get-help/resources-and-tips to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\welcome_get-help_resources-and-tips.txt
2025-06-02 20:00:00,123 - INFO - [Beautiful_soup_text.py:194] - Scraping content from: https://docs.netlify.com/welcome/get-help/resources-and-tips/
2025-06-02 20:00:00,153 - DEBUG - [Beautiful_soup_text.py:199] - Successfully retrieved URL: https://docs.netlify.com/welcome/get-help/resources-and-tips/ (Status: 200)
2025-06-02 20:00:00,214 - DEBUG - [Beautiful_soup_text.py:210] - Content found for https://docs.netlify.com/welcome/get-help/resources-and-tips/ using selector: 'article'
2025-06-02 20:00:00,218 - INFO - [Beautiful_soup_text.py:234] - Saved content from https://docs.netlify.com/welcome/get-help/resources-and-tips/ to Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14\welcome_get-help_resources-and-tips.txt
2025-06-02 20:00:00,219 - INFO - [Beautiful_soup_text.py:327] - Scraping for https://docs.netlify.com/ completed. 241 page(s) saved in 'Web_Scrapes\docs.netlify.com_2025-06-02_19-56-14'.

###End of file##

-------- security_content-security-policy.txt --------
Start of file
URL: https://docs.netlify.com/security/content-security-policy/
Scraped_At: 2025-06-02T19:58:51.243298

Contact
Forums
Contact support
Protect your site against user data breaches and cross-site scripting (XSS) attacks by controlling which scripts, content, and other resources can fetch or execute requests on your site.
A
Content Security Policy (CSP)
instructs the browser to restrict network requests to a set of trusted domains that your site specifies.
A CSP should be considered by any organization that cares about compliance and protecting against security concerns such as:
client-side attacks
exfiltration of customer data
website defacement
When you implement a CSP, you create a custom response header that defines an allowlist. The allowlist contains the accepted domains, content hashes, and/or cryptographic nonces for your site.
To avoid the complexities that come with manually maintaining an allowlist, we recommend using the
Content Security Policy extension
to dynamically generate
nonces
for use with your CSP response headers.
This document outlines how to set up and use a CSP with your site on Netlify. You can also learn more by reading
How I learned to stop worrying and love the Content Security Policy
on the Netlify blog.
#
Add a CSP to your site
To implement a CSP for your site, complete the following steps:
Define a CSP with custom headers
Generate a dynamic nonce
Verify the integrity of your CSP
#
1. Define a CSP with custom headers
Define your CSP by setting
custom headers
. There are two headers in particular that are responsible for CSP:
Content-Security-Policy
: This header instructs the browser to enforce the CSP as defined by this header’s value. Any resource that does not conform to this value will be blocked.
Content-Security-Policy-Report-Only
: This header acts as a dry-run of a CSP. You can test your production traffic against your proposed CSP and safely collect reported violations without actually blocking any resources.
If you’re not sure where to start, we recommend the following from the
Content Security Policy Reference
as a good starter policy for many sites. The policy allows images, scripts, AJAX, form actions, and CSS from the same origin, and does not allow any other resources to load. Include the following in your
_headers
file:
Content-Security-Policy-Report-Only: default-src 'none'; script-src 'self'; connect-src 'self'; img-src 'self'; style-src 'self';base-uri 'self';form-action 'self'
#
2. Generate a dynamic nonce
A unique
nonce
, or a number used once, can supplement the
script-src
directive. Instead of maintaining a static allowlist, you can rely on this dynamic value matching the
nonce
attribute of your
<script>
tags to verify integrity.
You can dynamically generate a unique nonce on every request by using Netlify
Edge Functions
. As a convenience, we’ve packaged this functionality into the
Content Security Policy extension
.
To install and configure the extension:
As a Team Owner, navigate to
Content Security Policy
and install the extension on your team.
Next, go to
Project configuration
>
Build & Deploy
>
Content Security Policy
for the site you want to add a CSP nonce to and select
Enable
.
The page will automatically update to reveal the extension’s configuration fields. Fill in the fields to configure the CSP for your site and then select
Save
.
If you prefer configuration as code, you can use the
@netlify/plugin-csp-nonce
build plugin instead.
#
3. Verify the integrity of your CSP
We recommend you test your CSP with
Google’s CSP Evaluator test site
.
#
Monitor report violations
Netlify’s Content Security Policy extension automatically injects a CSP reporting function into your site if you don’t specify a reporting URL. Once installed, you can review CSP violation reports by navigating to
Logs
>
Functions
for your site and accessing the
__csp-violations
function logs.
For more advanced monitoring, consider using a third-party tool like
ReportURI
or
Datadog
. If you already use an observability tool, it may offer a CSP report integration.
#
More resources
Netlify blog: How I learned to stop worrying and love the Content Security Policy
Content Security Policy extension
@netlify/plugin-csp-nonce
build plugin repository
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_overview.txt --------
Start of file
URL: https://docs.netlify.com/security/overview/
Scraped_At: 2025-06-02T19:58:51.888437

Contact
Forums
Contact support
Netlify can meet the complex security and compliance needs of Enterprises and cross-functional teams with customizable access to production and preview sites, SAML SSO login, SCIM provisioning, role-based access control, Firewall traffic rules, and more.
#
Check your security posture
If you have an Enterprise plan, you can improve your team’s security and reduce your vulnerabilities by reviewing the
Security Scorecard
for your Enterprise team.
You can also check out the
security checklist
for more details on how Netlify can improve your security.
#
Secure access to sites
Customize access control for your sites with a password prompt, login credentials, or based on site visitors’ IP address or location.
Block traffic to your site with
Firewall traffic rules
and set custom rate limits with our
rate limiting rules
.
Learn more about
Secure access to sites
.
#
Secure Netlify access
Secure how people can access your Netlify team, resources, and sensitive information with these security features:
SAML SSO login through an identity provider
SCIM Directory Sync to provision users
Secrets Controller
, which allows you to protect your most sensitive secrets
Role-based access control
Enforce 2FA
Learn more about
Secure access to Netlify
#
Secure by design and at scale
Netlify’s Frontend Cloud has a reduced attack surface, offering security by design.
Netlify also offers these security features to help you stay secure as you scale:
Proactive DDoS monitoring
Content Security Policy
Log Drains
Data encrypted at rest with AES-256 or stronger
Traffic encrypted in transit with TLS 1.2 or greater
Private Connectivity
#
Support against DDoS attacks
Even if a malicious attacker tries to take down your site, our global infrastructure and automated DDoS protection can keep your site available.
Netlify automatically detects distributed denial-of-service (DDoS) attacks and will rate limit and block malicious clients from connecting to sites hosted on our servers.
Our edge network mitigates malicious clients from impacting network performance in several ways, including:
Global load balancing:
routes traffic strategically amongst our many servers. Netlify manages these servers to ensure capacity grows as needed.
Automatic DDoS detection:
automatically identifies anomalous clients that pose a risk to your site’s availability.
Automatic rate limiting & blocking:
mitigates attacks by rate limiting and blocking identified clients from connecting to sites deployed on Netlify and hosted on our servers.
Control traffic to your site
To help you control traffic to your site, you can configure your own traffic rules and block traffic or only allow traffic from specific geographic locations or IP addresses. Learn more about
Firewall Traffic Rules
. This feature may be helpful for certain DDoS attacks when you have an idea of where the attack is coming from.
You can also monitor site traffic with
Log Drains
.
#
Compliance and Certifications
SOC 2 Type 2 and ISO 27001 reports available
PCI DSS
GDPR and CCPA
For the latest compliance updates and more details, check out our
Netlify trust center
.
#
Add contacts for security incidents
To ensure that Netlify can quickly contact you about potential abuse, fraud, or other security incidents, add at least one email address as an incidents contact. If you have an organization, you can only add a contact in your organization settings.
#
Add a contact for a team
As a Team Owner, go to
Team settings
>
General
>
Primary Contacts
, then select
Edit contacts
.
Add at least one email address as a primary contact for security, abuse, or fraud incidents.
#
Add a contact for an organization
If your team is a part of an organization, you can only add contacts in your organization settings.
As an Organization Owner, select your organization name in the navigation and then select
Organization overview
.
Select your Organization’s
Settings
page, go to
Primary contacts
, then select
Edit contacts
.
Add at least one email address as a primary contact for security, abuse, or fraud incidents. This contact info will appear as read-only in team settings.
#
More security resources
Security checklist
Content Security Policy
Security posts from Netlify blog
Last updated: November 21, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_private-connectivity.txt --------
Start of file
URL: https://docs.netlify.com/security/private-connectivity/
Scraped_At: 2025-06-02T19:58:52.773401

Contact
Forums
Contact support
This feature is available as an add-on to
Enterprise
plans and requires High-Performance Edge or High-Performance Build.
Use Private Connectivity to reduce the risk to your backend environment and improve compliance. With Private Connectivity, your builds and serverless functions will contact your backend from a specific set of IP addresses that you can allowlist.
#
Overview
By default, the IP addresses that the build process and serverless functions use to connect to your systems will fluctuate when we scale up and down to handle variable loads. With Private Connectivity, you can count on the connections coming from a static set of IPs that never change. This is helpful when your backend, CMS, or self-hosted Git needs to be behind a firewall. You can allowlist the Private Connectivity IP addresses so that your builds and functions can contact your systems without opening up your backend to the whole internet.
Keep the following in mind when working with Private Connectivity:
For builds, Private Connectivity is enabled at the team level and immediately applied to all of a team’s sites.
For functions, Private Connectivity is first enabled at the team level and then requires further action at the site level to be applied.
Private Connectivity for functions is available in the following
regions
:
us-east-2 - US East (Ohio)
eu-central-1 - EU (Frankfurt)
eu-west-2 - EU (London)
Local development still uses your local IP address when you test functions with
netlify dev
or
netlify functions:serve
or when you run builds with
netlify build
or
netlify deploy --build
.
Private Connectivity for builds also grants you access to static IP addresses for the Netlify API.
#
Configure Private Connectivity
To get started with Private Connectivity, take the following steps:
Contact your account manager
to enable Private Connectivity for your team. Let them know if you want Private Connectivity for only builds, only functions, or both.
Virtual private cloud for Netlify Functions
For further security, we can configure a custom virtual private cloud (VPC) for Functions. Please
contact your solutions engineer
to get started with a VPC.
Get the IP addresses for your private networks by going to
Team settings
>
General
>
Team details
>
Private Connectivity
.
Update the allowlists for your backend, CMS, or self-hosted Git to allow the Private Connectivity IP addresses.
Function requests can come from multiple IP addresses
If you’re using Private Connectivity for functions, note that the Netlify UI supplies multiple static IP addresses for each region and that you need to allowlist all of the static IP addresses for the region or regions you intend to use.
After Private Connectivity is enabled at the team level, all of the builds for all of your team’s sites will start using the private network automatically. For functions, a few more steps are required.
To make a site’s functions use the private network:
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Functions region
.
Make sure your site’s
Functions region
is set to
us-east-2
,
eu-central-1
, or
eu-west-2
.
Redeploy your site to make Private Connectivity for your functions take effect.
#
Limitations
Private Connectivity for builds does not apply to network requests from Visual Editor. As an alternative solution, if your code is hosted on-premise, Visual Editor App can support it by connecting to it with read-only permissions or by using an isolated and secure container running on Visual Editor’s cloud.
Private Connectivity is not available for Edge Functions.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-access-to-sites.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-access-to-sites/
Scraped_At: 2025-06-02T19:58:53.599397

Contact
Forums
Contact support
Secure access to your sites by requiring login credentials or configuring Advanced Web Security rules or both. Advanced Web Security allows you to control site access and add extra protection against attacks.
Netlify offers automated network-wide protections from DDoS attacks by default to all sites and across all plans.
To further protect your sites, you can do the following:
control site access with a
password or login credentials
for your live production site, just part of your live site, or for preview environments of your site, such as Deploy Previews.
control site access and protect your site against malicious requests with
Advanced Web Security
rules
#
Netlify Advanced Web Security
Netlify Advanced Web Security protects your team’s sites with extra security features designed for enterprise and advanced security needs:
Web Application Firewall (WAF)
:
blocks malicious traffic for a site using a Netlify-managed ruleset that’s based on common known attacks
Firewall Traffic Rules
:
blocks or allows traffic based on custom rules/rulesets for your site or team’s sites
Rate limiting
:
customizable rate limiting rules for your site or team’s sites with custom enforcement actions, such as blocking traffic or rewriting traffic with the
rewrite to path
action
#
Rule precedence
Netlify evaluates and enforces Advanced Web Security rules in this order:
Firewall Traffic Rules
Web Application Firewall (WAF) rules
Rate limiting rules
This rule precedence means that requests evaluated for rate limits have not been blocked yet by Firewall Traffic Rules or WAF rules.
Note that Netlify applies Advanced Web Security rules to a site before other site visitor access features that require a password or login credentials. This means site visitors with a blocked IP address can encounter an error page before they find a password or login prompt on your site.
#
Block malicious actors with Web Application Firewall (WAF)
Quickly protect your site from malicious web requests with our Web Application Firewall (WAF), which blocks web attacks with preset rules.
For example, you can protect a site with the Baseline ruleset, which is managed by Netlify. The Baseline ruleset detects common attacks we’ve found on our network as well as some common attacks documented by the
OWASP Top 10
and the
OWASP Core Ruleset
.
Learn more about our
Web Application Firewall
.
#
Control site access with rate limiting or Firewall traffic rules
Set rate limiting rules to enforce for your sites. Learn more about
rate limiting
.
Set Firewall Traffic Rules to control who can access your site based on their IP address or geographic location. Learn more about
Firewall Traffic Rules
.
#
Require password or login credentials
Customize how site visitors access your entire site, just parts of your site, or just preview environments of your site, such as
Deploy Previews and branch deploys
. Optimize site visitor access for gated content, site administration, protected early access to your site for QA, and more.
The configuration options below allow you to require site visitors to enter a password or other login credentials before they can access your site.
Site Protection
.
Protect your entire site or just preview environments of your site with a password you control or by requiring site visitors to be Netlify team members and log in with their Netlify team credentials. Site Protection settings are built-in to the Netlify UI for quick adjustment. One of the password protection options was previously called site-wide password protection.
Netlify Identity service
.
Allows you to manage and authenticate users on your site or app, without requiring them to be users of Netlify or any other service. Optimized for gated content, site administration, and more.
Git Gateway
.
Connects your site to a Git provider’s API, allowing tools like a CMS to work with content, branches, and pull requests on your users’ behalf. This feature is in
BETA
.
OAuth provider tokens
.
Add authentication to your site using GitHub, GitLab, or Bitbucket and Netlify’s built-in support for OAuth2 integration.
Role-based access control with JWT
.
Customize granular access to your site, or to specific pages using JSON Web Tokens (JWT), custom roles you define, and redirect rules to grant access to those sections.
Basic authentication with custom HTTP headers
.
Configure basic authentication for your site to protect just one or more sections of your site using Netlify’s custom HTTP header support. Unlike the
Site Protection
password options, you can set multiple passwords for your site. Formerly called Selective password protection.
For more help figuring out the best option for your use case, check out the official Support guide
Access control options for your Netlify sites
.
Last updated: July 26, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-access-to-sites_rate-limiting.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-access-to-sites/rate-limiting/
Scraped_At: 2025-06-02T19:58:55.510495

Contact
Forums
Contact support
This feature is available on
Enterprise
plans and requires High-Performance Edge.
Rate limit your sites with highly-customizable rate limiting rules, which you can apply across your team’s sites in rulesets defined in the Netlify UI. You can also define rules in your site’s code for a specific deploy or site.
Rate limiting is a part of
Netlify Advanced Web Security
, which offers extra security features designed for enterprise and advanced security needs.
Note that rate limiting rules are evaluated after
Firewall Traffic Rules
and
Web Application Firewall (WAF)
rules. Learn more about
rule precedence
.
#
Overview
As a Team Owner, you can create rate limiting rules in the following ways:
in rulesets you create in the Netlify UI, which you can then apply to a site’s
published or unpublished deploys
in your site’s code for
redirects
,
functions
and
edge functions
Here are some general guidelines that may help you decide how and when to set up these rules:
Set up rate limiting rules in the Netlify UI to establish rules across all new and existing sites in your team quickly with a team policy and get more help setting up your rulesets. Track ruleset changes in your audit log.
Set up programmatic rate limiting rules in your site’s code to test out rules for a single deploy before merging into your production branch and to track rate limiting rule changes in code. You can add rules in the code for redirects, serverless functions, or edge functions. Note that if a deploy has its own unique rate limiting rules committed in code, these will take precedence over other rate limiting rules created in the Netlify UI. Learn more about
rule evaluation order
.
Learn more about
rate limiting rules set in the UI
and
programmatic rate limiting rules
.
#
Use cases
Mitigate a DDoS attack.
While Netlify offers automatic DDoS detection, rate limiting, and blocking to keep your site reliable, you can now preemptively customize rate limiting rules for your site and apply these rules to all sites in your team by default with a
team policy
. Note that Netlify’s automatic DDoS protection can activate before your own custom limits are triggered.
Protect your backend.
Protect your site’s backend by limiting traffic for all requests to your site instead of just requests from certain IP addresses. This helps your site avoid server crashes and slow response times.
Prevent web scraping.
Limit requests from a single IP address or user agent to preserve content integrity and prevent unauthorized access to sensitive information.
Enforce fair API usage.
Limit the number of API calls that a client can make within a 60 second period to prevent API abuse and keep the API available and high-performing for all.
Reduce bot traffic.
Prioritize requests from real site visitors by limiting requests from bots that can overwhelm the server. This is especially important during times of high traffic, such as for flash sales, promotions, or viral content.
Optimize bandwidth usage.
Limit requests that use up a lot of bandwidth, such as requests to access articles and media files, and requests related to data transfer.
Target a malicious actor.
Limit requests to your site based on the number of requests to a domain from a certain IP address.
#
Examples
For more detailed examples of how to set up a rate limit rule for different use cases, check out our official
Developer Hub guide on safeguarding your sites from abuse
.
#
Set rate limiting rules in UI
Define and manage rate limiting rules in the Netlify UI. To ensure that a ruleset is always applied to your team’s sites, you can set up a team policy in the UI that enforces a ruleset for all new and existing sites.
When you configure rate limit rules in the UI, you can specify what action should occur when a rate limit is triggered:
Block
: this action blocks requests with a standard
429 status code
.
Rewrite to path:
this action rewrites the request path with a new relative path that you specify. For example, you can rewrite requests to your own customized rate limit error page with a relative path such as
/rate_limit_page.html
.
When a Team Owner creates, edits, deletes, or applies a rate limiting ruleset in the Netlify UI, these actions are logged in the
Team audit log
. Rate limit rules are
read-only
for the
Developer
role.
#
Rule conditions defined in the UI
Optimize your rate limiting rules for different use cases with different rule conditions, which define when a rate limit rule is triggered.
You can trigger a rate limit rule when values match or equal one or more of the following:
Connection IP address
Geolocation
Request path
Cookie
HTTP header
Below are some rule condition triggers and examples of the values they accept in the UI.
Rule condition trigger
Supported value format
Examples
Connection IP
IP address of either the user accessing the site or the proxy set up to access the site in
CIDR notation
155.255.355.0/24
Geolocation
Text
Enter a country name, then select a country/subregion
Path
Text or regex
/api/v1/.*
For requests that proxy to an API
Cookie
Text or regex
Set
session_key
to match
.*
value
Will match requests with a
session_key
value, even if the value for that key is empty
HTTP Header
Text or regex
Set
Authorization
Header to match a specific API token value
Bearer ABUSIVE_TOKEN
Can set up a rule that rate limits a specific API token
#
Published and unpublished deploys
Optimize your rate limiting rules for published or unpublished deploys.
A published deploy is the current live deploy at a site’s main URL. Once a different deploy becomes live at the site’s main URL, that deploy becomes the published deploy for that site.
An unpublished deploy can be a Deploy Preview, a branch deploy, or any other deploy not published at your site’s main URL, such as a new production deploy that has not published because you
locked an older published deploy
.
Learn more in our
deploys docs
.
#
Limitations
The rate limiting feature includes these limits:
Each ruleset must have at least 1 rule.
100 rules maximum per ruleset.
A maximum of 2 rate limiting rulesets can be set per site — one for published deploys and one for unpublished deploys. You can apply the same ruleset to both or use two different ones.
#
How request counts are calculated
By default, Netlify calculates requests globally instead of by region. To set a limit for a specific region, you can add rule conditions that specify the geolocation/subregion you want the rule to apply to.
You can specify how you’d like Netlify to count requests for each rule with our
request aggregation options
in the Netlify UI.
When calculating requests, there may be a window of time between when a client passes a limit and when Netlify starts enforcing the limit. This latency is minor and expected to be less than a second. Adding rules to your site won’t impact latency when serving assets.
Given all the variations in traffic patterns, we recommend you try different settings to find what works best for your site and site visitors. Some experimentation is especially helpful when considering how much you want to optimize a site’s rate limiting to enforce a hard limit versus a more approximate limit.
#
Request aggregation options
When creating a rule in the Netlify UI, under
Request aggregation
, you can choose between two different ways to calculate requests:
Per domain (default)
: all site visitors are limited to a shared limit with a specified number of requests per 60 seconds. This option is good for protecting your backend no matter who is visiting your site.
Per domain and IP address:
each site visitor is limited to a specified number of requests per 60 seconds. This option is good for targeting potential bad actors.
#
Request calculation for rate limiting per domain
When you rate limit
by domain
, once the number of requests goes above the limit during specified time period, then we start banning the IPs with the highest rate.
For example, if you set a limit of 300 requests, once the site reaches that limit, we ban the IP address with the highest request rate. We then adjust the currently counted requests with the traffic we’ve just banned, so other lower rate IPs are not affected.
This means you may notice more than 300 requests for that time interval because, by banning those high rate IPs, there’s more request budget for other lower rate IPs. This continues until the request rate is under the defined limit.
So if one IP address is behind most of the traffic, then you may detect a seesaw (repeated up and down) traffic pattern in your web traffic monitoring tools.
When calculating the request count,  Netlify assigns a weight to IP addresses based on the number of requests and how recently the requests were made. This allows Netlify to prioritize rate limiting IP addresses that are currently generating the largest amount of traffic until the desired limit is reached.
#
Example request calculation for set of rules
To explain how we calculate requests, here’s an example of ruleset:
Rule 1: Protect homepage
Rule triggered when requests match path
/index.html
Limit: 10 requests per 60 seconds
Action: Block and return 429 error
Request aggregation: By domain (default)
Rule 2: Limit known API abusers
Rule triggered when requests have the header
Authorization
that equals
Bearer ABUSIVE-TOKEN
.
Limit: 5 requests per 60 seconds
Action: Block and return 429 error
Request aggregation: By domain (default)
If the example ruleset above is applied to your site and your site has requests to path
/index.html
with an
Authorization
header with the same
Bearer ABUSIVE-TOKEN
value from rule 2, then we will count requests for both rules and start applying the first rule that has been triggered, by order of the definition you set in the UI.
If there are 7 requests per 60 seconds, then rule 2 is applied since rule 1’s threshold hasn’t been crossed
If there are 10 requests per 60 seconds, then rule 2 is applied, since rule 1’s threshold hasn’t been crossed (you need 11 requests to cross it)
If there are 20 requests per 60 seconds, then rule 1 is applied, since rule 1’s threshold has been crossed and is defined first. Although, rule 2 is triggered as well with 20 requests, we only apply one action (block with a 429 status code) per request.
#
Manage rulesets in the UI
Rate limiting rules are managed in rulesets, which can be edited and applied to sites. Any changes in a ruleset take effect on all sites where the ruleset applies.
Only Team Owners can create, edit, or delete a ruleset.
A site can have a maximum of two rulesets applied, one for published deploys and one for unpublished deploys.
Learn more in the next sections:
Create a ruleset
Edit a ruleset
Delete a ruleset
#
Create a ruleset
To create a ruleset:
As a Team Owner, go to
Team settings
>
Access & security
>
Rate Limiting
>
Team rulesets
.
Select
Create ruleset
.
Enter your ruleset name and description.
Select
Add a rule
and follow the prompts. You can add up to 100 rules for a ruleset. When you add a rule, you can specify the following:
Rule condition:
defines when the rule is triggered. For an overview of your options, check out the
rule conditions table
.
Limit:
defines the number of requests allowed per 60 seconds.
Request aggregation:
defines how we calculate and apply the limit for your rule. Includes
Per domain (default)
(ideal to protect your site’s backend) or
Per domain and IP address
(ideal to target a potential bad actor).
Action:
defines what happens when the rate limit threshold is crossed. The action is applied for 60 seconds. Currently supports these actions:
Block:
this action blocks access to the site and returns a
429
status code.
Rewrite to path:
this action rewrites the request path with a new relative path that you specify. For example, you can rewrite requests to your own customized rate limit error page with a relative path such as
/rate_limit_page.html
.
Confirm your rule by selecting
Add rule
.
Optionally, repeat steps 4 and 5 to add more rules to your ruleset as needed.
Save your ruleset.
Next, you can make your ruleset the
team policy
or
apply it to an individual site
.
#
Edit a ruleset
To edit a ruleset:
As a Team Owner, go to
Team settings
>
Access & security
>
Rate Limiting
>
Team rulesets
.
From your
Team rulesets
, select the ruleset you want to edit.
Under your ruleset description, choose
Edit ruleset
.
Make your changes and save.
Your ruleset’s updates will take effect in all sites where the ruleset is applied.
#
Delete a ruleset
To delete a ruleset:
As a Team Owner, go to
Team settings
>
Access & security
>
Rate Limiting
>
Team Rulesets
.
From your
Team rulesets
, select the ruleset you want to delete.
Under your ruleset description, choose
Delete ruleset
.
The ruleset will no longer apply to your sites.
#
Apply a ruleset to a site
Only Team Owners can apply a ruleset to a site from the
Site Configuration
page in the Netlify UI.
To apply a ruleset to a site:
For the desired site, go to
Project configuration
>
Access & security
>
Rate limiting
.
Under
Rulesets for [site name]
, select
Manage rulesets
.
Choose a ruleset option to apply to your site’s published deploys and/or unpublished deploys and select
Save
. If you already have a team policy ruleset configured, then you can override the team policy ruleset with a different ruleset.
#
Configure a team policy ruleset in the UI
To rate limit your team’s sites with a default ruleset, configure a team policy for your site’s published deploys and/or unpublished deploys.
The team policy ruleset applies to all new and existing sites in your team. A Team Owner can override the team policy ruleset with a different ruleset for one site at a time.
A maximum of 2 rate limiting rulesets can be set per site — one for published deploys and one for unpublished deploys. You can apply the same ruleset to both or use two different ones.
As a Team Owner, to configure a team policy:
Go to
Team settings
>
Access & security
>
Rate Limiting
>
Team policy rulesets
.
Select
Configure team policy
.
Choose a ruleset option for published deploys and/or unpublished deploys, then save your changes.
#
Set rate limiting rules in code
Set up programmatic rate limiting rules in your site code to do the following:
supplement the rules you enforce through the Netlify UI
manage your rules in code using version control
test out some rules for a single deploy before these rules apply across your site for multiple deploys
You can define programmatic rate limiting rules in your site’s code for
redirects
,
functions
and
edge functions
.
Note that Netlify calculates requests globally instead of by region for programmatic rules, just like Netlify does for rules defined in the Netlify UI.
#
Rule evaluation order
Programmatic rate limiting rules are activated and enforced before any rate limiting rulesets that are defined in the Netlify UI.
Netlify evaluates rate limiting rules in this order:
Edge functions
Serverless functions
Redirects
Rulesets defined in the Netlify UI
#
Define a limit in code
The same general rate limiting calculations apply. Note that a programmatic rate limiting rule can only execute on the path you’ve defined for that rule.
For example, if you set up the following:
a function on path
/function_path
with a rate limit rule
a rewrite rule on path
/rewrite_path
that rewrites to
function_path
Then this is how requests to our CDN will result:
The rate limit rule is applied when there’s a request to
/function_path
The rate limit rule
is not
applied when there's a request to
/rewrite_path
#
Define a limit for a redirect rule
In this example, there’s a redirect rule defined in a
netlify.toml
file:
from
=
"/some-path"
to
=
"/function-path"
status
=
200
[
redirects.rate_limit
]
window_limit
=
50
In this redirect rule example, there is a limit of 50 requests for every 60 seconds.
#
Define a limit for a function
In this example, a programmatic rate limit rule is defined for a function:
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/function-path"
,
ratelimit
:
{
windowLimit
:
100
}
}
;
#
Calculate a limit for a function and redirect rule
If you have programmatic rate limiting rules set up for the
function
and
redirect
examples shared above, then this is the order that Netlify enforces them:
If a request hits our CDN on
/some-path
, the 50 request limit applies
If a request hits our CDN on
/function-path
, the 100 request limit applies
If there’s another function also on
/some-path
, both that function’s limit and the redirect limit apply.
#
Track rules in the build log
You can find programmatic rules definitions for a relevant deploy and any related errors in your build log under
Post-processing
.
Note the following:
An error for a programmatic rule definition cannot make the build fail.
If your build fails for a deploy, then programmatic rules for that deploy will not apply.
#
Redirect examples
Programmatic rate limiting rules for redirects are only supported for redirects defined in
netlify.toml
and not those defined in a
_redirects
file.
In this example, there’s a proxy redirect rule to an external API that you own. You can define a rate limit rule directly within your redirect definition, which will protect your API against unexpected increases in traffic. Here there’s a defined limit of 50 requests per client IP for every window length (each window is 60 seconds).
# use-case: protecting external proxy
[
[
redirects
]
]
from
=
"/search"
to
=
"https://api.mysearch.com"
status
=
200
force
=
true
[
redirects.rate_limit
]
window_limit
=
50
aggregate_by
=
[
"ip"
,
"domain"
]
# optional, will default to "domain" only
# use-case: protecting entire site
[
[
redirects
]
]
from
=
"/*"
to
=
"/:splat"
[
redirects.rate_limit
]
action
=
"rewrite"
# optional, will default to "rate_limit"
to
=
"/custom_rate_limit.html"
# only needed if action is "rewrite"
window_limit
=
50
aggregate_by
=
[
"domain"
]
#
Function & edge function examples
Functions must have a
path
defined in the
config
export of the function, otherwise the custom rate limit will not be evaluated. We do not support rate limiting rules defined in the
netlify.toml
file
.
In these examples, an edge function and serverless function are invoked on the root path of the site. To avoid unexpected overages on compute usage, we define a rate limit of 100 requests per client IP for every window length (each window is 60 seconds). Once a client is limited, it will be blocked and no invocation will occur.
Loading error: Refresh the page to access this code sample
import
type
{
Config
,
Context
}
from
"@netlify/edge-functions"
;
// use-case: safeguarding your edge function usage/spend
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/"
,
rateLimit
:
{
windowLimit
:
100
,
aggregateBy
:
[
"ip"
,
"domain"
]
,
}
}
;
// same use-case
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/"
,
rateLimit
:
{
action
:
"rewrite"
// optional, will default to "rate_limit"
to
:
"/custom_rate_limit.html"
,
// only needed if action is "rewrite"
windowLimit
:
100
,
aggregateBy
:
[
"ip"
,
"domain"
]
,
}
}
;
import
type
{
Config
,
Context
}
from
"@netlify/functions"
// use-case: safeguarding your serverless function usage/spend
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/"
,
rateLimit
:
{
windowLimit
:
100
,
aggregateBy
:
[
"ip"
,
"domain"
]
,
}
}
;
// same use-case
export
default
async
(
request
:
Request
,
context
:
Context
)
=>
{
// ...
}
;
export
const
config
:
Config
=
{
path
:
"/"
,
rateLimit
:
{
action
:
"rewrite"
// optional, will default to "rate_limit"
to
:
"/custom_rate_limit.html"
,
// only needed if action is "rewrite"
windowLimit
:
100
,
aggregateBy
:
[
"ip"
,
"domain"
]
,
}
}
;
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-access-to-sites_site-protection.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-access-to-sites/site-protection/
Scraped_At: 2025-06-02T19:58:56.302508

Contact
Forums
Contact support
Customize how visitors access your site using Site Protection settings available through the Netlify UI.
Basic password protection for your entire site is available on
Pro
plans. All basic password protection and team login protection options are available on
Enterprise
plans.
You can configure protection for all site deploys or only Deploy Previews and branch deploys.
SSO login support for Reviewers
The ability for
Reviewers
to log in to the Netlify app and
collaborate on deploys
using SAML SSO is currently in
beta
and is available on Enterprise
plans
.
#
Site Protection options
You can restrict access to site deploys with these options:
Protect all deploys
:  protect all site deploys, including production deploys, Deploy Previews, and branch deploys.
Protect only non-production deploys
: keep your production deploys open to all visitors and only protect Deploy Previews and branch deploys. Note that protecting only private deploys with Site Protection settings is only available for Enterprise plans.
Learn more about how site deploys are defined in our
site deploys docs
.
Once you decide which deploys you would like to protect, you can choose between
basic password protection and team login protection
. If you choose team login protection, you have the option to
configure SSO
as part of that protection.
#
Who can configure Site Protection
As a Developer, you can change the Site Protection settings for your site at any time in the Netlify UI. Site Protection settings configured for a specific site will override any default Site Protection settings configured for your team.
As a Team Owner, you can configure the default Site Protection settings for all sites on your team. Individual Site Protection settings will take precedence over team settings. If you configure default Site Protection for site deploys on your team, this becomes the baseline protection for all of your sites.
#
Basic password protection versus team login protection
Site Protection allows you to protect your site with basic password protection or team login protection.
If you set up basic password protection for a site deploy, a visitor to your site deploy will find a generic password prompt. They must know and enter a shared password to access the site deploy.
If you set up team login protection for a site deploy, a visitor to your site deploy will find a Netlify team login prompt. They must be a member of your Netlify team and log in using the same credentials they use to access the Netlify app.
Basic password protection
Team login protection
Universal password required to access site deploy
Unique password and username required to access site deploy
Password set by a Developer or Team Owner
Username and password set through your Netlify team login configuration
No SSO support
Supports SSO through an identity provider
Anyone can use your basic password to access a site deploy
Only members of your Netlify team can use your team login to access a site deploy
Invite unlimited Reviewers
to access your site
Note that Git Contributors cannot access your site with team login protection
#
Protect your site with single sign-on (SSO)
To protect your site with SSO protection through an identity provider, you must first set up
Organization SSO
or
Team SSO
.
Next, you need to configure Site Protection with the team login protection option.
You can protect either all site deploys or just Deploy Previews and branch deploys.
If you want to require SSO login for your site, you must configure Organization or Team SSO with the
Only SSO allowed (strict)
option.
SSO auth tokens expire after 1 hour
When a team member uses SSO to log in to your site, the authorization lasts for 1 hour. While this timeout is meant to enhance your security, it can be inconvenient if your use cases involve long sessions.
For this reason, we provide a
Netlify-Site-Protection-Expires-In
response header for sites with SSO protection. That header indicates the number of seconds remaining until the auth token used for the request expires. You can use this information to proactively refresh pages before they start to return a
401
during a long session.
#
Configure default Site Protection for your team
Customize Site Protection for your team with either a
basic password or Netlify team login
. As a Team Owner, you can customize the default Site Protection settings for all sites owned by your team.
Default Site Protection settings apply to all new sites and all existing sites that don’t have their own custom Site Protection settings configured. This allows you to customize Site Protection for a specific site.
#
Protect your sites with a basic password
To set a default Site Protection setting for sites owned by your team:
For your team, go to
Team settings
>
Access & security
>
Visitor access
>
Default Site Protection settings
.
Select
Configure Site Protection
.
To require site visitors to enter a basic password for all new sites and existing sites without custom Site Protection, choose
Basic password protection
. Enter the custom password. You will need to share this password for site visitors to access the impacted site deploys.
Choose the scope of your default Site Protection:
To only protect site deploys that are not on your production branch, such as Deploy Previews and branch deploys, select
Non-production deploys only
.
To protect both production and non-production site deploys, select
All deploys
.
To confirm, select
Save
.
#
Protect your sites with Netlify team login
To set a default Site Protection setting for sites owned by your team:
For your team, go to
Team settings
>
Access & security
>
Visitor access
>
Default Site Protection settings
.
Select
Configure Site Protection
.
To require site visitors to use their Netlify login credentials to access your site, choose
Team login protection
. Visitors must be a member of your Netlify team for this option.
Who counts as a Netlify team member for team login protection?
Team login protection applies to
Developers, Team Owners, and Billing Admins
only. Git Contributors will not be able to log in to your site deploys that are protected with team login protection.
Choose the scope of your default Site Protection:
To only protect site deploys that are not on your production branch, such as Deploy Previews and branch deploys, select
Non-production deploys only
.
To protect both production and non-production site deploys, select
All deploys
.
To confirm, select
Save
.
#
Configure Site Protection for a single site
Customize Site Protection for a specific site’s deploys with either a basic password or Netlify team login.
#
Protect your site with a basic password
Basic password protection allows you to quickly protect your site deploys with a single shared password. When you configure basic password protection for a specific site, all site members can change or remove this password at any time.
All site visitors will be required to enter this password to access a site deploy, including team members who can manage your site deploy’s settings in the Netlify app.
To protect your site with basic password protection:
In the Netlify UI, navigate to your site and go to
Project configuration
>
Access & security
>
Visitor access
>
Site Protection
.
Select
Configure Site Protection.
If a Team Owner has configured default Site Protection settings on your team, then you can choose to keep the default Site Protection settings that are listed in the Netlify UI or you can select
Customize this site’s protection settings
.
To set a password that anyone can use to access your site, choose
Basic password protection
, and enter the required password for all site visitors.
Choose the scope of basic password protection for your site:
To only protect site deploys that are not on your production branch, such as Deploy Previews and branch deploys, select
Non-production deploys only
.
To protect both production and non-production site deploys, select
All deploys
.
To confirm, select
Save
.
#
Protect your site with Netlify team login
Team login protection is ideal for internal sites or for Deploy Previews and branch deploys that should remain private and for internal preview only.
Team login protection for your site allows you to restrict access to only members of your Netlify team. Team members must log in to your site using the same login credentials they use to access the Netlify app.
Once team login protection is configured, only Team Owners, Developers and Billing Admins can access the protected site deploys.
To protect your site with Netlify team login protection:
In the Netlify UI, navigate to your site and go to
Project configuration
>
Access & security
>
Visitor access
>
Site Protection
.
Select
Configure Site Protection.
If a Team Owner has configured default Site Protection settings on your team, then you can choose to keep the default Site Protection settings that are listed in the Netlify UI or you can select
Customize this site’s protection settings
.
To allow team members to access your site with their Netlify team login credentials, choose
Team login protection
.
Who counts as a Netlify team member for team login protection?
Team login protection applies to
Developers, Team Owners, and Billing Admins
only. Git Contributors will not be able to log in to your site deploys that are protected with team login protection.
Choose the scope of team login protection for your site:
To only protect site deploys that are not on your production branch, such as Deploy Previews and branch deploys, select
Non-production deploys only
.
To protect both production and non-production site deploys, select
All deploys
.
To confirm, select
Save
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-access-to-sites_traffic-rules.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-access-to-sites/traffic-rules/
Scraped_At: 2025-06-02T19:58:57.159142

Contact
Forums
Contact support
This feature is available on
Enterprise
plans and requires High-Performance Edge.
Control who can access your site based on their IP address or geographic location with Netlify’s Firewall Traffic Rules.
Rate limiting rules
Instead of completely blocking all traffic, you can set up rate limiting rules. Learn more about
rate limiting
.
Firewall Traffic Rules is a part of
Netlify Advanced Web Security
, which offers extra security features designed for enterprise and advanced security needs.
Note that Firewall Traffic Rules are evaluated before
Web Application Firewall (WAF)
and
Rate limiting
rules. Learn more about
rule precedence
.
#
Overview
As a Team Owner, you can create Firewall Traffic Rules to block or allow site traffic from specific IP addresses, countries, or subregions.
You can block an entire country, or a subregion, such as California or Crimea. Netlify supports subregions defined by the ISO standard. Learn more about
ISO codes for subregions (also called subdivisions)
.
If an IP address is blocked, the site visitor is directed to a Netlify-branded 404 error page. Traffic rules are applied to sites before
site authentication and other visitor access options
.
You can standardize default traffic rules for all sites on your team or customize rules for a specific site. You can also apply distinct rules for
published or unpublished deploys
.
Team Owners
can create and manage traffic rules, while
Developers
can only read traffic rules for sites they have access to.
When a Team Owner creates, updates, or removes a traffic rule, these actions are logged in the
Team audit log
.
#
Published and unpublished deploys
You can optimize traffic rules for published or unpublished deploys.
A published deploy is the current live deploy at a site’s main URL. Once a different deploy becomes live at the site’s main URL, that deploy becomes the published deploy for that site.
An unpublished deploy can be a Deploy Preview, a branch deploy, or any other deploy not published at your main site URL, such as a new production deploy that has not published because you
locked an older published deploy
.
Learn more in our
deploys docs
.
#
Use cases
Traffic rules are optimized for the following use cases:
Meet compliance requirements
by allowing or blocking specific IP addresses, countries, or subregions.
Ensure site access for critical partners
, such as for contractors and site crawlers, by allowing IP exceptions for specific IP addresses.
Reduce site hosting costs and bandwidth usage
by blocking specific IP addresses or geographic locations.
Traffic rule management is optimized for the following use cases:
Standardize default traffic rules for your team
for all new sites on a team and all existing sites that don’t have their own custom site traffic rules.
Secure unpublished deploys
, such as for Deploy Previews and branch deploys, by configuring traffic rules for unpublished deploys.
Manage strict site access for an internal site
by setting traffic rules for your internal site’s published deploys.
#
Traffic rule inheritance
You can
standardize traffic rules for a team’s sites
so that all sites without their own custom rules will automatically inherit the team default rules.
You can also
customize traffic rules for a specific site
or
apply the team default rules to a site that currently has site-specific custom traffic rules
.
#
Configure default traffic rules for sites in your team
As a Team Owner, you can standardize the default traffic rules you want all sites in your team to have.
Team default traffic rules apply to all sites in your team that do not have their own site-specific traffic rules. Custom traffic rules for a site override the default team rules. You can quickly
switch a site’s traffic rules to the team default
anytime.
To configure default traffic rules for your team:
Go to
Team settings
>
Access & security
>
Firewall traffic rules
.
Choose whether to configure traffic rules for your site’s
published or unpublished deploys
. You can add/edit traffic rules for both types of deploys but only one deploy type at a time.
To add traffic rules, under
Published deploys
or
Unpublished deploys
, select
Configure
.
Select a baseline traffic setting to either block or allow all traffic for this deploy type by default.
Common setups
For
Block all traffic
, we recommend you add an IP exception or geographic exception rule to ensure your team’s sites can still be accessed from desired IP addresses or geographic locations.
For
Allow all traffic
, we recommend you add a geographic restriction or IP restriction rule to add some control over site traffic.
Add your traffic rules. For each traffic rule you add, include a custom traffic rule description that Team Owners and Developers can read.
Keep the following in mind as you create your rule set:
If you want to add a subregion, add a relevant country first, then you’ll find a list of subregions associated with that country that are listed by the
ISO subregion codes
.
You can target individual IP addresses or ranges of IP addresses. In both cases, use
CIDR block notation
. For example, a single IPv4 address should end with
/32
, a single IPv6 address should end with
/128
, a range of IPv4 addresses should end with a prefix length between
/0
and
/31
, and a range of IPv6 addresses should end with a prefix length between
/0
and
/127
.
You can add up to 100 traffic rules for published deploys and another 100 traffic rules for unpublished deploys.
If your sites use a proxy, be sure to include your proxy’s IP address ranges in your Netlify traffic rules to ensure they work as expected.
Traffic rules take effect as soon as you save them. Traffic rules apply to existing and future deploys but do not apply to sites on your team with custom site-specific traffic rules.
#
Configure traffic rules for a site
As a Team Owner, you can always customize traffic rules for a specific site. Custom traffic rules for a site always override the team’s default rules.
To configure traffic rules for a specific site:
Go to
Project configuration
>
Access & security
>
Firewall traffic rules
.
If your site has inherited team traffic rules, select
Customize site rules
. The team rules will still be in effect for this site until you save new traffic rules.
Choose whether to configure traffic rules for your site’s
published or unpublished deploys
. You can add/edit traffic rules for both but only one deploy type at a time.
To add traffic rules, under
Published deploys
or
Unpublished deploys
, select
Configure
.
Select a baseline traffic setting to either block or allow all traffic for this deploy type by default.
Common setups
For
Block all traffic
, we recommend you add an IP exception or geographic exception rule to ensure your site can still be accessed from desired IP addresses or geographic locations.
For
Allow all traffic
, we recommend you add a geographic restriction or IP restriction rule to add some control over site traffic.
Add your traffic rules. For each traffic rule you add, include a custom traffic rule description that Team Owners and Developers can read.
Keep the following in mind as you create your rule set:
If you want to add a subregion, add a relevant country first, then you’ll find a list of subregions associated with that country that are listed by the
ISO subregion codes
.
You can target individual IP addresses or ranges of IP addresses. In both cases, use
CIDR block notation
. For example, a single IPv4 address should end with
/32
, a single IPv6 address should end with
/128
, a range of IPv4 addresses should end with a prefix length between
/0
and
/31
, and a range of IPv6 addresses should end with a prefix length between
/0
and
/127
.
You can add up to 100 traffic rules for published deploys and another 100 traffic rules for unpublished deploys.
If your site uses a proxy, be sure to include your proxy’s IP address ranges in your Netlify traffic rules to ensure they work as expected.
Traffic rules take effect as soon as you save them. Traffic rules apply to existing and future deploys for your site.
#
Change custom site rules to team rules
If a Team Owner created custom traffic rules for your site, these rules override any team default traffic rules.
To adopt the team default traffic rules for your site instead, you can quickly switch your custom site traffic rules to team rules. Note that your site rules are not saved after switching to team rules.
To apply team rules to a site with custom rules:
Go to
Project configuration
>
Access & security
>
Firewall traffic rules
.
Select
Apply team rules
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-access-to-sites_web-application-firewall.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-access-to-sites/web-application-firewall/
Scraped_At: 2025-06-02T19:58:57.995412

Contact
Forums
Contact support
This feature is available on
Enterprise
plans and requires High-Performance Edge.
#
Overview
Quickly protect your site from common attacks with our Web Application Firewall (WAF), which uses a ruleset managed by Netlify to block malicious requests.
The WAF feature is one element of
Netlify Advanced Web Security
, along with
Firewall Traffic Rules
and
Rate limiting
. These features are designed to complement each other for a robust solution, with a clear
order of precedence
between these.
Unlike Firewall Traffic Rules or Rate Limiting, the WAF does not require you to manually create rules based on traffic patterns you observe, and extensive customizations are typically not required.
However, we always recommend that you ensure that your security configuration does not prevent legitimate visitors from using your site. You can confirm by observing traffic behavior in detail using
Log Drains
.
#
How WAF works
Before proceeding to
enable protection
and
fine-tune your configuration
, here is what you should know about how the WAF works.
#
The baseline ruleset
Netlify maintains and updates WAF rules as a managed service. The rules included in the baseline ruleset are based on the
OWASP CRS (Core Rule Set)
, which covers the most common attack types included in the
OWASP Top 10
, such as cross-site scripting (XSS), SQL injection attacks, remote code execution (RCE), and more.
The baseline ruleset is a subset of the rules in the full CRS. The ruleset includes rules that are related to common attacks observed on our platform and those that are less likely to block legitimate web requests.
Netlify WAF follows the CRS concepts of configurable
Anomaly Scoring
and
Severity Levels
. This means that requests are not naively blocked on any rule match. Rather, for a request to be blocked, the
anomaly score threshold
must be met for that request. More on this below.
#
Blocking modes
When enabled, WAF supports two modes:
In
Active
mode, requests matching the
anomaly score threshold
are blocked.
In
Passive
mode, no requests are actually blocked, but all information about rule matches is logged. We recommend using this mode the first time you enable WAF, until you have completed tuning your configuration.
#
Rules and actions
Each rule has an ID number, a category, and a severity level that match the same attributes in the OWASP CRS. This means that you can review rule definitions in the
CRS GitHub repository
, if needed.
Each rule has an action associated with it:
Rules set to
Block
are counted towards the anomaly score threshold. If the threshold is met and blocking mode is
Active
, the request will be blocked.
Rules set to
Disable
are not evaluated at all and will not appear in the logs.
Rules set to
Log
do not count towards any score thresholds, but are included in the WAF log output. This lets you continue tracking a rule’s matches until you decide whether it should be set to
Block
or
Disable
.
After you
enable WAF
for a site, you will be able to review the rules list and set actions on the WAF configuration page.
#
Anomaly scoring and score thresholds
Each rule in the baseline ruleset has a severity level set to either
Critical
,
Error
,
Warning
, or
Notice
. These levels, in turn, have a fixed anomaly score:
Severity Level
Anomaly Score
Critical
5
Error
4
Warning
3
Note
2
For each incoming web request, Netlify WAF will complete the following in order:
Evaluate all rules with action
Block
or
Log
.
Collect all matching rules with action
Block
(which is the default action), and sum up the anomaly scores of these rules based on their severity. This sum is the anomaly score of this request.
For example, if a request matches one critical-level rule and two warning-level rules, the anomaly score of that request would be 5 + 3 + 3 = 11.
For a request to be blocked, its anomaly score should be equal or greater than the anomaly score threshold set in your WAF configuration.
By default, that threshold is 5. This means that a request with a single matching rule of level
Critical
will be blocked, while requests with a single rule match of lower severity will not.
If you find that the default threshold is too low or too high for your site, you can adjust the threshold up to 100.
Be mindful when setting high thresholds
Keep in mind that setting the threshold too high may let some malicious requests through.
#
Advanced: category-specific thresholds
In some cases, by
observing the logs
, you will find that rules of a specific category tend to fire too often and trigger blocking. If you do not want to disable these rules, you can add
category-specific thresholds
to adjust the sensitivity for that category.
When category-specific thresholds are in place, a request is blocked if either the general request score threshold is met, or when matching rules in a specific category meet the category-specific threshold.
This enables you to set a high threshold for some categories (meaning, more rules and/or higher-severity rules must match), while having a lower threshold for others.
#
Enable WAF
Enabling and configuring WAF for a site requires you to have a Team Owner role. Users with a
Developer
role on your team only have read-only access to the current WAF configuration.
#
Prerequisite: configure log drains
To successfully configure WAF, you need the ability to observe which rules are matching requests. This requires setting up
Log Drains
.
WAF-related information is included in two log output types. Make sure you enable both:
The
site traffic log
includes high-level data on WAF behavior in the
waf
field.
The
WAF log
provides detailed information on any requests that match one or more rules.
The traffic log is useful for looking at general traffic trends — for example, what portion of requests is blocked or which country or specific IP addresses do these requests originate from. You can use this data to block offending geographic regions or IP addresses using
Firewall Traffic Rules
.
In contrast, the WAF log lets you pinpoint exactly which rules were matched for a request, the details of that match, the accumulated anomaly scores, and more. You can use the WAF log to fine-tune the WAF configuration.
#
Enable the baseline ruleset
To enable the baseline ruleset for a site:
For your site, go to
Project configuration
>
Access & security
>
Web Application Firewall
.
Under
Baseline Ruleset
, select
Configure
.
Select
Enabled
.
We strongly recommend you set
Blocking Mode
to
Passive
first. Then, after you
fine-tune
your configuration, switch to
Active
mode.
To confirm, select
Save
.
#
Fine-tune your configuration
To avoid false positives (that is, requests that are legitimate but end up being blocked), there are a few settings available to you. You can:
Set a rule’s action to only
Log
matches (or disable it completely)
Exclude specific request patterns using text or regular expressions (regex)
Modify anomaly score thresholds
All of these options are available under
Project configuration
>
Access & security
>
Web Application Firewall
after you enable the Baseline ruleset.
#
A typical workflow
Here is a recommended workflow to follow when you set up WAF:
When enabling the baseline ruleset, set
Blocking Mode
to passive. Make sure both log drain output types (traffic log and WAF log) are configured.
Then, start observing logs in the WAF log output.
If a matching rule looks valid, keep it at its default action (
Block
).
If a rule match is consistently a false positive, set it to
Disable
.
If you’re not sure yet about a rule, you can defer your decision until after you’ve enabled
Active
blocking mode, by changing the action to
Log
.
You may find that you want to tweak the request score threshold, so that more rules must match before the threshold is hit. You may also want to exclude some specific paths from the WAF completely. We recommend that you observe traffic logs for a while before and after you make such changes.
When you’re ready to start blocking, switch the blocking mode to
Active
.
If you need to temporarily pause the WAF operation, we recommend that you switch blocking mode back to
Passive
instead of disabling the baseline ruleset altogether because the latter option also clears any configuration changes you’ve made.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-netlify-access.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-netlify-access/
Scraped_At: 2025-06-02T19:58:58.895833

Contact
Forums
Contact support
Ensure only trusted team members can access Netlify by configuring a secure login to Netlify and managing access across your sites and teams.
#
Configure a secure Netlify login
To reduce the risk of security breaches, we recommend you configure single sign-on (SSO) login with an identity provider using either
Team SSO
or
Organization SSO
. We recommend Organization SSO for the most scalable security and SCIM (System for Cross-domain Identity Management) provisioning.
For more robust security, we recommend enforcing SSO by enabling strict SSO in Netlify when you configure team or organization SSO.
#
Manage access control
As a Team Owner, you can limit a Developer’s access to sites within your team. Learn more on managing
site access
.
To securely manage user access at scale, we recommend setting up SCIM Directory Sync through a supported identity provider with Netlify. SCIM Directory Sync allows
Organization
Owners to manage Netlify access for users across multiple Netlify teams and to manage access directly from your identity provider.
Last updated: March 27, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_secure-netlify-access_enforce-2fa.txt --------
Start of file
URL: https://docs.netlify.com/security/secure-netlify-access/enforce-2fa
Scraped_At: 2025-06-02T19:58:59.963082

Contact
Forums
Contact support
Require all team members to authenticate with two-factor authentication (2FA) before they can access your team or organization’s data and resources. Enforce 2FA from within Netlify or your identity provider.
#
Enforce 2FA from an identity provider
For the most robust security, we recommend setting up FIDO2 2FA, especially through an identity provider.
If you have already set up SAML SSO with an identity provider with
Organization SSO
or
Team SSO
, you can set up FIDO2 2FA through your identity provider. Learn more about FIDO2 2FA through your identity provider’s docs or
why we recommend this
.
#
Enforce 2FA within Netlify
As an Owner, you can enforce 2FA and encourage 2FA adoption through Netlify’s enforcement policies for teams with the Pro plan or higher.
When you enforce 2FA within Netlify, people with the following team roles will receive an in-app message telling them they must set up 2FA for their Netlify user ID within user settings:
Developer
Owner
Reviewer
Content Editor
Publisher
Billing Admin
Git Contributors do not have login access to Netlify and so they do not need 2FA setup.
#
Encourage 2FA setup with a warning
To help you rollout 2FA enforcement, we recommend you send all team members a warning that they must set up 2FA soon so they don’t lose access.
This warning doesn’t disrupt any of your team members’ workflows, and you can enable this warning through Netlify’s 2FA enforcement options.
#
Enforce 2FA for an organization
Only Organization Owners can enforce 2FA for an organization. Any 2FA enforcement policy set for an organization applies to all teams in that organization.
To start the 2FA enforcement process for an organization:
If you haven’t already, enable
Netlify 2FA for your Netlify user ID
.
Navigate to your
Organization overview
page
. In the navigation, select the organization name and then select
Organization overview
.
Select
Access & security
. Next, under
Two-factor Authentication
, select
Edit settings
.
Choose a 2FA enforcement policy:
None (default):
no enforcement
Encouraged:
display a banner to members who have not enabled 2FA
Enforced:
restrict access to organization resources for those who have not enabled 2FA
#
Enforce 2FA for a team
Only Team Owners can enforce 2FA for a team. Any 2FA enforcement policies set for an organization will override a specific team’s 2FA enforcement policy.
To start the 2FA enforcement process for a team:
If you haven’t already, enable
Netlify 2FA for your Netlify user ID
.
Go to
Team settings
>
Access
>
Two-factor authentication
and select
Edit settings
.
Choose a 2FA enforcement policy:
None (default):
no enforcement
Encouraged:
display a banner to members who have not enabled 2FA
Enforced:
restrict access to team resources for those who have not enabled 2FA
Last updated: November 21, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- security_security-scorecard.txt --------
Start of file
URL: https://docs.netlify.com/security/security-scorecard/
Scraped_At: 2025-06-02T19:59:00.789959

Contact
Forums
Contact support
This feature is available on
Enterprise
plans.
Improve your team’s security and reduce your vulnerabilities with the Security Scorecard. The scorecard offers actionable insights on using Netlify and applying security best practices.
#
Overview
The Security Scorecard is designed to help you identify risks in your security posture and take action to remediate them. We recommend using the scorecard as an ongoing part of your own security policy.
Team Owners can review an autogenerated scorecard at a team’s
Security Scorecard
tab. To start a new security audit, refresh the browser page.
The Security Scorecard offers recommendations for your team based on these areas:
Authentication
User Management
Site Security
Account Settings
#
Authentication recommendations
Configure secure access to your Netlify team to help protect sensitive information and prevent others from gaining control over your sites.
#
Set up 2FA for Team Owners
We recommend setting up 2FA for all Team Owners to reduce the risk that an adversary gains full administrative control of your team and sites.
You can configure 2FA through an identity provider or within Netlify. Either way, it’s critical that you protect access to your team/organization with 2FA.
#
Most recommended
To remediate this risk with a more robust and longer-term fix,
configure and enforce SSO with an identity provider and Netlify
. After configuring SSO, you have the option to set up 2FA through your identity provider. We recommend FIDO2 2FA for the most robust security.
#
Alternative
Whether or not you have set up SAML SSO, you can enforce 2FA within Netlify.
When you enforce 2FA within Netlify, team members cannot access your team/organization without authenticating through the 2FA authenticator app that they set up for their Netlify user ID. As a fallback method, they can use recovery codes they saved.
Once a team member sets up 2FA for their Netlify user ID, they must always authenticate with 2FA to log in to Netlify.
Before enforcing 2FA, you can encourage Netlify team members to set up 2FA within Netlify with a warning banner that appears at the top of every page in the Netlify UI for team members who haven’t enabled 2FA.
To start the 2FA enforcement process through Netlify:
If you haven’t already, configure
2FA for your Netlify user ID
.
Encourage team members to set up 2FA or enforce 2FA for your team or organization with these
2FA enforcement docs
.
#
Set up 2FA for Developers
We recommend setting up 2FA for all Developers to reduce the risk that an adversary gains access control to your site settings and private site deploys.
You can configure 2FA through an identity provider or within Netlify. Either way, it’s critical that you protect access to your team/organization with 2FA.
#
Most recommended
To remediate this risk with a longer-term fix,
configure and enforce SSO with an identity provider and Netlify
. After configuring SSO, you have the option to set up 2FA through your identity provider. We recommend FIDO2 2FA for the most robust security.
#
Alternative
Whether or not you have set up SAML SSO, you can enforce 2FA within Netlify.
When you enforce 2FA within Netlify, team members cannot access your team/organization without authenticating through the 2FA authenticator app that they set up for their Netlify user ID. As a fallback method, they can use recovery codes they saved.
Once a team member sets up 2FA for their Netlify user ID, they must always authenticate with 2FA to access any other Netlify teams where they are a Developer, Team Owner, or Reviewer.
Before enforcing 2FA, you can encourage Netlify team members to set up 2FA within Netlify with a warning banner that appears at the top of every page in the Netlify UI for team members who haven’t enabled 2FA.
To start the 2FA enforcement process through Netlify:
If you haven’t already, configure
2FA for your Netlify user ID
.
Encourage team members to set up 2FA or enforce 2FA for your team or organization with these
2FA enforcement docs
.
#
Enforce SSO login
We recommend strict enforcement of SSO. Otherwise SSO is simply another authentication option that team members aren’t required to use, offering convenience without security.
Netlify allows you to enforce SSO login through an identity provider with Organization SSO or Team SSO. You can enforce SSO by enabling Strict SSO for your team or organization.
To enforce SSO with an identity provider:
If you haven’t already, consider whether
Organization SSO
, which offers SCIM provisioning and guided setup, is best for your team over
Team SSO
.
To ensure site access, confirm that everyone who needs access to your site or team settings has an account with your identity provider.
Follow these steps to enable strict SSO for
Organization SSO
or
Team SSO
.
#
Set up SSO with an identity provider
We recommend you set up SSO login with an identity provider. This reduces the risk that users log in with insecure authentication methods and compromise your team’s security.
Netlify allows you to set up SSO login through an identity provider using Organization SSO or Team SSO. Organization SSO supports more identity providers, a guided setup, and SCIM provisioning.
To set up SSO with an identity provider:
Check whether your identity provider is supported by
Organization SSO
or
Team SSO
.
Choose whether to use Organization SSO or Team SSO:
For the most scalable security, SCIM provisioning, guided setup, and wider identity provider support, choose Organization SSO.
For basic SSO login for a single team without guided setup or Netlify-integrated SCIM provisioning, choose Team SSO.
Follow the set up steps for either
Organization SSO
or
Team SSO
.
FIDO2 2FA best practice
We recommend you enforce FIDO2 2FA through your identity provider for even greater security. Learn more from your identity provider.
#
User Management recommendations
Apply security best practices to how you manage users and their access to your Netlify team, sites, and sensitive information.
#
Provision users with SCIM Directory Sync
We recommend provisioning users with SCIM Directory Sync to securely manage access control through your identity provider at scale. This reduces the risk that people who have left your company can still control your sites and access sensitive information.
To set up SCIM Directory Sync, you must have a Netlify Organization and also have an Organization Owner role. Learn more about Netlify’s
SCIM Directory Sync
.
#
Reduce Team Owners
We recommend maintaining a maximum of 5 Team Owners per team to ensure you are giving the least privilege needed and applying a security best practice.
To reduce the number of Team Owners on your team:
Navigate to your team’s
Members
page to review Team Owners.
Decide whether it makes sense to demote a Team Owner to a Developer role or remove them from the team completely.
Edit a Team Owner’s role or remove them from the team. There are two different ways to do this depending on whether or not a Team Owner is provisioned through SCIM Directory Sync.
If not provisioned with SCIM:
Navigate to your team’s
Members
page. Next, you can
edit their role
or remove them from the team completely.
If provisioned with SCIM and managed by a Netlify organization:
In your identity provider, deprovision the user or change their user role. To change their user role, move them to a directory group that has a different Netlify role. You can check the Netlify role assigned to directory groups from your
Directory Sync settings
.
#
Remove inactive Team Owners
We recommend removing inactive Team Owners from your team to ensure you’re not giving privileged access to people who should no longer control or access your team and sensitive information.
A Team Owner is considered inactive when they haven’t logged in nor triggered a build in the last 30 days.
#
Remove a Team Owner in Netlify UI
You can remove a Team Owner in the Netlify UI if that user is not provisioned through
SCIM Directory Sync
.
If a user is provisioned through SCIM Directory Sync, the Netlify UI shows that they are
Managed by org
in the
Members list
.
To remove an inactive Team Owner:
Navigate to your team’s
Members
page to review Team Owners.
Choose a relevant Team Owner from the Member list.
Next to your chosen Team Owner, select
Options
, then
Remove from team
.
#
Deprovision a Team Owner in your identity provider
If an inactive Team Owner is currently provisioned through SCIM Directory Sync, you must deprovision the Team Owner in your identity provider.
To deprovision an inactive Team Owner:
Go to your identity provider.
In your identity provider, review users in any directory groups that are assigned the Netlify Team Owner role. You can review the Netlify roles assigned to directory groups in your
Directory Sync settings
on Netlify. For example, you may have a directory group in your identity provider called Team Admins. In Netlify, an Organization Owner can assign the Team Admins directory group to the Team Owner role.
Remove inactive Team Owners from the directory group.
For more details check out your identity provider’s docs.
#
Remove inactive Developers
We recommend removing inactive Developers from your team to ensure you’re not giving access to Developers who should no longer access site deploy management or sensitive information in your team.
A Developer is considered inactive when they haven’t logged in nor triggered a build in the last 30 days.
#
Remove a Developer in Netlify UI
You can remove a Developer in the Netlify UI if that user is not provisioned through
SCIM Directory Sync
.
If a user is provisioned through SCIM Directory Sync, the Netlify UI shows that they are
Managed by org
in the
Members list
.
To remove an inactive Developer:
Navigate to your team’s
Members
page.
Choose a relevant Developer from the Member list.
Next to your chosen Developer, select
Options
, then
Remove from team
.
#
Deprovision a Developer in your identity provider
If an inactive Developer is currently provisioned through SCIM Directory Sync, you must deprovision the Developer from your identity provider.
To deprovision an inactive Developer:
Go to your identity provider.
In your identity provider, review users in the directory groups assigned to the Netlify Developer role. You can review the Netlify roles assigned to directory groups in your
Directory Sync settings
on Netlify. For example, you may have a directory group in your identity provider called Site Maintainers. In Netlify, an Organization Owner can assign the Site Maintainers directory group to the Developer role.
Remove inactive Team Owners from the directory group.
For more details check out your identity provider’s docs.
#
Site Security recommendations
We recommend securing your sites with the following:
Protect unreleased content and intellectual property with Netlify’s built-in Site Protection
Ensure sites with sensitive information are not left inactive
Apply Git repository best practices
#
Set up default Site Protection for your team
To prevent unwanted access to unreleased content and intellectual property, we recommend enabling Site Protection for preview environments of your site, such as for Deploy Previews and any branch deploys.
You can also enable Site Protection for your entire site, which is ideal for internal-only sites.
When you set up default Site Protection for all sites in your team, all sites are protected by default. You can also further customize Site Protection for different sites.
#
Most recommended
For the most robust security, we recommend enabling Team login protection with strict SSO, which requires all site visitors to log in with their Netlify team credentials through your identity provider to access site previews. Learn more about
Team login protection
.
To enable strict SSO, you must first enable
Organization SSO
or
Team SSO
.
To set up Site Protection for your team:
For your team, go to
Team settings
>
Access & security
>
Visitor access
>
Default Site Protection settings
.
Select
Configure Site Protection
.
To require site visitors to use their Netlify login credentials to access your sites, choose
Team login protection
. Site visitors must be a member of your Netlify team to access your sites.
Who counts as a Netlify team member?
Team login protection applies to
Developers, Team Owners, Reviewers, and Billing Admins
only. Git Contributors will not be able to log in to your site deploys that are protected with team login protection. You can invite an unlimited number of people to access your site in a Reviewer role, which gives them  Netlify team login credentials.
Choose the scope of your default Site Protection. This will apply to all new sites and all existing sites with no custom configuration.
To only protect preview versions of your sites, such as Deploy Previews and branch deploys, select
Non-production deploys only
.
To protect entire sites for an internal site experience, select
All deploys
.
To confirm, select
Save
.
These default Site Protection settings apply to all new sites and all existing sites with no custom configuration. Developers can customize protection for a specific site without changing the team default.
#
Alternative
As an alternative to setting up Site Protection for all sites in your team, you can set up Site Protection for just a single site.
Check out the docs for setting up
Site Protection for a single site
.
We still recommend team-configured Site Protection as a default for all new sites and for existing sites that don’t have their own custom Site Protection settings.
#
Delete or update inactive sites
Inactive sites have not had a build in 90 or more days. Inactive sites with environment variables and custom domains are at greater risk of compromising sensitive information.
To avoid this risk, we recommend you delete these sites or start maintaining them by triggering a new build of your site.
#
Maintain an inactive site
If you choose to maintain an inactive site, we recommend you review its purpose and audit its functionality with a new build. You can trigger a new build of your site with the CLI, API, or Netlify UI.
#
Delete an inactive site
As a Team Owner, to delete an inactive site with environment variables:
For the inactive site, go to
Project configuration
>
Danger zone
.
Follow the guided steps to delete your site.
#
Apply Git repository best practices
For the most secure site setup, we recommend you follow these Git repository best practices:
Link your sites to a Git repository, especially sites with access to sensitive information, such as
environment variables
Link a private Git repository for your site whenever possible
If you linked a public Git repository to your site, enable the
sensitive variable policy
to protect sites built from public repos from giving unapproved open source builders access to sensitive variables
Learn more about
linking
or
unlinking
a Git repository.
#
Account Settings recommendations
To ensure the most secure experience and fastest support, we recommend you configure these account settings for your team or organization.
#
Add contacts for security incidents
To ensure that Netlify can quickly contact you about potential abuse, fraud, or other security incidents, add at least one email address as an incidents contact. If you have an organization, you can only add a contact in your organization settings.
#
Add a contact for a team
As a Team Owner, go to
Team settings
>
General
>
Primary Contacts
, then select
Edit contacts
.
Add at least one email address as a primary contact for security, abuse, or fraud incidents.
#
Add a contact to an organization
If your team is a part of an organization, you can only add contacts in your organization settings.
As an Organization Owner, navigate to your
Organization overview
page. In the navigation, select the organization name and then select
Organization overview
.
Select your Organization’s
Settings
page, go to
Primary contacts
, then select
Edit contacts
.
Add at least one email address as a primary contact for security, abuse, or fraud incidents. This contact info will appear as read-only in team settings.
#
More resources
Learn more on security best practices and how Enterprises are using Netlify for better security:
Security blog series
Essential Security and Identity ebook
Security at Netlify
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_collaborate-on-deploys.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/collaborate-on-deploys/
Scraped_At: 2025-06-02T19:59:01.723322

Contact
Forums
Contact support
Optimize feedback cycles across preview environments of your site with the Netlify Drawer, and collect better feedback with richer context that syncs across your project tracking tools.
You can use the Netlify Drawer to maintain an efficient workflow for a cross-functional team:
Give and collect better feedback with annotated screenshots or screen recordings.
From a site preview URL for Deploy Previews or branch deploys, site visitors can take screenshots and add visual or text-based annotations, create screen recordings, and share comments.
Open issues that sync to where your stakeholders work.
Use the Netlify Drawer to open issues that sync with other tracking tools, such as GitHub, GitLab, Jira, Linear, Shortcut, Trello, and more.
Invite unlimited Reviewers.
An unlimited number of cross-functional stakeholders can review Deploy Previews and branch deploys for free when they log in to the Netlify Drawer in the Reviewer role.
Test site performance faster.
Test site functionality while inspecting your deploy or function log from the Netlify Drawer. Use a QR code to check your site’s responsiveness on mobile, and share your browser info with your feedback automatically. Test site functionality in the same browser environment as a different feedback author.
#
Netlify Drawer overview
The Netlify Drawer allows stakeholders visiting your site preview URL to share visual annotations, video, and even appends their browser metadata to their feedback comments or issues for quick reference. With our
BrowserStack integration
, you can test your site feedback in the same browser environment as your site’s Reviewer.
When stakeholders preview your site’s changes at your site preview URL, they can find the Netlify Drawer at the bottom of the window.
Stakeholders can also toggle the Netlify Drawer on or off using the keyboard shortcut
⌘\
on Apple or
^\
on Windows/Linux on any Deploy Preview or branch deploy.
By default, the Netlify Drawer is enabled for
Deploy Previews
, but you need to enable the Netlify Drawer for
branch deploys
specifically. To customize your site’s branch deploys, check out our
branch deploy controls
doc.
The Netlify Drawer enables a wide range of stakeholders to share context-rich feedback on your site and integrates into project tracking tools. You can also invite an unlimited number of people to review your site deploys with the Netlify Reviewer role.
#
Open issues in third-party tracking tools
Stakeholders can also open issues, items, or cards in project tracking tools once they log in to the Netlify Drawer with a free Netlify Reviewer account or as Developer or Team Owner on the team that owns the site.
For example, you can take a screenshot, add annotations, draft an issue with your annotated screenshot in Markdown, and then open this issue in GitHub with some labels or assigned users, all from within the Netlify Drawer.
Any Reviewer or other stakeholder logged into the Netlify Drawer can open an issue, item, or card by selecting
Connect
in the Netlify Drawer to seamlessly connect and appear as the feedback author in your project tracking tools.
The Netlify Drawer integrates with these project tracking tools:
GitHub
GitLab
GitLab self-managed instances
Bitbucket
Jira Software
Jira Server/Data Center
Trello
Azure DevOps
Linear
Shortcut
Reviewers must be approved and log in to Netlify through the Netlify Drawer to use collaboration tools for your site.
#
Site & browser requirements to use Netlify Drawer
For the Netlify Drawer to appear and work properly on your site preview, your site must meet these requirements.
Your site preview URL is a Deploy Preview or branch deploy URL.
Deploy permalinks
, such as
1234abcd12acde000111cdef--yoursitename.netlify.app
, do not support the Netlify Drawer. The Deploy Preview URL must have a
deploy-preview
prefix.
Valid HTML.
Your site must have valid HTML output with opening and closing
body
tags.
Site pages with SSR or ISR require certain response headers.
For site pages with server-side rendering (SSR) or
Incremental Static Regeneration (ISR)
, your function must also set these response headers:
The function generating the page requires
Content-Type
with
text/html
.
If the function response is compressed,
Content-Encoding
is required in the function response. The supported compression algorithms are
brotli
(br) and
gzip
(gzip).
For examples of a server-side rendering site that works with the Netlify Drawer, check out our
official Next.js template repository
.
#
Netlify Drawer limitations
If a site has
active split tests
, the Netlify Drawer won't appear on branch deploys.
#
Git provider support for the Netlify Drawer
For Deploy Previews, feedback is automatically synced to the pull/merge request where the site preview changes are made in the site repository.
The Netlify Drawer supports these Git providers:
Azure DevOps
Bitbucket
GitHub
GitLab
GitLab self-managed instances
If you’re using GitHub and want to open an issue, verify that the Netlify GitHub App is
installed with the necessary permissions
for you to open an issue in GitHub.
#
Configure the Netlify Drawer
By default, the Netlify Drawer is enabled for Deploy Previews, but you need to enable the Netlify Drawer for branch deploys specifically. To customize your site’s branch deploys, check out our
branch deploy controls
doc.
To disable or enable collaboration tools for Deploy Previews or branch deploys:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Collaboration tools
, and select
Configure
.
Choose whether to enable or turn off the Netlify Drawer for Deploy Previews or branch deploys.
To confirm, select
Save
.
#
Configure Deploy Previews for using the Netlify Drawer
To get the most out Deploy Previews with the Netlify Drawer, ensure that you have installed the GitHub Netlify App if you are using GitHub. We recommend giving Netlify access to all repositories, which includes future site repositories your team may create. Learn more about
installing the GitHub Netlify App on existing sites
.
For other suggested setup instructions, check out our
Get started guide for collaborating
.
#
Configure branch deploys for using the Netlify Drawer
First, you must set up branch deploys for your site if you have not already.
To set up branch deploys for your site:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
Choose whether to automatically set up branch deploys for all new branches in your site or for just specific branches. For example, you may decide you want Netlify to automatically set up branch deploy URLs for the branches
staging
and
qa
for ongoing testing or
early-access-docs
for a unique early access preview environment. These branches do not need to exist yet. If they already do, you can push a new commit to activate these settings once they are saved in the UI.
To confirm, select
Save
.
Next, to ensure the Netlify Drawer is enabled for your site’s branch deploys:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Collaboration tools
, and select
Configure
.
To enable collaboration tools for branch deploys, select
branch deploys
.
To confirm, select
Save
.
#
Use the Netlify Drawer to give feedback
These guidelines offer an opinionated flow for maximizing your review. If you are looking for more in-depth debugging guidance, check out our
debug with the Netlify Drawer docs
.
#
1. Review the site deploy and any existing conversation.
The Netlify Drawer on Deploy Previews features a conversation pane where stakeholders can review and add comments that sync to the connected pull/merge request. Branch deploys do not support the conversation pane since there is no synced pull/merge request. The latest commit hash is shown in the Netlify Drawer for branch deploys.
Any comment added using the Netlify Drawer on a Deploy Preview is automatically posted in the corresponding pull/merge request at your Git provider and vice versa, so everyone can work in context.
#
2. Decide where you want share your feedback.
If you are reviewing a Branch deploy, you can only share feedback in an issue, item, or card in a project tracking tool.
For Deploy Previews, you have the option to share your feedback in the Netlify Drawer conversation and have this synced directly on the pull/merge request. Or you can open an issue, item, or card in a project tracking tool.
If opening an issue, you must connect with your desired tool. Learn more in the next step.
#
3. Connect to third-party project tracking tools.
If you have not already connected to issue tracking tools from within the Netlify Drawer, we recommend you do so. If you are reviewing a branch deploy, you must connect to a tool to share any feedback since there is no merge/pull request.
To connect your Netlify user to your account in a third-party tool, select
Integrations
in the Netlify Drawer and choose your tool. You will be prompted to log in to the third-party tool through the Netlify Drawer and grant Netlify access to your account.
#
4. Create your feedback message.
Now you are ready to add your feedback with annotated screenshots or video feedback.
When you annotate a screenshot of your site, you can reduce ambiguity and save review time, especially when stakeholders may not have the same shared language for parts of your site.
You can add this feedback to an issue or to the pull/merge request and Netlify Drawer conversation preview of your pull/merge requests’ comments.
For guidance on reviewing a deploy as a
Reviewer
, check out our
quickstart guide
. We recommend you share this guide with Reviewers you invite.
If your comments appear as authored by the wrong user, check out
how to adjust the comment author
.
Besides recording your screen from the Netlify Drawer or using Loom to record video feedback, you can also drag and drop image and video files directly into the comment area of the Netlify Drawer.
#
Manage access to the Netlify Drawer
As a Team Owner, you can invite an unlimited number of people to give feedback on your site deploys in the official Reviewer Netlify role for free.
You can also share a deploy link with a Developer or add new team members (if you have payment details on your account).
If your site deploys are password-protected or require some other authentication, your stakeholders will need the required password or credentials to access your site preview.
#
Invite a Reviewer
As a Team Owner, you can invite Reviewers through the Netlify Drawer.
The Netlify Reviewer role is free and unlimited so you can invite as many Reviewers as you’d like to collaborate on a preview site URL.
To invite a Reviewer to use the Netlify Drawer for your site deploy:
From the Netlify Drawer, in the left pane, select
Add members
.
Enter the the invitee’s email address. If you are a Team Owner, select the Reviewer role next to this email.
Confirm with
Send invite
.
We recommend you share the
quickstart for reviewers
with your Reviewers to help them optimize their feedback and get guidance on creating a free Reviewer account for themselves.
#
Share a deploy link with a Developer
To give other Developers quick access from the Netlify Drawer, select the share icon to copy your site preview URL, then share this URL.
Developers can then log into the Netlify Drawer, if they are not already logged in.
#
Debug your site with the Netlify Drawer
The Netlify Drawer also offers more context for Team Owners and internal testing teams that are debugging your site preview.
As a Team Owner logged into the Netlify Drawer, you can review your
deploy log or function log
while testing your site’s functionality and quickly access different links for your deploy.
#
Monitor logs
Team Owners can access the deploy log and serverless function logs in the Netlify Drawer to help with monitoring and troubleshooting a specific deploy.
To find details about your deploy from the Netlify Drawer, select
Deploy logs
. For help understanding your deploy log, visit our
deploy log docs
.
To inspect a function and its latest log contents for the current session from the Netlify Drawer, select
Function logs
. For help understanding your function log, visit our
function logs docs
.
#
Check responsiveness and site performance on a mobile device
You can open your site preview on a mobile device to check your site’s performance and test responsiveness. In the Netlify Drawer, select
QR code
, then scan the displayed QR code with a mobile device to open the page.
#
Access browser details and replicate in BrowserStack
When someone shares feedback through the Netlify Drawer, you can access metadata about the browser the comment author used. You can also replicate their browser environment for testing and QA through a built-in integration with
BrowserStack
.
In Netlify Drawer feedback, find the browser information (usually near the bottom of the feedback) and select
Open in BrowserStack
to launch a BrowserStack instance that matches the author of the comment’s browser, browser version, viewport size, and operating system.
The BrowserStack service provides a free 30 minute total usage allotment for users who sign up from Netlify. An option to upgrade is available in BrowserStack once the allotment is finished.
#
Share product feedback on the Netlify Drawer
Your feedback to the Netlify Product team can improve your Netlify Drawer experience and help us prioritize updates.
To share your Netlify Drawer product feedback:
Open the Netlify Drawer and select your name, Netlify avatar, or email address to open your
User settings
.
Enter your product feedback and select
Submit feedback
.
In addition, you can also share your feedback about these docs by scrolling to the bottom of this page.
#
Troubleshoot the Netlify Drawer
For help troubleshooting the Netlify Drawer, check out our
Netlify Drawer troubleshooting docs
.
Last updated: May 13, 2025
←
Deploy Previews
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_create-deploys.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/create-deploys/
Scraped_At: 2025-06-02T19:59:02.574057

Contact
Forums
Contact support
This page covers features and tools you can use to create deploys with or without continuous deployment.
Note
When you create a deploy manually without continuous deployment, Netlify does not run a build command.
#
Deploy with Git
Continuous deployment works by connecting a Git repository to a Netlify site and keeping the two in sync. This is done using the Git provider’s OAuth2 authentication or the Netlify GitHub App.
After you set up
Git provider permissions
and link a repository, Netlify will run your build command and deploy the result whenever you push to your Git repo. The benefits of Netlify’s continuous deployment include:
No deploying without committing and pushing first
Easy collaboration through pull/merge requests
Fix a typo through your Git provider’s web UI from your mobile
Edit content without code by using a CMS
#
Netlify CLI
You can use the CLI to
set up continuous deployment
for a Git repository. Once continuous deployment is configured, you can update your Production site, staging site, or Deploy Preview with
git push
.
You can also use the CLI to
create manual deploys
without continuous deployment. For example, you can deploy directly to your production site from the command line with
netlify deploy --prod
.
#
Drag and drop
You can create a new site by dragging a project folder to the deploy dropzone in
Netlify Drop
or at the bottom of your team’s
Projects
page.
If you need to update a site that you created using drag and drop, update and rebuild your project locally. Then, drag the project’s updated output folder to the deploy dropzone at the bottom of the site’s
Deploys
page. This will start a new site deploy with the updated files.  You can also use this functionality to manually update any site that is not connected to a Git repository.
#
API endpoints
You can use the
API
to create deploys manually using a file digest or a ZIP file.
#
Deploy to Netlify button
The
Deploy to Netlify
button helps users deploy new sites from templates with one single click. Web developers can use the button to give their users a one-click way to deploy those applications on Netlify.
It’s designed to be used in README files, documentation sites, and probably anything that renders as an HTML file.
You can find examples of the button in use in the READMEs on our
templates
.
The template code must be available in a public repository stored on GitHub.com or GitLab.com.
#
Markup
You can use any markup language that renders as HTML to display the button. There are two very important URLs that you’ll need:
The SVG URL for the button:
https://www.netlify.com/img/deploy/button.svg
.
The URL the button takes users to:
https://app.netlify.com/start/deploy
. This link requires the public Git repository as a parameter, for example:
https
:
//
app.netlify.com
/
start
/
deploy
?
repository
=
https://github.com/netlify/netlify-statuskit
You can make the button clone a whole repository or just a
portion of a repository
. Both are good options for monorepos but you may need to
set a base directory
if the button clones the whole repository.
Here is an example of the full Markdown or HTML code for a Deploy to Netlify button that deploys the
Netlify StatusKit template
:
Loading error: Refresh the page to access this code sample
[
![Deploy to Netlify
](
https://www.netlify.com/img/deploy/button.svg
)
](https://app.netlify.com/start/deploy?repository=https://github.com/netlify/netlify-statuskit)
<
a
href
=
"
https://app.netlify.com/start/deploy?repository=https://github.com/netlify/netlify-statuskit
"
>
<
img
src
=
"
https://www.netlify.com/img/deploy/button.svg
"
alt
=
"
Deploy to Netlify
"
>
</
a
>
If your repository uses extensions built with
Netlify's SDK
, you can add the URL parameter
fullConfiguration=true
to make users go through an extra step where they'll be able to install required extensions, choose a site name, and configure their new repository before deploying the site.
#
File-based template configuration
You can control some aspects of template configuration directly in the template’s Git repository.
Create a
netlify.toml
file in the root of the repository, if you don’t have it already. Netlify will read the information from there. If your Deploy to Netlify button
clones just a subdirectory of the repository
, create the
netlify.toml
file in that subdirectory so that the file ends up in the root of the cloned repository. This file can also be used to set options for continuous deployment, you can read more about it in the
file-based configuration documentation
.
Within the
[template]
section of the
netlify.toml
, you can set three directives:
A list of incoming hooks for the users site. This is very useful if you want to allow a third party service to control when to deploy the site. This is what headless CMS services like Contentful and DatoCMS do. Users can give those providers the address Netlify generates for their specific incoming requests.
[
template
]
incoming-hooks
=
[
"Contentful"
]
A list of required environment variables. This is one way to let users set specific configuration options upon deployment. It also enables customization without having to change the code of the base template. If you don’t want to use a
netlify.toml
file, you can instead use the
URL hash
to require or even pre-fill environment variables.
[
template.environment
]
SECRET_TOKEN
=
"change me for your secret token"
CUSTOM_LOGO
=
"set the url to your custom logo here"
The placeholder strings you set in
netlify.toml
are used as labels in the UI to provide guidance to users deploying your template.
A list of required extension slugs.
Extensions
expand the capabilities of a site deployed on Netlify. This is useful if you wish to specify your template depends on specific Netlify extensions to work as expected. If you define
required-extensions
, users will be prompted to install the extensions, to allow them to get up and running faster. This can be combined with the optional parameter
fullConfiguration=true
if you wish to force users to install the extension(s) prior to the first deploy of their site.
[
template
]
required-extensions
=
[
"supabase"
]
Note that you can’t do the following in this
[template]
section:
Set values for environment variables. To pre-fill environment variable values, use
URL-based template configuration
.
Set a base directory for the Deploy to Netlify button. To set a base directory for sites deployed with the button, use the
base
query parameter
instead.
#
URL-based template configuration
You can control the following aspects of how the template repo is cloned and how the resulting site is configured by passing values in the Deploy to Netlify URL:
require or set environment variables
set a base directory
clone a subdirectory
deploy a specific branch
#
Require or set environment variables
You can require or set environment variables for the site template in the hash of the template’s Deploy to Netlify URL with key/value pairs. Values can be null.
https
:
//
app.netlify.com
/
start
/
deploy
?
repository
=
https://github.com/myworkspace/sweetkittentemplate
#
SECRET_TOKEN=specialuniquevalue&CUSTOM_LOGO=
Passing environment variable values in the hash ensures that they’re processed on the client side only. You can create custom Deploy to Netlify buttons for your users with tokens and other secure data, and they won’t appear in Netlify logs.
#
Set a base directory for monorepos
If your Deploy to Netlify button clones a whole monorepo rather than
a single subdirectory
, you can use the
base
query parameter to set an alternate directory as the
base directory
for deployments. The format is
&base=your-base-directory
. Note that while Netlify uses the specified base directory for the build and deploy, the entire repo is still cloned to the user’s Git provider account.
For example, here’s a URL with a base directory of
blog
:
https
:
//
app.netlify.com
/
start
/
deploy
?
repository
=
https://github.com/myworkspace/sweetkittentemplate
&
base
=
blog
When someone uses this Deploy to Netlify button, Netlify clones the whole
sweetkittentemplate
repository to the user’s Git provider account and then builds and deploys from the
blog
subdirectory.
Note the following limitations:
Template configuration
to set incoming hooks and environment variables can only be used at root level and can’t be used for sites with a different base directory. When you set an alternate base directory, the
netlify.toml
in the base directory will take precedence over the root level configuration for that site’s builds.
#
Clone a subdirectory of a repo
To make a Deploy to Netlify button clone just a part of a repo, use the
create_from_path
query parameter to specify a subdirectory to clone. The format is
&create_from_path=your-subdirectory
.
For example, here’s a URL with a creation path of
examples/hello
:
https
:
//
app.netlify.com
/
start
/
deploy
?
repository
=
https://github.com/myworkspace/demos
&
create_from_path
=
examples/hello
When someone uses this Deploy to Netlify button, Netlify clones just the subdirectory
examples/hello
from the
demos
repo to the user’s Git provider account and then builds and deploys from the root of the cloned repository.
#
Deploy a specific branch
To make a Deploy to Netlify button deploy a branch other than the default branch, use the
branch
query parameter. The format is
&branch=your-branch
.
For example, here’s a URL that will deploy the
beta-feature
branch:
https
:
//
app.netlify.com
/
start
/
deploy
?
repository
=
https://github.com/myworkspace/app
&
branch
=
beta-feature
When someone uses this Deploy to Netlify button, Netlify sets the new site’s
production branch
to
beta-feature
and then builds and deploys from that branch of the cloned repository.
#
Define additional instructions
You can define additional configuration instructions in the
USAGE.md
file, which should be saved in the root of your repository. This can be useful to include guidance on setting up any required third-party service accounts (such as databases, content sources, analytics platforms, or APIs) and provisioning those services. Be sure to mention any necessary extensions or tools that need to be pre-installed to ensure a smooth setup.
When a
USAGE.md
file is included in the root of the repository, Netlify's app will prompt users to read the additional instructions included in it during the
fullConfiguration
flow and, after the site has been deployed, in the site overview.
#
Build hooks
Build hooks
give you unique URLs you can use to trigger new builds and deploys.
#
Zapier integrations
Netlify is available on Zapier, where you can connect Netlify with over 1,000 other applications. You can use Zapier “Zaps” to start a new deploy of your site in response to a trigger from another service. You can
find out more on our blog
, or use one of the templates below to get started:
Start deploys of Netlify sites daily
Netlify + Schedule by Zapier
Use this Zap
Start Netlify deploys when you send new Tweets
Netlify + Twitter
Use this Zap
Start Netlify site deploys with the push of a Flic button
Flic + Netlify
Use this Zap
#
n8n integrations
Netlify is available on
n8n
, an open source tool that allows you to connect Netlify with other applications. By using one of n8n’s Netlify nodes, you can create your own automated workflow. To get started, you can use the
Netlify node
,
Netlify Trigger node
, or you can use the existing workflow below:
Deploy site when new content gets added
Netlify node
Use workflow
Last updated: May 13, 2025
←
Overview
Manage deploys
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_deploy-previews.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/deploy-previews/
Scraped_At: 2025-06-02T19:59:03.247798

Contact
Forums
Contact support
Deploy Previews allow you and your team to experience changes to any part of your site without having to publish them to production.
#
Get started
By default, Netlify automatically builds Deploy Previews when you open pull / merge requests in a connected site repository from GitHub, GitLab, Bitbucket, or Azure DevOps.
The base branch must either be a
production branch
, or a branch that has
branch deploys enabled
.
Once the deploy is complete, you can access the Deploy Preview at the unique
Deploy Preview URL
. The Deploy Preview remains available until the deploy is deleted either
automatically
or
manually
.
To change these settings or to control who can access your previews, review the section below on how to
configure Deploy Previews
.
#
Status and notifications
As Netlify starts to generate your Deploy Preview, a Deploy Preview status will appear on your pull / merge request. The status automatically updates to reflect the deploy progression. Once the status is marked as complete, you can access your Deploy Preview at the unique
Deploy Preview URL
.
If you have
deploy notifications
enabled, Netlify will also add a comment to your pull / merge request with a link to the Deploy Preview once it is ready.
#
Configure Deploy Previews
In the Netlify UI, you can choose to disable Deploy Previews for all new pull / merge requests.
To disable or enable Deploy Previews for all new pull / merge requests:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
Choose whether to disable or re-enable Deploy Previews.
To confirm, select
Save
.
If you can’t find this setting, ensure you have enabled continuous deployment for your site by
linking to a Git repository
.
#
Customize landing page for Deploy Preview
To customize the first page that visitors land on when they access your Deploy Preview, you can set the entry path for a Deploy Preview in the Netlify Drawer or in your pull/merge request.
#
Set entry path in Netlify Drawer
To automatically update the Deploy Preview link in the Netlify UI, set the entry path in the
Netlify Drawer
. This updates the link in the
Deploy
page or deploy details page.
To set the entry path:
Open the Netlify Drawer on a Deploy Preview and sign in if you haven’t already.
Go to
Deploy settings
.
Set your entry path and
Save
.
#
Set entry path in pull/merge request
To automatically update the Deploy Preview link in your pull/merge request comment, set the entry path in your merge/pull request opening description.
To set the entry path:
In your pull/merge request, add
@netlify
followed by the relative path to your page.
For example:
@netlify /get-started/
Push a new commit or empty commit to generate the new Deploy Preview link.
To standardize this across many PRs in your site’s repo, you can add this syntax to your PR template:
<!--Set an entry path if your PR has a primary page for review.
    Add a relative path next to `@netlify` below.-->
@netlify /
Note that you can’t customize the Deploy Preview entry path in the Netlify Drawer once you customize it in the pull/merge request.
#
Protect all Deploy Previews with a password
You can control who can access your site’s Deploy Previews by requiring a password to visit your Deploy Preview. Review our
Site Protection docs
to learn more.
#
Set environment variable values for Deploy Previews
You can set different environment
variable values for each deploy context
, including Deploy Previews. This can be helpful if you want to set a different CMS environment to use for production versus Deploy Previews, for example.
To set specific values for the
Deploy Previews
context, create your environment variables with the
Netlify UI, CLI, API
, or a
Netlify Configuration file
.
#
Deploy Preview URLs
Deploy Previews work by deploying pull / merge requests to a unique URL different from the one your production site uses. This URL has the prefix
deploy-preview
followed by the identifier number of the pull request or merge request. For example, a Deploy Preview for pull / merge request #42 will deploy to
deploy-preview-42--yoursitename.netlify.app
.
While the initial deploy for your pull / merge request is pending, this URL will result in a
Not Found
error. For subsequent changes, the web content of the Deploy Preview URL will update as changes are pushed to the pull / merge request and successfully deployed.
You can share this URL with your team to collaborate and
gather feedback
.
Every deploy also has a permalink that starts with the deploy ID number. For example:
1234abcd12acde000111cdef--yoursitename.netlify.app
. The contents of this URL never change, even after you redeploy your site.
Set up automatic deploy subdomains to ensure deploys are accessible
If you use Netlify DNS to manage a custom domain for your site, we recommend that you consider
setting an automatic deploy subdomain
for your Deploy Previews. This ensures that the deploys are not blocked by any third-party scripts or services that require this, such as local internet service providers.
#
Collaborate on Deploy Previews
Using the Netlify Drawer on your Deploy Previews, you and your team can add, review, and manage feedback about site changes right from your site. You can leave comments, take screenshots and video, and test responsiveness on a mobile device.
You can open the Netlify Drawer with the keyboard shortcut
⌘\
on Apple or
^\
on Windows/Linux.
Learn more about using the Netlify Drawer in our docs on
collaborating on deploys
.
For troubleshooting guidance, check out our
troubleshooting docs for using the Netlify Drawer
.
Collaborate on deploys
Troubleshoot the Netlify Drawer
Last updated: May 13, 2025
←
Fix a failed deploy
Collaborate on deploys
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_disable-projects.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/disable-projects/
Scraped_At: 2025-06-02T19:59:04.011435

Contact
Forums
Contact support
Netlify allows you to disable your projects to take them offline while keeping your existing configuration. This is also an effective way to stop consuming resources like build minutes, functions or bandwidth.
Note that you cannot disable a project if the project is a public extension as this would break other projects using that extension.
#
Disable a project
As an
Owner
, to disable a project:
Go to
Project configuration
>
General
>
Danger zone
and select
Disable project
.
#
Enable a project
You can enable a project at any time.
As an
Owner
, to enable a project:
Go to
Project configuration
>
General
>
Danger zone
and select
Enable project
.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_fix-a-failed-deploy.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/fix-a-failed-deploy/
Scraped_At: 2025-06-02T19:59:04.912916

Contact
Forums
Contact support
Netlify’s AI capabilities help diagnose and suggest solutions for deploy failures or build errors so you can get back to shipping code.
#
How these solution suggestions work
When a deployment failure happens, your team will find a
Why did it fail?
button on the failed deploy summary page. This button always appears on failed deploys unless an Owner has disabled the feature for your team.
If this feature is enabled for your team and you select the
Why did it fail?
button, the details about the failure are processed by Netlify’s AI systems to generate guidance for how to resolve the issue.
We’re continuously improving the feature to suggest accurate solutions but your team should review them for accuracy.
#
Security for solution suggestions
This feature does not use the information processed to train models or store data outside of Netlify’s systems.
The deploy failure details used to generate suggestions includes:
a subsection of the build log entries in your deploy log at or around the place where the error returns.
other metadata, such as the name of your site’s framework to provide more accurate results.
Like all Netlify features, usage of this capability is subject to our service agreements referenced in the
Terms of Use
.
#
Enable solution suggestions
These AI capabilities are only available if they have been enabled for your team. Once enabled, any Developer or Owner on your team can use this AI capability to generate solutions for resolving deploy failures on all sites they have access to in your team.
Who can turn this feature on or off:
Owners can enable or disable this feature for their team.
Developers can enable this feature for their team unless an Owner has disabled this feature for the team. The
Why did it fail?
button appears to Developers and Owners unless the feature is disabled.
If a Developer selects the
Why did it fail?
button and the feature is not enabled or disabled for the team, then a prompt appears to enable this feature for the team. Until this feature is enabled on the team, selecting this button will not process the deploy failure details or generate suggestions.
As an Owner, to enable deploy failure solution suggestions:
For your team, go to
Team settings
>
General
>
AI enablement
Select
Configure
.
Choose
Enabled
.
#
Disable solution suggestions
Once disabled, the
Why did it fail?
button will not appear on any of your team’s sites. Only an Owner can enable deploy diagnostics for all sites in your team after the feature is disabled.
As an Owner, to disable deploy failure solution suggestions:
For your team, go to
Team settings
>
General
>
AI enablement
Select
Configure
.
Choose
Disabled
.
#
More troubleshooting help
Verified Support Guide on using the log to debug your build process
Build troubleshooting tips
Last updated: July 12, 2024
←
Manage deploys
Deploy Previews
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_heads-up-display.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/heads-up-display/
Scraped_At: 2025-06-02T19:59:05.744181

Contact
Forums
Contact support
This feature is in
Beta
.
Enable informational UI on your production site — for your teammates only — to show at-a-glance stats and helpful links.
#
Overview
The Heads-up Display (HUD) provides your teammates at-a-glance information about the published deploy, and offers quick entry points back into the Netlify product suite.
#
Use cases
Links in the Heads-up display allow your teammates to do the following quickly:
edit content quickly with deep links to a specific page to edit in Visual Editor Studio
change site settings
understand what changes were last published and when with a link to the commit of the last published deploy in your Git provider (version control provider)
What your Netlify teammates can do from the HUD on your production site depends on their:
Netlify role
access to Visual Editor Studio
access to your Git provider (version control provider)
#
Visibility
By default, the Heads-up Display is not enabled.
Any Developer or Team Owner can enable the Heads-up Display for the last published deploy of a production site.
Once the HUD is enabled, your teammates can find the HUD on your production site when they open the HUD special link. The HUD special link contains a query parameter that tells Netlify to inject a lightweight script that renders the HUD, and saves a cookie so that the HUD remains visible without the query parameter needing to be present.
Teammates can toggle the Heads-up Display on or off using the keyboard shortcut
⌘\
on Apple or
^\
on Windows/Linux.
Note that the Heads-up Display is different and separate from the
Netlify Drawer
, which can be available on
Deploy Previews
and branch deploys.
The Netlify Drawer enables a wide range of stakeholders to share context-rich feedback on your site and integrates into project tracking tools. The Netlify Drawer also requires people to log in before they can access it.
In contrast, once the Heads-up Display is enabled for a site, anyone with a special HUD link of the production site can find the Heads-up Display. However, they will not be able to go to your site settings or site editor tools from the HUD unless they are also logged into Netlify.
#
Configure the Heads-up Display
By default, the Heads-up Display is turned off.
As a Developer or Team Owner, to enable the Heads-up Display:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Collaboration tools
, and select
Configure
.
Choose whether to enable or turn off the Heads-up Display on production for your Netlify teammates.
To confirm, select
Save
.
Select the clipboard icon button to copy the special URL to your clipboard. Your teammates must visit your production site from this special URL in order to find the HUD.
#
Share product feedback
Your feedback to the Netlify Product team can improve your Heads-up Display experience and help us prioritize updates.
To share your Heads-up Display product feedback, select the plus (+) icon in the HUD, or
follow this link
.
#
Limitations
Pages rendered from a
Netlify Function
(SSR/ISR) currently do not inject the Heads-up Display.
Last updated: May 13, 2025
←
Collaborate on deploys
Split Testing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_manage-deploys.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/manage-deploys/
Scraped_At: 2025-06-02T19:59:06.596586

Contact
Forums
Contact support
Netlify versions all deploys. From the
Deploys
tab for your site in the Netlify UI, you can browse any deploy you’ve ever made and preview it from a unique URL.
#
Find a deploy
As a Developer or Team Owner, you can find deploys using the search or filter options available on the
Deploys
tab.
Use the search field above the deploy list to search by deploy ID or branch name.
Where to find your deploy ID
You can find the deploy ID in the first part of a
deploy permalink
. For example:
1234abcd12acde000111cdef
is the deploy ID of
1234abcd12acde000111cdef--yoursitename.netlify.app
.
You can also filter deploys for your site based on these options:
Time frame
Filter deploys triggered in the
Last hour
,
Last day
,
Last 7 days
, or filter by a
Custom
date and time range.
Deploy context
Deploy status
Successful
Unsuccessful
(includes
Failed
,
Canceled
, or
Skipped
deploys)
Enqueued
for deploys that are in the queue awaiting deployment
Pending review
,
Accepted
, or
Rejected
for deploys triggered by an unrecognized author. Learn more about
deploy requests and permissions
.
#
Rollbacks
If you need to roll back, you can publish one of the previous deploys listed in the UI as the live version of your site in production. Use the
Publish Deploy
button on the detail page of any successful deploy. This doesn’t trigger a new deploy but instead publishes a previous atomic deploy that is still available to you. Rollbacks are instantaneous.
Note
If your Netlify site is connected to a Git repository and has auto publishing turned on, any new Git-triggered production deploys will overwrite the previously rolled back version.
#
Locked deploys
Locked deploys give you the ability of pinning a site to the latest published deploy for the time being. New deploys won’t be published to the main site, although Netlify will still build them and they will be ready for whenever you want to publish them.
#
Lock a published deploy
You can lock a deploy by disabling auto publishing. To disable auto publishing, navigate to your site’s
Deploys
list and select
Lock to stop auto publishing
.
#
Unlock a locked deploy
After a deploy has been locked, you can use
Unlock to start auto publishing
to unlock it from the same
Deploys
list.
#
Event notifications
This feature is available on
Pro
and
Enterprise
plans.
You can get notifications about locked deploys by email, outgoing webhook, or Slack. Netlify can notify you when a deploy is either locked or unlocked.
You can configure these notifications from the notifications section in
Project configuration
>
Notifications
>
Deploy notifications
. Visit the
deploy notifications documentation
to learn more.
#
Cancel a deploy
Sometimes, you may want to cancel a deploy after it has started. To do this, go to the detail page of the deploy in progress and select
Cancel deploy
. You’ll then be prompted to confirm the canceling action. Select
Yes, cancel deploy
to confirm.
If you later want to restart the deploy, you can
deploy from the latest branch commit
.
#
Skip a deploy
Sometimes, you may want to push commits to a branch without triggering a deploy on Netlify.
To avoid generating a Deploy Preview for a pull/merge request, add
[skip ci]
or
[skip netlify]
to the title of the pull/merge request.
To avoid generating a branch or production deploy for a commit pushed directly to a branch, add
[skip ci]
or
[skip netlify]
anywhere in the Git commit message.
To avoid generating a branch or production deploy for multiple commits pushed together, add
[skip ci]
or
[skip netlify]
to the most recent commit, and it will apply to all other commits in the push.
The next commit pushed without one of those messages will trigger a new branch deploy or production deploy, including all changes from the skipped commits as well. To generate a Deploy Preview from a pull/merge request, remove
[skip ci]
or
[skip netlify]
from the title and push a new commit.
To trigger a deploy at will on your production branch, go to your site’s
Deploys
page and select
Trigger deploy
at the top of the deploy list.
To avoid triggering automated deploys of
any
kind, you can
stop builds
for the entire site.
If you would like to continue building your deploys but don’t want them published to your main URL, you can
stop auto publishing
.
#
Retry deploy from latest branch commit
If your build fails or you run into other issues, you can retry your deploy with the latest branch commit. You can also retry your deploy with a cleared cache.
When you retry a deploy, the build triggers from the HEAD of your branch. If the HEAD of the branch differs from the original deploy SHA, Netlify still builds from the HEAD of the branch.
#
Automated cleanup for failed and canceled deploys
By default, Netlify automatically deletes failed and canceled deploys older than 30 days (or 90 days on paid plans) as a part of deploy cleanup and maintenance.
Once deleted, you can expect deploys and their associated builds to disappear from the Netlify UI and API queries.
#
Automatic deploy deletion
By default, Netlify will delete deploys after 30 days (or 90 days on paid plans). This includes deploys triggered by either source control changes, the Netlify UI or CLI, manual uploads, or third-party integrations.
Netlify will not automatically delete:
The deploy currently published to your site (also called the
published deploy
).
The most recent successful production deploy.
The most recent successful branch deploy for a given branch.
Owners and Developers on an Enterprise plan can adjust the default retention period for up to 365 days.
Once a deploy is automatically deleted, you can expect the deploy and its associated builds to disappear from the Netlify UI and API queries. If you visit the deploy permalink for an automatically deleted deploy, a generic 404 page is returned.
The
team audit log
updates with
Deploy retention has changed
when a Developer or Team Owner changes the deploy retention limit for a site.
#
Change the deploy retention limit
This feature is available on
Enterprise
plans.
To adjust a site’s default deploy retention limit, you must be a Team Owner or Developer.
After you change the deploy retention limit for a site and save, all changes take effect instantly. For example, if you set your site’s deploy retention to 30 days and confirm this update, all eligible deploys older than 30 days will delete with no additional warning. Netlify runs deploy deletions daily.
As a Developer or Team Owner, go to
Project configuration
>
Build & Deploy
>
Automatic Deletion
.
Select
Configure
, and use the drop-down to select a new deploy retention limit.
Confirm with
Save setting
.
#
Manual deploy deletion through the Netlify UI
You may want to
delete a deploy
to remove sensitive data, as a part of your team’s security best practices, or to clean up your Netlify deploys list. Deploy deletions are logged in the team audit log as
Deploy deleted
actions.
#
Deploy deletion requirements
To delete a deploy manually in the Netlify UI, you must be a
Developer or Team Owner
.
You cannot delete the deploy that was most recently published to a site’s main URL.
You also cannot delete a deploy that is still in progress. You must either cancel the deploy or wait until the deploy is finished before you can delete it.
#
Deploy deletion considerations
Be aware that deleting a deploy is permanent and does not reduce costs for your Netlify team or help you preserve build minutes. More details on this are below.
Once a deploy is deleted, you cannot access any artifacts associated with the deploy, including URLs, deploy logs, or functions unique to the deploy. The deploy permalink for the deleted deploy will no longer work and will show a generic 404 error message instead.
After you delete a deploy, you may encounter the following:
The deploy context URL may no longer work.
If you delete a deploy and there are no other deploys in the context, the
deploy context
URL will return a generic 404 message.
Your deploy context URL may show changes from a different deploy.
If you delete the most recent deploy to a
deploy context
, then that URL will point to the next most recent deploy in the same context.
Split testing results may be disrupted.
If the deleted deploy is from a branch with split testing configured, your split testing results may be disrupted.
After a deploy is deleted, the deploy’s associated build is removed from the team’s
builds list
on the main
Builds
page. However, the build data from deleted deploys is still included in the aggregated
build minute counts and insights analytics
to help you make an accurate assessment of your team’s build minutes usage.
#
Delete a deploy through the UI
As a Developer or Team Owner, you can delete a single deploy manually through the UI.
To find the deploy you want to delete, go to the
Deploys
page for your site and select the deploy from the deploy list or use the deploy search.
From the deploy details page:
For successful deploys, select
Options > Delete deploy
.
For failed or canceled deploys, select
Delete deploy
.
If the
Delete deploy
option is not available, make sure the deploy meets the
requirements for deploy deletion
.
To confirm, review the deploy deletion warning, then select
Delete
.
#
Download a deploy
From the detail page of any successful deploy, including
Netlify Drop
deploys, you can download individual files or an entire copy of your site.
#
Download an individual file
On the detail page for a successful deploy, scroll down to
Deploy file browser
.
Search for or browse to the file you want to inspect, then select
Download
.
#
Download all deployed files
To generate a ZIP file containing all of your deployed files:
In the deploy detail page header for a successful deploy, select
Download
.
When the ZIP finishes generating, select
Download ready
to download the deploy.
If you’re looking to update a site you deployed manually through the UI, you can download and edit the deployed files locally, and then use the
deploy dropzone
to deploy the update.
#
Configure your deploy environment
You can use environment variables to control the environment your site gets deployed to.
Environment variables created using the
Netlify UI, CLI, or API
are available to
Builds
,
Functions
,
Runtime
and
Post processing
scopes
. This means that you can use them in your
serverless functions
and
edge functions
at execution time,
snippet injection
during post processing, and more.
Note that environment variables created in a
netlify.toml
are not available to the deploy environment.
To learn more about how to set and use environment variables review our
environment variables
docs. For more information on using environment variables with functions during runtime specifically, review
environment variables and functions
.
#
Failed deploy troubleshooting tips
To help you fix failed deploys, Netlify offers AI capabilities that diagnose and suggest solutions for deploy failures and build errors so you can get back to shipping code.
Learn more about Netlify’s AI capabilities to
give solutions for failed deploys
.
For more help troubleshooting failed builds, check out our
Build troubleshooting tips
. If your deploy returns an error, you can also clear your cache and retry the deploy in the Netlify UI or trigger a new deploy.
Last updated: May 13, 2025
←
Create deploys
Fix a failed deploy
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_netlify-reviewer-quickstart.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/netlify-reviewer-quickstart/
Scraped_At: 2025-06-02T19:59:07.481066

Contact
Forums
Contact support
Preview a new or updated site before it’s officially published and share annotated visual or video feedback with your cross-functional release partners. Your feedback flows where your release partners are already working - in issues, popular project tracking tools, and code platforms.
If you are a cross-functional stakeholder who needs to review preview sites or offer QA feedback, the Netlify Reviewer role was designed for you. This role is free, at no cost to you or the team managing your site.
Already signed up and approved as a Netlify Reviewer or Developer?
Are you already signed up and approved as a Netlify Reviewer for the team that shared a deploy link with you? If so, you can skip to
Log in as an approved Reviewer
.
As a Developer, you can check out our docs on
debugging with the Netlify Drawer
.
#
Prerequisites
All you need to start is the site URL of the preview you want to review. If you need one, you can ask a Developer or someone who helps manage your sites on Netlify.
#
Sign up as a Reviewer
From an open deploy link, at the bottom of your browser window, select
Collaborate on this Deploy Preview
or
Collaborate on this branch deploy
.
Password prompt?
If this deploy requires a password or other authentication, contact the person who shared the deploy with you for troubleshooting help.
To set up a free Netlify Reviewer account with the team that owns the site deploy shared with you, select
Create a free account
.
Enter your info and select
Sign up for Netlify for free
. A reviewer account is free to you and the team that builds and manages your site using Netlify.
To verify your email for your new Netlify Reviewer account, go to your email inbox and confirm you got the Netlify invite email. A Developer on the team that manages your site will need to approve your request to join the team as a Netlify Reviewer.
#
Log in as an approved Reviewer
Once you are approved as a Reviewer, you can log in for access to collaboration tools through the Netlify Drawer.
From an open deploy link, at the bottom of your browser window, select
Log in to the Netlify Drawer
.
Enter your Reviewer account credentials.
Now you can access the Netlify Drawer’s collaboration tools.
#
Connect to project tracking tools
Log in to your team's project tracking tool in the Integrations pane to leave feedback from the Netlify Drawer.
The Netlify Drawer supports these project tracking tools:
GitHub
GitLab
Azure DevOps
Linear
Jira
Jira Server/Data Center
Trello
Shortcut
If you want to open issues in supported project tracking tools:
From the Netlify Drawer, go to
Integrations
, then choose the tool you want to connect with. A prompt to log in to the third-party tool will open.
Enter your credentials to log in to the third-party tracking tool. You may also get a prompt to grant Netlify access to this tool.
Once a tool is connected you can open an issue in that tool directly from the Netlify Drawer.
#
Give context-rich visual or video feedback
Using the collaboration tools in the Netlify Drawer, you can take a screenshot of the preview site and annotate it to save review time.
You can also record video feedback using the video icon or with an integration with Loom.
Once you create an annotated screenshot or video recording, you can add more context in a review message.
Finally, you can also drag and drop image and video files directly into the comment area of the Netlify Drawer.
#
Open an issue
To open an issue in a connected project tracking tool, go to
New issue
to begin drafting your feedback message. You can drag and drop image and video files directly into your issue draft.
In this issue draft example, someone is drafting a GitHub issue with a screenshot featured at the top in Markdown.
#
Give product feedback and improve your experience
Your feedback to the Netlify Product team can improve your Netlify Drawer experience and help us prioritize updates.
To share your Netlify Drawer product feedback:
Open the Netlify Drawer and select your name, Netlify avatar, or email address to open your
User settings
.
Enter your product feedback and select
Submit feedback
.
In addition, you can also share your feedback about these docs by scrolling to the bottom of this page.
#
Need help?
If you are having access issues, reach out to the person who invited you to review for help.
If you are having other trouble, check out our
docs on troubleshooting the Netlify Drawer
.
You can also share feedback about your experience by scrolling to the bottom of the page and using our docs feedback form.
Last updated: March 27, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_notifications.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/notifications/
Scraped_At: 2025-06-02T19:59:08.638775

Contact
Forums
Contact support
Deploy notifications can inform you or external services about a specific site’s deploy activity.
Netlify supports the following deploy events:
Deploy started:
event emitted when Netlify starts building your site for a new deploy.
Deploy succeeded:
event emitted when Netlify finishes uploading a new deploy to our CDN.
Deploy failed:
event emitted when a deploy does not complete.
Deploy deleted:
event emitted when a deploy is manually
deleted
.
Deploy locked:
event emitted when the site is
locked to a published deploy
, stopping auto publishing.
Deploy unlocked:
event emitted when deploys are unlocked, resuming auto publishing.
Deploy request pending:
event emitted when an
untrusted deploy requires approval
to begin building.
Deploy request accepted:
event emitted when an untrusted deploy request is accepted and can begin building.
Deploy request rejected:
event emitted when an untrusted deploy request is rejected.
Deploy restored:
event emitted when a deploy is manually published (usually for
rollback or rollforward
).
Previously successful deploy failed:
event emitted when a deploy was previously successful but then failed.
Previously failed deploy succeeded:
event emitted when a deploy succeeded after it had failed.
You can enable notifications for deploy events in
Project configuration
>
Notifications
>
Deploy notifications
. Select the type of notification you want to create and add the required configuration.
You can also set up Slack notifications with our Netlify App for Slack.
#
Slack notifications
Send deploy event information to a Slack channel. Learn more in our
Netlify App for Slack docs
.
#
Email notifications
This feature is available on
Pro
and
Enterprise
plans.
This type of notification allows you to send event information to an email address of your choice.
#
HTTP Post Request
This type of notification works as an outgoing webhook and allows you to send event information to an arbitrary URL using a POST request.
The body of the outgoing webhook request will have a JSON representation of the object relevant to the event.
#
Payload signature
If you provide a JWS secret token for an outgoing webhook, Netlify will generate a JSON Web Signature(JWS) and send it along with the notification in the request header
X-Webhook-Signature
.
We include the following fields in the signature’s data section:
iss
: always sent with value
netlify
, identifying the source of the request
sha256
: the hexadecimal representation of the generated payload’s SHA256
You can use any JWT client library to verify this signature in the service receiving the notification. This is an example of an API built with the Sinatra framework that verifies the signature header:
require
"digest"
require
"jwt"
require
"sinatra"
def
signed
(
request
,
body
)
signature
=
request
[
"X-Webhook-Signature"
]
return
unless
signature

  options
=
{
iss
:
"netlify"
,
verify_iss
:
true
,
algorithm
:
"HS256"
}
decoded
=
JWT
.
decode
(
signature
,
"your signature secret"
,
true
,
options
)
## decoded :
## [
##   { sha256: "..." }, # this is the data in the token
##   { alg: "..." } # this is the header in the token
## ]
decoded
.
first
[
:sha256
]
==
Digest
::
SHA256
.
hexdigest
(
body
)
rescue
JWT
::
DecodeError
false
end
post
"/netlify-hook"
do
body
=
request
.
body
.
read
  halt
403
unless
signed
(
request
,
body
)
json
=
JSON
.
parse
(
body
)
# do something with the notification payload here
end
If your project uses Node.js with Express for backend, you need to compare the incoming request data before it’s transformed to JSON:
import
crypto
from
"crypto"
;
import
jwt
from
"jsonwebtoken"
;
import
express
from
"express"
;
const
app
=
express
(
)
;
// parse body and keep the raw contents
app
.
use
(
bodyParser
.
json
(
{
verify
:
(
req
,
res
,
buffer
,
encoding
)
=>
{
req
.
rawBody
=
buffer
;
}
}
)
)
;
app
.
post
(
"/"
,
(
req
,
res
)
=>
{
const
signature
=
req
.
headers
[
'x-webhook-signature'
]
;
const
isValid
=
validateSignature
(
signature
,
req
.
rawBody
)
;
res
.
send
(
isValid
)
;
}
)
;
app
.
listen
(
3000
)
;
const
secret
=
"your signature secret"
;
function
validateSignature
(
token
,
buffer
)
{
const
options
=
{
issuer
:
"netlify"
,
algorithms
:
[
"HS256"
]
}
;
const
decoded
=
jwt
.
verify
(
token
,
secret
,
options
)
;
const
hashedBody
=
crypto
.
createHash
(
"sha256"
)
.
update
(
buffer
)
.
digest
(
"hex"
)
;
return
decoded
.
sha256
===
hashedBody
;
}
#
GitHub commit statuses
This type of notification sets commit status directly in your GitHub pull requests and commit lists. For successful deploys, this will include a link to the Deploy Preview. For failed deploys, this will include a link to the detail page for the deploy where you can examine the deploy log and deploy the latest branch commit.
These notifications are added to all new GitHub-connected Netlify sites by default. You can add, remove, or edit them in
Project configuration
>
Notifications
>
Deploy notifications
.
The settings include a field for a custom message, which will replace the “Deploy preview ready!” message that displays by default.
#
GitHub pull request comments
This type of notification adds a comment to your GitHub pull requests indicating the status of the associated deploy and providing a link to the Deploy Preview when ready. If you append more commits to a pull request, this notification will update the comment to indicate status changes.
GitHub pull request comment notifications are added to all new GitHub-connected Netlify sites by default. You can add, remove, or edit them in
Project configuration
>
Notifications
>
Deploy notifications
.
The settings include a field for a custom message, which will replace the “Deploy preview ready!” message that displays by default.
#
GitHub commit checks
This type of notification adds rich deploy information from your
deploy summary
to your GitHub pull requests and commit lists.
This includes more detailed information in the
Checks
tab of your pull requests on GitHub.
These notifications are added to all new GitHub-connected Netlify sites by default. You can add, remove, or edit them in
Project configuration
>
Notifications
>
Deploy notifications
.
If you don’t find the option for GitHub commit checks in the
Add notification
menu, you will need to configure your site to use the
Netlify GitHub App
.
#
GitLab commit statuses
Personal access token (PAT) required
If your deploy notifications stop working, you may need to add a GitLab PAT to Netlify. Learn more at our
Troubleshoot GitLab notifications docs
.
This type of notification creates commit statuses in your GitLab repositories.
You can configure this notification through the Netlify UI using your GitLab personal access token (PAT). Your PAT must have the
api
scope. Learn more in
GitLab’s PAT docs
. You can add, remove, or edit access in
Project configuration
>
Notifications
>
Deploy notifications
.
#
GitLab merge request comments
Personal access token (PAT) required
If your deploy notifications stop working, you may need to add a GitLab PAT to Netlify. Learn more at our
Troubleshoot GitLab notifications docs
.
This type of notification adds a comment to your GitLab merge requests indicating the status of the associated deploy and providing a link to the Deploy Preview when ready. If you append more commits to a merge request, this notification will update the comment to indicate status changes.
You can configure this notification through the Netlify UI using your GitLab personal access token (PAT). Your PAT must have the
api
scope. Learn more in
GitLab’s PAT docs
. You can add, remove, or edit access in
Project configuration
>
Notifications
>
Deploy notifications
.
#
Troubleshoot GitLab deploy notifications
If you set up your GitLab deploy notifications with a GitLab API access token, you’ll need to edit your notifications settings in the Netlify UI and add a GitLab personal access token (PAT).
GitLab 15.0 no longer supports OAuth tokens without an expiration date and introduced a 2-hour expiration window. Learn more about expiring tokens in
GitLab’s OAuth docs
.
Use Git Gateway or collaborative Deploy Previews?
Your connection to GitLab for these features may also be impacted by the GitLab 15.0 update. Learn more about how to resolve these issues for
Git Gateway
or
collaborative Deploy Previews
.
#
GitLab deploy notifications stop working
If your GitLab deploy notifications stop working, ensure that you are using a GitLab personal access token (PAT) with the right scopes.
On GitLab, generate a new GitLab PAT with the
api
scope. Learn more in
GitLab’s PAT docs
.
On Netlify, add your GitLab PAT for each desired deploy notification at
Project configuration
>
Notifications
>
Deploy notifications
.
#
Bitbucket notifications
Deploy notifications for Bitbucket allow your team to check out the latest deploy status and Deploy Preview from Bitbucket.
#
Bitbucket commit statuses
This type of notification sets commit statuses directly in your Bitbucket branches, pull requests, and commit lists. For successful deploys, this will include a link to the Deploy Preview. For failed deploys, this will include a link to the detail page for the deploy where you can examine the deploy log and deploy the latest branch commit.
#
Bitbucket pull request comments
This type of notification adds a comment to your Bitbucket pull requests with a Deploy Preview link and deploy status. This comment automatically updates with any new commits to your pull request.
#
Azure DevOps notifications
Deploy notifications for Azure DevOps allow your team to check out the latest deploy status and Deploy Preview from Azure DevOps.
#
Azure DevOps commit statuses
This type of notification adds a Netlify Deploy Preview link to the
Commit details page
for successfully deployed commits.
To set up this notification, you must create an
Azure DevOps personal access token (PAT)
with
Code: Read & write
permissions.
Once you have a PAT, configure the notification on Netlify. Go to
Project configuration
>
Notifications
>
Deploy notifications
, select
Azure DevOps commit status
, and add your PAT.
Once configured, you can open a Deploy Preview for a commit with a successful build. To open a Deploy Preview from Azure DevOps, go to the
Commit details page
, and select the
succeeded
build status for the desired commit.
#
Azure DevOps pull request comments
This type of notification adds a comment to your Azure DevOps pull requests with a Deploy Preview link and deploy status. This comment automatically updates with any new commits to your pull request.
To set up this notification, you must create an
Azure DevOps personal access token (PAT)
with
Code: Read & write
permissions.
Once you have a PAT, configure this notification on Netlify. Go to
Project configuration
>
Notifications
>
Deploy notifications
, select
Azure DevOps pull request comment
, and add your PAT.
#
Notifications for monorepos or repositories building multiple apps
For monorepos or setups where one repository builds multiple applications, you can manage the amount of commit status and commit check notifications for sites linked from GitHub or GitLab. This team-level setting works in tandem with deploy notifications configured individually for each site. Check out our
monorepo docs
to learn more.
#
Zapier integrations
Netlify is available on Zapier, where you can connect Netlify with over 1,000 other applications. You can use Zapier “Zaps” to trigger an action in another service on every successful deploy or when a deploy does not complete. You can
find out more on our blog
, or use one of the templates below to get started:
Show new Netlify deployments in Status Hero
Netlify + Status Hero
Use this Zap
Make ServiceNow records from new Netlify deploy failures
Netlify + ServiceNow
Use this Zap
Plant trees with Ecologi when new deploys in Netlify succeed
Ecologi + Netlify
Use this Zap
#
n8n integrations
Netlify is available on
n8n
, an open source tool that allows you to connect Netlify with other applications. By using one of n8n’s Netlify nodes, you can create your own automated workflow. To get started, you can use the
Netlify node
,
Netlify Trigger node
, or you can use the existing workflow below:
Send notification when deployment fails
Netlify Trigger Node
Use workflow
Last updated: May 13, 2025
←
Split Testing
Post processing
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_overview.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/overview/
Scraped_At: 2025-06-02T19:59:09.477847

Contact
Forums
Contact support
Netlify enforces a strict concept of atomic deploys. If you’re used to uploading files with FTP, SSH, RSync or S3’s API, this is quite a different concept.
Instead of pushing individual files to Netlify, you always create a new deploy. Netlify will compare the new deploy with your existing deploy and determine which files have changed and need to be uploaded.
No changes go live on your site’s public URL before all changes have been uploaded. Once all the changes are ready, the new version of the site immediately goes live on the CDN.
This means deploys are atomic, and your site is never in an inconsistent state while you’re uploading a new deploy.
With FTP or S3 uploads, each file is pushed live one after the other, so you can easily get into situations where a new HTML page is live before the supporting assets (images, scripts, CSS) have been uploaded. And if your connection cuts out in the middle of an upload, your site could get stuck in a broken state for a long time.
Atomic deploys guarantee that your site is always consistent.
Files per directory limit
While Netlify doesn’t have a limit on the number of files per deploy, we do have a limit of 54,000 files per directory. If any directory within your publish directory has more than 54,000 files, your deploys will fail.
#
Deploy summary
You can find a deploy summary on the detail page of any successful deploy, right above the
deploy log
. It allows you to quickly identify your deploy status and refer to the details in the log based on different types of information.
This summary indicates how many files have been uploaded to our CDN. It also indicates the status of site
headers
and
redirects
included in the deploy. It also shows you how many
functions
and
edge functions
were deployed.
When you have
branch deploys
enabled, the summary will inform you if the files to upload have already been uploaded by a previous deploy with the same commits. Netlify’s deployment infrastructure knows how to avoid uploading the same file twice, even between different deploys, so we get your changes ready without duplicating content. You can read more about how this works in this article about our
deploying and routing infrastructure
.
If the summary continually indicates that many more files were uploaded than you were expecting, your site may be taking longer to deploy than it needs to. Visit our Forums for a verified Support Guide on
making the most of Netlify’s CDN cache
to learn about why this might be happening and get advice about what you can do to reduce the number of files uploaded each time in order to speed up your deploys.
#
Deploy log
You can find a deploy log on the detail page of every deploy. The log provides content such as:
details about your site’s build image, dependency caching, and Netlify Build process, including all of the standard output which comes from running your build
information about any Build Plugins your site may have installed and their execution
details about the success, failure, or cancellation of the deploy
For any successful deploy, highlights from the deploy log will be included in the
deploy summary
.
#
Fix a failed deploy
To help you fix failed deploys, Netlify offers AI capabilities that diagnose and suggest solutions for deploy failures and build errors so you can get back to shipping code.
Learn more about Netlify’s AI capabilities to
give solutions for failed deploys
.
For additional troubleshooting help, check out our Forums for a verified Support Guide on
using the log to debug your build process
.
Note that Netlify deletes failed and canceled deploys that are 6 months old. Learn more about
automated cleanup for failed deploys
.
#
Share log content
Deploy logs for a site linked to a private repo are available to all site members. For a site linked to a public repo, you can control
deploy log visibility
to determine the privacy level.
To share deploy log content, you can copy the entire log by selecting
Copy to clipboard
(the clipboard icon). You can also generate a shareable URL for a single log line or a range of lines.
For a single log line, select the line number to highlight the line.
For a range of log lines, select the line number for the first log line in the range, then press
shift
and select the final log line number to highlight the full range.
If needed, press
esc
to deselect log lines.
Once you’ve selected a line or range, copy the resulting URL from the address bar of your web browser. The URL syntax should resemble this:
https://app.netlify.com/sites/SITE_NAME/deploys/DEPLOY_ID#L5-L10
#
Branches and deploys
Netlify lets you control which branches in your Git repository you want to deploy.
#
Definitions
The following definitions highlight terms related to site deploys. For definitions regarding build commands, directories, and settings, visit the
build configuration overview
.
Production branch
: the Git branch that Netlify uses to build and deploy changes to your site’s main URL, such as
www.yourcustomdomain.com
or
yoursitename.netlify.app
.
Production deploy
: a deploy from the production branch. If auto publishing is enabled, each new production deploy will become the published deploy.
Published deploy
: the deploy that is currently available as the live version of your site, accessible from your site’s main URL.
Branch deploy
: a deploy generated from a branch that is not your production branch. Branch deploys are published to a URL which includes the branch name and two hyphens (
--
) as a prefix. For example, if a branch is called
staging
, it will deploy to
staging--yoursitename.netlify.app
. If you use Netlify DNS, you can enable branch subdomains, so the
staging
branch example would deploy to
staging.yourcustomdomain.com
. To set up a branch deploy,
learn more
.
Deploy Preview
: a deploy generated from a pull request or merge request, building a preview of the site based on the latest commits. Deploy Previews are published to a URL which has the prefix
deploy-preview
followed by the identifier number of the pull request or merge request and two hyphens (
--
). For example, a Deploy Preview for pull/merge request #42 will deploy to
deploy-preview-42--yoursitename.netlify.app
. For more information, visit the docs on
Deploy Previews
.
Permalink
: every successful deploy of your site also creates a deploy permalink that starts with the deploy ID number and two hyphens (
--
). For example:
1234abcd12acde000111cdef--yoursitename.netlify.app
. The web content at this URL never changes. This is in contrast to production deploys, branch deploys, and Deploy Previews where the web content is updated when you merge or push new commits.
#
Branch deploys versus Deploy Previews
Deploy Previews
Branch deploys
Default setup
Netlify automatically builds Deploy Previews for pull/merge requests unless you change the
Deploy Preview controls
.
Requires
setup in Netlify UI
. Set up branch deploys for only specific branches or for all new branches.
URL
URL generated from a pull/merge request.
Default URL generated from the branch name. Can customize your branch deploy domain with Netlify DNS.
Scope
Preview site changes scoped to a single pull/merge request.
Preview site changes scoped to a branch.
Netlify generates a new branch deploy for every commit to your
branch deploy
branch.  Site visitors can visit your branch deploy at the same stable branch deploy URL.
By default, if a pull/merge request is opened on a branch against a production or branch deploy branch, then Netlify also generates a Deploy Preview.
For example, you can open a pull/merge request on a
branch deploy
branch and find both a Deploy Preview and a branch deploy in your site’s deploy list from this update.
#
Collaboration tools for your site
By default, the Netlify Drawer is enabled for
Deploy Previews
but if you want to use the Netlify Drawer on branch deploys, you must configure this in the
Netlify Drawer settings
.
The Netlify Drawer enables stakeholders to share context-rich feedback about your deploy. This includes image, video, and browser metadata that syncs with your established workflows and project tracking tools.
You can also invite an unlimited number of people to review your site deploys with Netlify’s
Reviewer role
.
Stakeholders can open issues, items, or cards that sync with their preferred project tracking tools. The Netlify Drawer integrates with project tracking tools, such as GitHub, GitLab, GitLab self-hosted instances, Jira Software, Jira Server/Data Center, Azure DevOps, Trello, and more.
Learn more about making your Deploy Previews and branch deploys more collaborative with the Netlify Drawer in our
deploy collaboration docs
.
#
Production branch controls
By default, Netlify deploys your site’s production branch after every merge to the production branch.
If you want to pause publishing your production branch, you can
lock a deploy
and stop auto-publishing to your site’s designated production branch.
To change the production branch name, go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
#
Branch deploy controls
You can set up a branch deploy for a specific branch or for all new branches in your repository through your site configuration.
By default, Netlify will not generate a branch deploy unless a Developer or Owner has set up branch deploys for your site.
Missing collaboration tools on your branch deploy?
If you have an existing branch deploy that does not show the Netlify Drawer, try merging new changes into your branch to generate a refreshed branch deploy. For more help, check our
troubleshooting docs
.
#
Set up a branch deploy for specific branches
To set up a branch deploy for one or more specific branches, such as
staging
or
qa
:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
Select
Let me add individual branches
and enter the name of each branch you want to deploy. You can also enter branch names you haven’t created yet in your repository. To deploy all branches with a specific prefix, add an asterisk to the end of your branch name, e.g.
features/*
.
To confirm, select
Save
.
#
Set up branch deploys for all new branches
To automatically generate branch deploys for every new branch pushed to your remote site repository:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
Next to
Branch deploys
, select
All
. This excludes the designated production branch for your repository.
To confirm, select
Save
.
#
Turn off all branch deploys for your site
To turn off all branch deploys for your site:
Go to
Project configuration
>
Build & deploy
>
Continuous Deployment
>
Branches and deploy contexts
, and select
Configure
.
For
Branch deploys
, select
None
.
To confirm, select
Save
.
#
Protect all branch deploys with a password
You can control who can access your site’s branch deploys by requiring a password. Learn more at our
Site Protection docs
.
#
Deploy Preview controls
Netlify builds Deploy Previews by default for pull requests and merge requests. To learn how to configure Deploy Previews, review the
Deploy Previews docs
.
#
Search engine indexing
Netlify automatically ensures that only your currently published production deploy and most recent branch deploys can be indexed by search engines. Requests to Deploy Previews, unpublished production deploys, and old branch deploys will have an
X-Robots-Tag: noindex
header included in the response. Depending on how you use branch deploys, you may want to prevent even your most recent branch deploys from being indexed by search engines. You can do so by configuring
custom headers
in your branch.
#
Deploy contexts
Deploy contexts give you the flexibility to
configure your site’s builds
depending on the context they are going to be deployed to.
There are five predefined deploy contexts:
production
: this context corresponds to the main site’s deployment, attached to the Git branch you set when the site is created.
deploy-preview
: this context corresponds to the previews we build for pull/merge requests.
branch-deploy
: this context corresponds to deploys from branches that are not the site’s main production branch.
preview-server
: this context corresponds to
Preview Server
environments.
dev
: this context corresponds to local development environments run using
Netlify Dev
.
Besides these predefined contexts, sites can also use branch names as custom deploy contexts. For example, a branch called
staging
will match a deploy context called
staging
.
Deploy contexts allow you to override options from your site’s configuration including the build command, the environment variables added to the build,
Build Plugin configuration
, and more.
Overrides are applied in a hierarchical order. The site’s global settings apply to each deploy, if we’re building the production site, and if you change options in your production context, they will be overridden. Only options that are set explicitly are overridden; if you leave one out, the build will use the value of the global settings or previous contexts. Environment variables are also overridden individually, for example, you can have access tokens as environment variables per context.
To customize settings for each deploy context, create a file called
netlify.toml
in the root of your Git repository. There, you can set as many contexts as you want to configure. For environment variables, you can also set different values for each deploy context using the Netlify
UI, CLI, or API
.
Note that, as the configuration file is stored in your repository, you should be mindful of what sensitive values you include. Where possible, we recommend you set sensitive
environment variables
with the Netlify UI, CLI, or API instead.
# Production context:
# All deploys from the main repository branch
# will inherit these settings. Be mindful
# when using this option and avoid committing
# sensitive values to public source repositories.
[
context.production
]
command
=
"make production"
[
context.production.environment
]
ACCESS_TOKEN
=
"super secret"
# Deploys from main branch run this plugin in the build.
# Plugins context requires double brackets.
[
[
context.production.plugins
]
]
package
=
"@netlify/plugin-sitemap"
# Deploy Preview context:
# All deploys generated from a pull/merge request
# will inherit these settings. Be mindful
# when using this option and avoid committing
# sensitive values to public source repositories.
[
context.deploy-preview.environment
]
ACCESS_TOKEN
=
"not so secret"
# Branch deploy context:
# All deploys that are not from a pull/merge request
# or from the production branch will inherit these settings.
[
context.branch-deploy
]
command
=
"make staging"
# Dev context:
# Environment variables set here are available for local
# development environments run using Netlify Dev. These
# values can be overwritten on branches that have a more
# specific branch context configured.
[
context.dev.environment
]
NODE_ENV
=
"development"
# Specific branch context:
# Deploys from this branch will take these settings
# and override their current ones.
[
context.feature
]
command
=
"make feature"
[
context."features/branch"
]
command
=
"gulp"
File-based configuration settings will override those set in the UI. In the
netlify.toml
file, settings for more specific contexts will override more general ones. For example, settings for a specific branch will override those for branch-deploy.
Visit our docs on
file-based configuration
to learn more about what you can do with deploy contexts.
#
Deploy protection
Netlify gives you the ability to protect your site deploys with the following features:
Firewall Traffic Rules
, which protect your site by applying traffic rules to block or allow certain IP addresses or geographic locations to access your site deploys.
Rate limiting
, which protects your site by applying highly-customizable rate limiting rules
Site Protection
features, which protect your site by requiring site visitors to enter a basic universal password or their Netlify team login credentials to access your site deploys.
#
Deploy permissions
Netlify has a Deploy Request Policy that ensures that Netlify only builds and deploys changes pushed to private repositories from recognized authors. This policy applies to production deploys, branch deploys, and Deploy Previews. Builds from build hooks are not affected.
Recognized authors include Owners, Developers, and
Git Contributors
. Netlify also treats bots from GitHub Marketplace as recognized authors in private repositories.
Unrecognized authors, or non-team members, are people, automated services, or bots who are not associated with a Netlify team member account. This includes some Git-based services, like a CMS. This policy does not apply to build hooks. Deploys triggered by build hooks are treated as trusted deploys.
Similar to the
Sensitive Variables policy
, the Deploy Request Policy treats deploys from unrecognized authors as "untrusted."
#
Working with deploy requests from non-team members
When a non-team member merges a pull request that triggers a build, the subsequent deploy will have the status
Pending approval
on the
Deploys
page. The
Deploy log
will show a similar message of
Deploy request is pending review
. A pending deploy request can be approved by a Team Owner, who must associate the non-team member with a Netlify team account before the build can start.
If the non-team member has an existing Netlify account, they can
connect their Git provider account
to their Netlify user.
Depending on your team
plan
, a Team Owner can take the following actions for non-team members:
Add them as Git Contributors and enable auto-approval for all deploy requests
Match them to an existing team member
Add them as a new Git Contributor
Reject their pending deploy request
#
Require manual review for deploy requests
Team Owners can require that all deploy requests triggered by users who are not already Netlify team members are manually approved by a Team Owner.
This ensures that your team is not charged for any Git Contributors unless they are manually approved. Learn more in the
Billing FAQ
.
To require manual approval for all deploy requests:
Go to
Team settings
>
Access & security
>
Visitor access
>
Auto-approve deploys from non-team members
.
Select
Edit settings
.
Select
Require approval
, then
Save
.
#
Enable auto-approval for deploy requests
Team Owners can allow all builds for non-team members to run and deploy without needing approval or prompting a deploy request. This automatically adds the non-team member to the team as a Git Contributor.
Your team will be charged for auto-approved Git Contributors. See the
Billing FAQ
page for details.
To enable auto-approval for all deploy requests:
Go to
Team settings
>
Access & security
>
Visitor access
>
Auto-approve deploys from non-team members
.
Select
Edit settings
.
Select
Auto-approve
, then
Save
.
#
Match to an existing team member
To match an unrecognized author with an existing team member:
Go to a sites’s
Deploys
page and find the pending deploy in the list of deploys.
Select
Start approval process
.
Next, use the
Further action required
drop-down menu to select
Approve and match with existing team member
.
Use the list to select the existing team member to match.
To confirm, select
Match contributor and approve deploy
.
#
Add a non-team member as a Git Contributor
Not every Git committer in your repo must be added as a Git Contributor. Only the Git committer who you’d like to trigger a deploy needs to be added to your team as a Git Contributor.
To add a non-team member as a Git Contributor:
Go to a sites’s
Deploys
page and find the pending deploy in the list of deploys.
Select
Start approval process
.
Next, use the
Further action required
drop-down menu to select
Approve and add as Git Contributor
.
Git Contributors will appear on the Members page as
Active Git Contributors
.
#
Reject a pending deploy
To reject a non-team member’s pending deploy request, go to the
Site overview
page and select
Reject
next to the pending deploy. The pull/merge request or changes from a Git commit will not be deployed, even if it is merged, and any future deploys by the same contributor will continue to require approval.
#
Sensitive variable policy
For sites connected to public repositories, Netlify may block some deploys depending on sensitive variable policy settings. A site member can approve or reject these deploys. Check out our
sensitive variable policy
docs for more information.
#
More site deploys resources
Create deploys
Manage deploys
Deploy Previews
Split Testing
Deploy notifications
Post processing
Compiled build and deploy resources - start here!
Deploy Previews: Configure Deploy Previews
Deploy Previews: Configure Deploy Previews
Deploy Previews: Protect all Deploy Previews with a password
Last updated: May 13, 2025
Create deploys
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_split-testing.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/split-testing/
Scraped_At: 2025-06-02T19:59:10.157420

Contact
Forums
Contact support
This feature is in
Beta
.
Netlify’s Split Testing lets you divide traffic to your site between different deploys, straight from our CDN, without losing any download performance, and without installing any third party JavaScript library. You can use this for A/B testing, or for
launching private beta releases
.
You can use any client-side analytics library to
track visitors
across different versions of your site.
#
Requirements and limitations
Branch Split Testing divides traffic to static files on your site between two or more deployed Git branches. This has the following implications:
Your site must
deploy from a connected Git repository
.
You must enable
branch deploys
.
If you created a deploy using the
Netlify CLI’s
--alias
flag
, be aware that this isn’t a branch deploy and isn’t supported for Split Testing.
Split Testing doesn’t work properly for responses from
proxies
or
functions
. We don’t recommend using Split Testing with sites that use functions or proxies to generate site content as your visitors may end up with inconsistent experiences. This can be a concern for sites that use server-side rendering (SSR) or incremental static regeneration (ISR).
Split Testing doesn’t work with
Scheduled Functions
because Split Testing relies on branch deploys and scheduled functions only run on your site’s published deploy.
In addition, if a site has Split Testing enabled, requests to that site will not execute
Edge Functions
.
#
Run a branch-based test
Once you have at least one branch deployed in addition to your production branch, go to
Project configuration
>
Build & deploy
>
Split Testing
in the Netlify UI.
Choose the branches you want to perform the test with, assign the percentage of traffic you want to send to each branch, and select
Start test
.
As soon as that’s done, we’ll start dividing traffic to your site according to the percentages you set. If you change the percentages, we’ll automatically readjust the traffic again.
If needed, you can add more deployed branches to the test by selecting
Add another branch
. Traffic distribution percentages will automatically adjust so they always add up to 100%.
You can also remove extra branches from the test by using the cross button in each branch row.
When you’re done with your test, you can stop it by selecting
Stop test
.
Only one test can be enabled at a time. If you want to start a new test, you’ll need to stop the current test you’re running and start a new one.
We set a cookie called
nf_ab
to ensure that the same visitor always gets the same branch. By default, the value of the cookie is a random number between zero and one and is configured out of the box to ensure that your site visitors have a consistent experience. If you'd like your visitors to manually opt in to a split test, you can also use client-side JavaScript to manually set the value of the
nf_ab
cookie to a branch name, which Netlify's CDN will read and serve accordingly.
Whatever you include on your branch will be part of the test
Keep in mind that variations between branches will factor into your split test. So, for example, if you have a serverless function on one branch and not the other, the function will only run for one of the tests.
#
Set up client-side analytics tracking
You can use any client-side analytics library, like Google Analytics or Segment, to track visitor behavior in a split test.
#
Expose branch information in your site
The most important piece of information you probably want is the branch a visitor is seeing. You can access branch information from the build environment when we build your site, and inject the name into your site.
For example, if your site uses Hugo to generate pages from templates, you can use the
getenv
function to retrieve this value:
{{ getenv "BRANCH" }}
If you use React, you can access the same variable from the process environment at build time:
process.env.BRANCH
You can read more about this environment variable and many others in our
environment variables documentation
.
#
Send to Google Analytics
Google Analytics
supports
dimensional data
that can be associated to events. You can use this feature to send the split test information that you compiled in the previous build.
For example, if you’re using Google Analytics in a site built with Hugo, you can use this template to track the branch a visitor is seeing:
<!-- install Google Analytics’ JS tracker before using this code -->
<!-- https://developers.google.com/analytics/devguides/collection/analyticsjs/ -->
<
script
>
ga
(
'send'
,
'pageview'
,
{
'Branch'
:
'{{ getenv "BRANCH" }}'
}
)
;
</
script
>
#
Send to Segment
Segment
is a platform that allows you to multiplex tracking information and send it to different services at the same time. Their JavaScript library also supports dimensional data that you can use to send the split test information.
To follow Google Analytics’ example, you can track the testing branch every time someone visits your site with a snippet like this one:
<!-- install Segment’s JS tracker before using this code -->
<!-- https://segment.com/docs/sources/website/analytics.js/quickstart/#step-1-copy-the-snippet -->
<
script
>
analytics
.
track
(
'pageview'
,
{
'Branch'
:
'{{ getenv "BRANCH" }}'
}
)
;
</
script
>
#
Use snippet injection for more flexibility
You might want those analytics scripts only in your production environment. After all, you don’t want to send tracking information when you’re developing your site.
You can use Netlify’s
snippet injection
to add those scripts right when we deploy your site. Snippet injection uses
Liquid
templates to expose environment variables to your snippets. This gives you the ability to inject the testing branch value without having to worry about which build tool you’re using.
To inject analytics scripts using Netlify’s snippet injection, go to
Project configuration
>
Build & deploy
>
Post processing
, find the
Snippet injection
section, and select
Add Snippet
.
Following the previous Google Analytics example, you can inject this template as a snippet:
<!-- install Google Analytics’ JS tracker before using this code -->
<!-- https://developers.google.com/analytics/devguides/collection/analyticsjs/ -->
<
script
>
ga
(
'send'
,
'pageview'
,
{
'Branch'
:
'{{ BRANCH }}'
}
)
;
</
script
>
In that same way, you can inject this template as a snippet to use Segment:
<!-- install Segment’s JS tracker before using this code -->
<!-- https://segment.com/docs/sources/website/analytics.js/quickstart/#step-1-copy-the-snippet-->
<
script
>
analytics
.
track
(
'pageview'
,
{
'Branch'
:
'{{ BRANCH }}'
}
)
;
</
script
>
Last updated: May 13, 2025
←
Heads-up Display
Notifications
→
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- site-deploys_troubleshoot-the-netlify-drawer.txt --------
Start of file
URL: https://docs.netlify.com/site-deploys/troubleshoot-the-netlify-drawer/
Scraped_At: 2025-06-02T19:59:11.834050

Contact
Forums
Contact support
Get help with common troubleshooting issues that people encounter using the Netlify Drawer on their sites or with syncing feedback across different tools.
As a part of your troubleshooting, we recommend you check if your site, browser, or Git provider support the Netlify Drawer. Learn more about
site & browser requirements
or about
Git provider support
.
If you have additional concerns that aren’t answered in this doc, you can visit our
Forums
to ask questions and find more information.
#
Netlify Drawer is missing
If you can’t find the Netlify Drawer on your Deploy Preview or branch deploy there may be several reasons why, such as the following:
Netlify Drawer is not enabled for your site in the Netlify UI.
Your site’s HTML does not contain a closing
</body>
tag. The Netlify Drawer requires a closing
</body>
tag to be present.
Your site is running an active Split Test.
Your site does not meet other
requirements for your site or browser
.
#
Netlify Drawer is not enabled for your site
We recommend that you verify that the Netlify Drawer is enabled for your site. You can do this by going to your site in the Netlify UI and selecting
Project configuration
>
Build & deploy
>
Continuous deployment
>
Collaboration tools
. Learn more in
these docs
.
No Netlify Drawer on a branch deploy?
If you cannot find the Netlify Drawer on a
branch deploy
, note that the Netlify Drawer is not enabled for branch deploys by default. A Developer or Owner must
enable the Netlify Drawer for branch deploys in the Netlify UI
.
#
Site browser requirements not met
The Netlify Drawer may also not be supported by your site if you have
active split testing
or if your site does not meet
certain requirements
.
#
Custom headers with Content Security Policy directives
The Netlify Drawer also might not appear if your site’s
custom headers
include the following Content Security Policy (CSP) directives:
default-src
frame-src
child-src
To address this issue, add
app.netlify.com
to the allow list in the
_headers
or
netlify.toml
file. For example:
Loading error: Refresh the page to access this code sample
/*
  Content-Security-Policy: frame-src 'self' app.netlify.com;
[
[
headers
]
]
for
=
"/*"
[
headers.values
]
Content-Security-Policy
=
"frame-src 'self' app.netlify.com;"
#
Netlify Drawer is missing for a site connected to GitLab
If the Netlify Drawer is missing on your site or has a “Something went wrong” error, this error is likely caused by a
GitLab 15.0 update that no longer supports OAuth tokens without an expiration date
.
Use Git Gateway or deploy notifications?
Your connection to GitLab for these features may also be impacted by the GitLab 15.0 update. Learn more about how to resolve these issues for
Git Gateway
or
deploy notifications
.
To get the Netlify Drawer working again, you’ll need to reauthenticate by relinking your GitLab repository to your site.
Go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Repository
>
Manage repository
>
Link to a different repository
, and link your existing GitLab repository to your site on Netlify.
#
Netlify Drawer hides important UI elements on site
If the Netlify Drawer is hiding important UI elements, you can move the drawer around the window or minimize the drawer.
#
Netlify Drawer interrupts automated tests
If a Deploy Preview is being used in automated tests, it will still display the Netlify Drawer in the website’s UI. This can be an issue for various reasons such as impacting load times or changing the visuals on the page. Developers can add a query parameter to the URL to prevent the Netlify Drawer from being placed on the page in these scenarios. Use the
?ntl-drawer-state=hidden
and
?ntl-drawer-state=visible
query parameters to force the drawer to be hidden or visible on the initial page load. Once loaded with either parameter, this state is stored within the browser’s storage for this tab only and will not require this parameter on subsequent navigation.
#
Comment author appears as a different user in your Git provider
If the person giving feedback doesn’t have a Git provider account or doesn’t connect to a Git provider through the Netlify Drawer, then that person’s feedback comments or issues may appear as a different default Netlify user in your Git provider.
By default, if the comment/issue author doesn’t have their Git provider account and Netlify user synced, then their comments are attributed to the Netlify user who linked the site to the repository.
If you’re a comment/issue author with a Git provider account and you want your review comments synced with your Git provider ID, then you can connect to your Git provider through the Netlify Drawer by selecting the
Integrations
tab.
As an alternative, you can set up a generic user account on the Git provider with the name “Netlify”. Once set up, all comments from people who do not have a Git provider account, or have not authenticated through the Git provider, are attributed to this generic “Netlify” user on merge/pull requests.
#
Set up a “Netlify” user for review comments in Azure DevOps
You can create a generic user named “Netlify” for everyone who has not authenticated to Azure DevOps, or who does not have sufficient permissions to comment on the pull request in Azure DevOps.
Once a generic user is set up, anyone who leaves feedback without authenticating to the Git provider will have their feedback attributed to the generic “Netlify” user.
To set this up, an administrator on Azure DevOps can take these steps:
In Azure DevOps, create a new role with at least a
Basic
role or higher permissions.
Confirm the user and log into Azure DevOps with that account.
Edit the Azure DevOps profile of the user to change the
Full name
and
Public avatar
. We recommend naming the user
Netlify
and using the Netlify logo as the avatar to help associate this feedback with Netlify’s collaboration tools.
Generate a
personal access token
with a
Code: read & write
scope, and copy the token to your clipboard.
In a Deploy Preview or branch deploy for a site connected to an Azure DevOps repo, log in through the Netlify Drawer.
In the Netlify Drawer, select the gear icon to open
Deploy settings
. Paste in the token from Azure DevOps, and select
Set Azure DevOps token
.
#
Set up a “Netlify” user for review comments in GitLab
To set up a “Netlify” user to appear in review comments from people who have not authenticated with GitLab, a GitLab project Owner or Maintainer can take these steps:
In GitLab, invite a new user with a role of Reporter or above to your project. The email address for this user must be one you have access to.
Confirm the user and log into GitLab with that account.
Edit the
GitLab profile
of the user to change the
Full name
and
Public avatar
. We recommend naming the user
Netlify
and using the Netlify logo as the avatar to help associate unauthenticated comments with Netlify.
Generate a
personal access token
with an
api
scope, and copy the token to your clipboard.
In a Deploy Preview from one of your GitLab sites, open the
Deploy settings
tab in the Netlify Drawer. Paste in the token from GitLab, and select
Save
.
Comments left by people who have not authenticated with GitLab should now be associated with the Netlify user on your project.
#
Netlify Drawer loading interferes with my site functionality or build
First, we recommend that you check out our docs for the types of
sites that support the Netlify Drawer
, including some workarounds for SSR/ISR site pages. You can also use the
Forums
for more specific help to address your use case.
To remove the Netlify Drawer from your site, go to
Project configuration
>
Build & deploy
>
Continuous deployment
>
Collaboration tools
, select
Configure
, and disable the Netlify Drawer.
You can also open a
deploy permalink
if you need to preview a deploy but don’t want to access any of the collaboration features.
#
Troubleshooting integrations
Learn more about troubleshooting integrations with the Netlify Drawer.
#
Loom requires third-party cookies
You may be prompted to enable third-party cookies while trying to enable the Loom integration.
On Google Chrome, you can
allow cookies for a specific site
. To add the Netlify app to
Sites that can always use cookies
, enter
[*.]netlify.app
and select to include third-party cookies on the site.
#
Bitbucket requires an issue tracker
Issues trackers are not enabled by default in Bitbucket repositories. In order to create a new issue in Bitbucket from the Netlify Drawer, you need to
enable the issue tracker
for the repository associated with your pull request. Otherwise, you can connect a different project management tool—such as Jira Software—from the
Integrations
tab in the Netlify Drawer.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- slack-app.txt --------
Start of file
URL: https://docs.netlify.com/slack-app/
Scraped_At: 2025-06-02T19:59:14.997853

Contact
Forums
Contact support
This feature is available on
Pro
and
Enterprise
plans.
Accelerate your workflow, get unblocked faster, find answers to your Netlify questions, and track Netlify activity — all from the Netlify App for Slack.
Get notified of changes to deploy states, environment variables, domains, form submissions, site configuration, and more. Ask your questions about using Netlify and get answers from our AI-powered chatbot assistant.
#
Overview
The Netlify App for Slack enables teams to set up Slack notifications in just a few clicks.
#
Event subscriptions
With the Netlify App for Slack, you can set up subscriptions to get notified of the following:
Data layer
sync event
failures in Netlify Connect
Deploy state changes
Filter these events by
deploy context
or
deploy state
Netlify Drawer activity
Environment variable changes
Form submissions
Site configuration changes
Team configuration changes
Team DNS zone and domain events
Team membership events
Team metered usage events
Receive notifications when your team crosses the 50%, 75%, or 90% threshold of bandwidth allotment, build minutes, and function invocations. Not applicable for Enterprise plans with unlimited metered services.
For Netlify Drawer activity, you can subscribe to these events:
when a user leaves a
review comment on a pull/merge request
from the Netlify Drawer
when a user
opens an issue
in a third-party tool from the Netlify Drawer.
What’s the Netlify Drawer?
The Netlify Drawer is the embedded review toolkit that allows Netlify Reviewers, Developers, and Owners to share context-rich feedback on the latest changes in a Deploy Preview or branch deploy. The Netlify Drawer powers collaborative Deploy Previews. Learn more about the
Netlify Drawer
.
#
Ask product questions
To get product answers from our AI-powered chatbot assistant, enter
@Netlify
in any public or private Slack channel where the Netlify App is added.
Our chatbot will only work in Slack workspaces where the Netlify App is authorized.
The chatbot assistant responds in Slack threads with info sourced from our product docs, recent blog posts, and Support Forum posts.
How does the chatbot work?
This experimental feature uses artificial intelligence (AI) to provide you with efficient access to information about Netlify. However, it may not always understand the full context of your query or produce a reliable, accurate answer. When in doubt, please refer to this documentation site or our other
help resources
.
Learn more about
how our chatbot assistant works
or share your feedback about your experience at the bottom of our
Ask Netlify overview
doc.
#
Track product updates
Learn about Netlify’s latest product updates directly from the Netlify App home page in Slack. In the left sidebar of your Slack workspace, select
Netlify
from your Slack apps.
#
Netlify activity and privacy
Any private or public Slack channel where the Netlify App is installed can surface notifications about Netlify forms, deploy states, domain changes, Netlify team member changes, and environment variable changes. You can also set up notifications for review comments or new issues created from the Netlify Drawer. Check out this
list of event subscriptions
available.
The Netlify App for Slack cannot be added to a channel that is shared across multiple Slack workspaces.
Slack workspace admins can also prevent Multi-channel guests in a Slack workspace from creating Netlify subscriptions. Slack admins can do this by changing permissions for all Multi-channel guests so they cannot use slash commands for installed apps and can only use the workspace’s default slash commands.
#
Set up the Netlify App for Slack
We recommend you install and authorize the Netlify App for your Slack workspace directly from the Netlify UI.
#
Required app permissions
To authorize installing the Netlify App to a Slack workspace, you need to be a Netlify Team Owner and have permission to install the Netlify App into your Slack workspace.
Depending on how your Slack workspace admins have configured app permissions, you may need help from a Slack workspace admin to install the app.
These Slack admins can:
approve the Netlify App
so you can install it
directly install the Netlify App for you
#
Authorize and install the app
When you authorize the Netlify App, note that you are granting everyone in your workspace the permission to view activity on your Netlify team, including Slack users who are not on your Netlify team or don’t have Netlify accounts. Any person in Slack with permissions to use your Slack workspace can also set up event subscriptions.
You can connect multiple Netlify teams to a single Slack workspace, which may be ideal for
Netlify organizations
.
Note that you can only connect a Netlify team to
one Slack workspace
.
Slack workspace on a free plan?
If your Slack workspace is on the free Slack plan, then you may exceed the message limit quicker with the Netlify App installed. Learn more about this
limitation
.
To install and authorize the app:
As a Netlify Team Owner, go to
Team settings
>
Notifications
>
Slack notifications
, and select
Select workspace
.
To complete your app installation, follow the Slack authorization prompts. If you are not able to install the app, consider asking your Slack workspace admin if they can either:
install the Netlify App for you
approve the Netlify App so you can install it in your workspace
#
Subscribe to Netlify activity
You can subscribe to Netlify activity from the
Netlify UI
or from a
Slack channel
.
To review all Slack subscriptions for a site or team, navigate to the following sections in the Netlify UI:
For teams, subscriptions on all sites, and Netlify Connect data layer events, go to
Team settings
>
Notifications
>
Slack notifications
For a project, go to
Project configuration
>
Notifications
>
Slack notifications
To create a subscription in a private Slack channel, you must subscribe from Slack with
/netlify
. You don’t have to be a Netlify Team Owner to subscribe to team-wide activity.
#
Subscribe from Netlify UI
Choose whether you want to subscribe to activity from a specific site or from an entire team.
To set up Netlify Connect notifications, subscribe on the team level
To set up notifications for
sync event
failures on your Connect data layer,
add the subscription under team settings
.
#
Subscribe to team-wide activity
As a Netlify Team Owner, go to
Team settings
>
Notifications
>
Slack notifications
.
Select
Add subscription
.
Choose the event type and channel.
#
Subscribe to a specific site’s activity
For your project, go to
Project configuration
>
Notifications
>
Slack notifications
.
Select
Add subscription
.
Choose the event type and channel.
#
Subscribe from a Slack channel
Channel shared across workspaces? Setting up Connect notifications?
Note that you cannot install the app in Slack channels that are
shared across Slack workspaces
, and that subscriptions for Connect data layer sync events can only be
set up using the Netlify UI
.
To subscribe a Slack channel to Netlify activity:
If you haven’t already, add the app to your channel by entering
@netlify
.
In your chosen Slack channel, enter
/netlify
and follow the subscription prompts.
Choose an event type.
Enter details for your event type subscription. If you don’t specify a site for your subscription, the event subscription will apply to all sites on the team.
Now your Slack channel is ready to post Netlify events.
#
Troubleshoot the Netlify App for Slack
If these troubleshooting tips or limitation explanations don’t help or you need more support, consider reaching out to us with
feedback
or for
more guided support
.
#
Messages do not post in Slack as expected
If messages are not posting as you expect, consider the following:
Double-check that the Netlify App has been invited to your Slack channel by entering
@Netlify
or
/netlify
in your channel.
Confirm your Slack channel has not been archived because subscriptions are paused for any archived channel. You can find paused subscriptions and resume them in the Netlify UI.
Next, consider if the messages are simply delayed.
#
Messages are delayed
If messages are delayed, you may have hit the Slack app rate limit. Learn more about the
Slack rate limit limitation
.
#
App not supported in channels shared across Slack workspaces
The Netlify App for Slack is only authorized to share Netlify activity for a single Slack workspace. This means you cannot install the app in a channel that is shared across multiple Slack workspaces. Learn more about
Slack channels shared across workspaces
.
#
Message limit for free Slack workspaces
If you are on a free plan for your Slack workspace, you may reach Slack’s message limit faster with the Netlify App installed.
We recommend you check out the
Slack usage limits docs
to understand this limit better. Note that the message usage limit is different than the rate limit.
If you exceed the message limit, no one in your Slack workspace will be able send a message until Slack lifts the restriction. The fastest way to resolve this restriction is to upgrade your Slack workspace to a paid plan.
To avoid exceeding the message limit, consider how you might prioritize or limit event subscriptions for free Slack workspaces.
#
Rate limit
The Netlify App for Slack is designed to share updates for humans rather than bots or scripts, so the app requires that notifications are not sent at a higher rate than 1 message per second per Slack channel.
Given this limit, notifications that occur more frequently than that will be queued and may appear delayed.
If you need notifications in Slack more often than every second, we recommend the following approaches:
Create more specific subscriptions. For example, subscribe to specific sites instead of all sites.
Make subscriptions for different channels rather than sending all notifications to the same channel.
Use our
webhook notification type
for deploy state notifications to build your own custom solution.
#
Share feedback
To share feedback about your experience using the app:
Go to any message from the Netlify App in your Slack workspace.
Using the three-dot menu, select
Leave feedback
.
For feedback about our chatbot assistant, check out
Ask Netlify feedback
.
For feedback about these docs, check out the docs feedback form at the bottom of this page.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- terraform-provider.txt --------
Start of file
URL: https://docs.netlify.com/terraform-provider/
Scraped_At: 2025-06-02T19:59:15.864884

Contact
Forums
Contact support
The Netlify Terraform provider allows companies to automate and manage their web infrastructure on Netlify using code. It integrates Netlify’s features into your Terraform workflows, enabling consistent and scalable deployments.
More information about the Terraform provider can be found in the
official provider documentation
.
#
Supported Terraform Versions
The Netlify Terraform provider is compatible with Terraform 1.0 or later, as well as OpenTofu 1.0 or later.
Pulumi is supported through the
Pulumi Terraform provider
.
#
Get Help
If you have ideas for new features or encounter bugs, you can
start an issue
on Netlify Terraform provider’s open source repository. You can also visit our
Support Forums
to start or join a conversation. We’d love to hear from you!
Last updated: August 30, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_analytics.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/analytics/
Scraped_At: 2025-06-02T19:59:16.766804

Contact
Forums
Contact support
Integrate analytics reporting into Visual Editor’s editing environment.
Typically, accessing web and product analytics data requires using specialized expert systems that are out of a content editor's typical workflow and expertise. However, you can make this data easily accessible to all editors by adding an analytics layer to the visual editor.
This integration has another significant benefit: by having analytics data immediately visible on all pages, editors are encouraged to make their work more data-driven, based on real-world signals rather than guesswork.
We have implemented this capability for an example site, pulling data from Google Analytics both at the page level as well as for specific section. Here's how it looks like:
Tip
For a live demo based on Google Analytics, please
contact us
. Paying customers get access to the source code for this demo.
#
Access your analytics data
Ideally, your tool of choice already provides an online API for getting report data (e.g.
Google Analytics Data API
,
Adobe Analytics Reporting API
), whether historical (i.e. last X days) or real-time.
If your vendor only allows for exporting data in bulk (typically to cloud storage), you'd need to write your own code to read and serve this data online.
In either case, the client-side should not have the credentials to directly access the analytics tool's API. Instead:
Create your own API endpoint to expose only needed KPIs. Keep needed credentials only on the server side.
Your API endpoint and any client-side code should only be enabled in non-production environments. Check-in your code that
process.env.NODE_ENV
is not set to
production
.
#
Add a data overlay
How you render analytics data depends on the web framework and components you use. Here are a few General guidelines:
To only show analytics data on the client when your website is running inside Visual Editor, check that the environment variable
process.env.STACKBIT_PREVIEW
is defined (note: to maintain business-sensitive data confidential, always also make sure the server does not provide this data in production).
Wrap your page component with a higher-order component to show a floating widget with page level data. Set a high z-index to ensure the widget is visible over all other controls.
When navigating between pages, ensure data is refreshed.
Ensure that any errors in fetching data are caught and do not fail page rendering.
Let content editors control the widget's visibility, plus any other global settings, by creating a dedicated webpage that is quickly accessible with a
sidebar button
.
To learn more, contact us!
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_automatic-content-reload.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/automatic-content-reload/
Scraped_At: 2025-06-02T19:59:20.319843

Contact
Forums
Contact support
Learn how automatic content reload works and how you can customize it.
#
Overview
Whenever a content editor makes a change - e.g. edit a field or add a component, everyone who's currently working on the same Visual Editor project should immediately see this change.
This is a core benefit of Visual Editor: everything you or your project collaborators do is visually reflected to all editors, instead of having to go through a lengthy server restart or publishing process just to preview changes.
Normally, sites running in production don't have this functionality: pages are either statically-generated as possible or otherwise heavily cached, and generally do not update on any content change after they've already been rendered in a user's browser.
To provide instant content updates in our Visual Editor, a few things need to happen:
The web server should run in a mode that doesn't apply pre-generation or caching to pages. This is commonly known as
development mode
in most web frameworks.
Content changes should be detected
via some watching mechanism.
When a change is detected, clients should be notified and
refresh the page content without reloading the whole page
, with minimal interruption to the end-user.
This typically requires framework-specific code, e.g. for Next.js, using the
router
object to re-navigate to the current page.
This process is exactly the same for both the editor who just made the change and for any other users working concurrently. There is no separate code path for refreshing the page based on whether you've made the change or anyone else.
#
Automatic content reload
Starting in version 0.5.0, here's how it works:
When running
locally
, the
stackbit dev
process watches for changes in the content source configured for your site. When we run your site ourselves for content editors (which we do for every Visual Editor project), our runtime environment does the same.
When a change is detected, all open Visual Editors get notified.
At this point, your code can be notified and take control of what happens next - if you wish. We'll get to that in a second.
Unless you've explicitly handled the change event in your codebase, Visual Editor will proceed to refresh the page by itself. The actual mechanism depends on the framework used (e.g. using the
router
object for Next.js, as mentioned above).
Hence, by default, everything just works - with no extra code required on your site.
#
Capture & handle change events
In automatic mode, Visual Editor always detects content changes by itself. However, there are scenarios in which you may opt to handle the actual page refresh yourself:
When there is a method to efficiently refresh the page that's specific to your site
(e.g. calling an API endpoint you control that will bring in updated content for the page in the fastest manner).
Check back soon for examples.
When you want to
bring in a web framework
we don't yet have built-in support for
and use its fast refresh path to update the page.
If you want to control whether a displayed page will refresh at all,
given which content objects have been changed.
By default, a page refresh will always occur regardless of what content has changed, since any page may render multiple content objects (that are referenced by each other, etc.). However, we provide detailed data on what content has changed that you can use to make the call yourself. See
event.detail
below.
#
Add an event listener
To receive change events in your client-side code, add a window-level event listener for the
stackbitObjectsChanged
event:
window
.
addEventListener
(
"stackbitObjectsChanged"
,
event
=>
{
// Override default refresh behavior ...
}
)
;
See
the event reference
for more details on the event object.
#
Next.js example
The event listener will run on all pages by using the
App component
.
// src/pages/_app.js
import
*
as
React
from
"react"
;
const
CHANGE_EVENT
=
"stackbitObjectsChanged"
;
export
default
function
MyApp
(
{
Component
,
pageProps
}
)
{
const
onContentChange
=
e
=>
{
// Override the default refresh behavior just for a specific URL
if
(
e
.
detail
.
currentUrl
===
"/about"
)
{
e
.
preventDefault
(
)
;
/* myRefreshCodeJustForAbout() ... */
}
}
;
/*
  When any page is mounted, add the listener.
  Note the function returned by the callback, which will be called on unmount,
  and the empty dependency array to prevent this from running on any re-render.
  */
React
.
useEffect
(
(
)
=>
{
window
.
addEventListener
(
CHANGE_EVENT
,
onContentChange
)
;
return
(
)
=>
{
window
.
removeEventListener
(
CHANGE_EVENT
,
onContentChange
)
;
}
;
}
,
[
]
)
;
return
<
Component
{
...
pageProps
}
/>
;
}
#
Conditional refresh
You can override Visual Editor’s default behavior just in certain conditions or for specific URLs, by conditionally calling
e.preventDefault()
just when appropriate.
For example, if you're methodically annotating all content objects used to render a given page with
data-sb-object-id
data attributes, you can prevent a refresh when there's no intersection between changed objects and on-page objects:
const
onContentChange
=
e
=>
{
const
intersects
=
e
.
detail
.
changedObjectIds
.
some
(
o
=>
e
.
detail
.
visibleObjectIds
.
includes
(
o
)
)
;
if
(
!
intersects
)
e
.
preventDefault
(
)
;
}
;
#
Custom content reload
To handle content change detection & refresh fully within your codebase, add the following to your
configuration file
:
export
default
{
stackbitVersion
:
"~0.6.0"
,
customContentReload
:
true
}
;
With
customContentReload
set to
true
Visual Editor will not notify you of content changes, nor will it refresh the page.
#
When to go fully custom
If you're using
Sourcebit
as many existing projects do.
This package is optional and external to Visual Editor itself. It handles change detection & page refresh by itself for supported content sources & web frameworks.
If your application implements a cache layer on top of your content source,
you need to ensure that this cache is up-to-date with content changes before the page is being refreshed. This requires having your own pipeline for content change detection => cache update/invalidation => page refresh. You can find an example of that in the
sourcebit-target-next plugin
.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_content-driven-development.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/content-driven-development/
Scraped_At: 2025-06-02T19:59:21.146235

Contact
Forums
Contact support
Empowering non-technical editors to make structural changes to a website without the help of a developer.
Content-driven development is the practice of using editable content to drive the behavior of code. This can be as simple as having a
title
field that renders text within a
<h1>
element on the page, but can be taken as far as dynamically driving page structure, layout, and styling.
#
Control code through content
The primary benefit to letting content dictate more than just text seen on the page is that it empowers non-technical editors to be able to make structural changes to the website without breaking it and without the intervention of a developer.
#
Avoid developer intervention
Building websites is a lot of fun for developers. Making small adjustments to accommodate the ongoing needs of editors after the site has been launched is not as much fun.
When content drives the structure and behavior of a site, anyone who can edit that content can control that structure and behavior. The more power developers can put into the hands of editors when handing the project over, the fewer smaller tasks and feature requests will be needed following the site's launch. That's good for everyone.
#
Apply guardrails to behavior
Ultimate flexibility is provided with access to the markup rendered on the screen. This is possible with direct access to the code. For many years (and still today), developers have provided editors with ultimate flexibility by opening up control over the HTML code that the browser renders.
This is very bad in practice. It's hard for developers to get HTML code right, let alone someone who doesn't write code all day.
Content-driven development promotes editing through some interface that stores content in a structured way. This means that developers choose the degree to which a page can be edited, while editors have much less chance of breaking the site. This is because the changes being made can be expected.
#
Degrees of composability
There are two ends of the spectrum when it comes to how composable (flexible, customizable, etc.) a page can be.
Template-based pages
are rigid and map fields directly to a location on the page, while
composable pages
provide a flexible way to structure and style content.
#
Template-based pages
Consider a blog post. Most sites have an expected design and structure for blog posts. The heading, body, and other meta attributes will have a predictable position and style on the public page.
In cases like this, having structured content models that represent these fields makes a lot of sense. It maximizes the productivity for editors because they don't have to think about where content belongs or how it should look. They just add and publish the content.
#
Composable pages
Many sites have other pages (e.g. landing pages) where the style, structure, and layout of content is highly dynamic. It can often vary greatly depending on the copy and purpose of that page. In this case, editors should have more control to be able to control the visual output of the page.
Let's look at an example that combines structured content with composable pages.
Here, the page object coming from the content source is a structured object that has an
id
attribute (
home-page
), along with an embedded array of component data, as the
sections
property.
This
sections
data get mapped through your code (shown in the next graphic) to create a page made up of flexible content. This enables content editors to compose pages in any way they want.
This particular process varies from project to project. The simple example above is a stripped-down version of a JSX page that would handle the rendering of content in the browser shown on the right.
#
Find the right balance
The key isn't giving editors flexibility, but finding the right degree of flexibility needed to meet their needs.
Many site builders struggle in this area because they go too far with flexibility. And every bit of flexibility you add makes managing the code more complex.
Therefore, flexibility should be introduced to the degree to which it best serves the site and its editors. A blog site probably doesn't need much flexibility, while a marketing site that consistently runs new campaigns is probably going to need to be much more flexible to serve the changing needs of each campaign.
#
Use Visual Editor for balance
This is where Visual Editor comes into play. Our visual editor is designed to flex to the needs of each individual editor by providing control for developers to introduce the exact degree of flexibility needed for each site.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_how-visual-editor-works.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/how-visual-editor-works/
Scraped_At: 2025-06-02T19:59:22.081411

Contact
Forums
Contact support
Walk through the core concepts of how Visual Editor works by following a developer's typical journey.
Understanding how Visual Editor works is easiest when we follow a developer's typical journey, where each step builds on concepts and practices from those before it.
Try it yourself
You can put many of the concepts in this guide into action by following the
getting started tutorial
.
#
Working modes
You can use the visual editor in local development mode or in cloud setup mode.
#
Start with local development
Developers typically start by working locally to build out a visual editing experience to suit their project's needs, while collaborating with content editors occurs in the cloud, which is covered near the end of this guide.
Learn more about Local Development
#
Visual Editor development server
Working locally with Visual Editor is made possible by using the CLI. The
stackbit dev
command runs in parallel with your site's development server to create a visual editing environment that enables developers to prepare a site before bringing in content editors.
See the CLI reference
#
Project requirements
Visual Editor is fully composable, which means that most content sources and site frameworks can be supported (with varying levels of required configuration).
Although Visual Editor services a large variety of sites, the one thing all sites have in common — what we consider to be
the sole prerequisite
— is that
content must be
structured
and
separated
from code
. We think of this as having a
content-driven architecture
.
Read more on Content-Driven Development
#
Structured content
For Visual Editor to be able to empower editors to change content, that content must be
structured
, which means it has a predictable shape, as defined by a content schema.
Visual Editor will inherit content schema when it is defined in the source. When Visual Editor can't infer the schema (e.g. file-based content), you must provide a schema definition through Visual Editor configuration.
Structured content requirements
#
Visual Editor configuration
Visual Editor’s behavior for any given project is controlled by the configuration file,
stackbit.config.js|ts
. Configuration is how Visual Editor knows how to retrieve and store content, which content models represent pages, how editing features should work, and so on.
See the config reference
#
Content source connections
Perhaps the most critical configuration property is identifying the source(s) of a site's content, which is (usually) done through the
contentSources
config property.
Each content source implements Visual Editor’s
Content Source Interface
, the mechanism that enables two-way content sync between Netlify and the source.
Learn about Content Source Interface
#
Content editing
Once a site is properly configured, its content can be immediately edited through Visual Editor.
#
Two-way content sync
One of the most powerful capabilities of Visual Editor is its two-way content synching mechanism, which provides the ability to:
Make changes from Visual Editor that get saved back to the content source.
Update content in Visual Editor when changes are made directly at the source.
Automatically update the site preview when content changes have been made.
Dive deep into Two-Way Content Sync
#
Traditional CMS editing
When a content source is properly configured, all the models within the source will be available to edit within Visual Editor’s content editor panel.
When working with content from a headless CMS, this requires no additional configuration, as Visual Editor can automatically detect content models and fields from the CMS.
Learn more about the content editor panel
#
Basic page editing
To be able to edit with the page editor panel, you must tell Visual Editor which models represent pages. This is handled by content source modules.
See
contentSources
property reference
#
Advanced editing
Editing can then be taken to the next level by enabling editing to click on elements in the preview and make the changes inline. This is made possible by
annotating
components by adding specific data attributes to inform Visual Editor how the structure of your content maps the elements in the DOM.
More on inline editing
#
Reusable content
As powerful as inline editing is, it's made even more powerful when content editors can reuse content. Although
there are multiple ways to do this
, Visual Editor’s content presets feature tends to boost editors' productivity the most.
Learn more about Content Presets
#
Collaboration
When you’re ready to collaborate with content editors in the containerized version of your visual editor in the cloud, you can set up your site for visual editing.
You can do this in these ways:
Import your site’s Git repository
Enable visual editing for an existing site deployed through Netlify
#
Service provisioning
The visual editor provisions services based on your site and configuration. While many of your services will already be configured, the visual editor does the following:
Production Site:
the visual editor deploys your site to a
[site].stackbit.app
site on Netlify, unless your organization is configured to skip this step.
Container:
the visual editor creates a container that powers the editing experience for your site. This replaces
stackbit dev
, used when working locally.
Provisioning configuration options
#
Content publishing
Once editors have been added to Visual Editor project, they can begin publishing content to production. This process can also be customized, though it is through the visual editor settings.
More on Publishing and Git Workflows
#
Next steps
This concludes the overview on how Visual Editor works. Here are a few suggestions on what to do next.
#
Get started tutorial
Follow the get started tutorial if you haven't. This provides a quick way to put some of these concepts into action.
Choose a get started tutorial
#
Explore documentation
We've covered a lot of the basics, but there are other features and concepts to explore.
Explore feature guides
Last updated: January 29, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_overview.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/overview/
Scraped_At: 2025-06-02T19:59:23.366489

Contact
Forums
Contact support
A deeper dive into how Visual Editor fits into your modern web stack and how its major elements work.
Visual Editor enables developers to compose a custom site-building experience for the unique needs of their sites, by providing a mechanism for connecting content sources and third-party marketing tools into a single website management experience.
This experience is controlled through configuration files that live alongside your code, with zero impact on your production application.
Learn how the visual editor works
.
Visual Editor can make content from any source editable both in context and through standard and custom form controls. Additional features and third-party tools can also be integrated to enable your team to have a single source of truth for website management while continuing to use your preferred tools.
#
Visual Editor’s role in your stack
Visual Editor plays no role in your production application
. Visual Editor only interacts with your site while it is running the development server.
Note
Visual Editor has no effect on your production code:
Development Only:
Your production application can run completely independent of Visual Editor.
Development Dependencies:
Any dependencies we require are
development
dependencies.
Loading Content:
The method by which you retrieve and deliver content to your pages and components is independent of how Visual Editor loads and stores content during the editing process.
#
Choose a starting point
Although we have a number of
templates and examples
, many developers choose to bring Visual Editor into an existing site. Most sites and frameworks can be compatible with Visual Editor, though they may require custom configuration. (
Talk to us to learn more
.)
#
When to add Visual Editor
Visual Editor sits in a unique position in your stack. While it doesn't run in production, it plays a crucial
production
role in bringing together all tools and services necessary to edit and manage your site in a single environment.
Having this tool at your disposal throughout the development process is vital to optimizing content modeling, catching design issues, and generally minimizing rework. While integration tends to be relatively seamless regardless of where you are in the process, we recommend bringing Visual Editor in as early as possible.
#
Migrate to a modern stack
Because we're concerned with bringing together the myriad of tools and services required to build a modern site, we often play a role in helping our customers choose what will serve them best. However, this answer is unique to each team and each project. The best way to get started is to
send us a message
.
#
Concepts documentation
To learn more about key concepts for Visual Editor, check out the concepts docs.
How the visual editor works
:
walk through the core concepts of how Visual Editor works by following a developer's typical journey.
Content-driven development
:
empowering non-technical editors to make structural changes to a website without the help of a developer.
Reusable content
:
help content editors work faster by providing a starting point for content.
Structured content
:
how Visual Editor works with structured content, along with content modeling basics.
Two-way content sync
:
Visual Editor stores content back to the appropriate source, while also listening for changes from each source.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_reusable-content.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/reusable-content/
Scraped_At: 2025-06-02T19:59:24.223993

Contact
Forums
Contact support
Help content editors work faster by providing a starting point for content.
Part of the role of a developer on a web project is not just providing editors with a mechanism for getting text on a page, but also helping to maximize their productivity in creating and editing that content.
#
Methods for content reuse
The most effective way to boost an editor’s productivity is to provide a starting point that is as close as possible to the final product.
There are three ways to do this:
Providing sensible defaults (or initial values)
Duplicating existing content
Creating content templates
#
Sensible defaults
Sensible defaults help when an editor doesn't know exactly where to start from. They should still have something to start with.
For example, if you have a field in the CMS responsible for controlling a button's text, you would want to first require that the field have a value. But, secondarily, you should provide some text as a starting point. For a button, this might be something like:
Click Me
.
Visual Editor has its own sensible default value for some fields, but also provides a way for developers to control their own defaults when
modeling content
.
#
Duplicate content
After an editor has created some content, there should be an easy way that they can then use that content again as needed by duplicating it. For example, if a site has one visually-rich landing page, an editor shouldn't have to start from scratch to create another.
While some content management systems have this feature, Visual Editor ensures that editors can duplicate content regardless of the features provided by the CMS through our
content presets feature
.
#
Templated content
Another way for editors to work quickly is through the use of template variations that can be used as starting points for pages or for components on those pages. For example, a card component may have several different layouts. Rather than asking an editor to choose the layout each time, they could work faster if they could pick the arrangement of contents first, and then edit to their liking.
This is another aspect of the
content presets
provided by Visual Editor.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_structured-content.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/structured-content/
Scraped_At: 2025-06-02T19:59:25.140116

Contact
Forums
Contact support
How Visual Editor works with structured content, along with content modeling basics.
Visual Editor sites rely on structured content that can drive both the presentation and behavior of your site, an approach we call
content-driven development
. This guide explores how Visual Editor works with structured content in content-driven sites.
#
Content requirements
Visual Editor’s only real requirement that affects your site's code is that
content must be
structured
and
separated from code
.
For a page to be editable in Visual Editor,
its content must be represented by a
structured
data object coming from a content source.
This type of object is referred to as a
document
. For components to be editable, they must also be represented by structured content, either as their own document or embedded inside another document (more on this below).
Documents of a similar structure are grouped together in the content source using a
model
. In other words, we can say that
every editable page and component is represented by a model
in your content source.
#
Types of models
Visual Editor uses three types of models:
Page:
That which represents the shape of a page, as mentioned above. Example: A blog site that uses a
Post
model for its individual blog posts.
Data:
Content objects which are meant either to stand alone and be accessed globally, or to be
referenced
from a page. Global example: A
Header
model that contains content for a site's main menu. Reference example: A blog site uses an
Author
model to apply rich attributes to
Post
content (via a reference field).
Object:
Repeatable content that is embedded in another model (of any type). Component models are typically object models. See the composable page section below for a detailed example.
Here's an example of how elements on a web page may be modeled:
The header and footer content comes from globally-shared content objects of a
data
model.
The content specific to the page is wrapped in a
page
object.
Content for components within that page are of the
object
type, and are embedded within the page object.
#
Content modeling for headless CMS
Visual Editor automatically inherits the schema (collection of models) from the API CMS.
However, because most API content management systems don't have the concept of
pages
, page models must be
extended
with Visual Editor-specific attributes by setting
type
, which is often handled by extending page models.
See
modelExtensions
property reference
#
Distinguish model types
Whether Visual Editor can resolve the distinction between the
data
and
object
type for the remaining (non-page) models depends on the behavior of the CMS.
#
Contentful example
Contentful has no concept of model types. Everything is an
entry
. Therefore, all non-page models from Contentful are assumed to be
data
models.
Learn more about using
Contentful as a content source
.
#
Sanity example
Because Sanity has the concept of
documents
and
objects
, all documents that aren't pages become
data
in Visual Editor, while Sanity objects remain
object
models in Visual Editor.
Learn more about using
Sanity as a content source
.
#
Content modeling for Git CMS
When using Git CMS as the content source (files in the repository), you may not have any concept of modeling, as you can technically use files as a content source without any sort of schema.
Visual Editor requires that all content objects be defined by some model. Therefore, file-based content must be represented by
the
models
property
in the Git CMS content source configuration.
See the content modeling reference
Last updated: June 24, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_concepts_two-way-content-sync.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/concepts/two-way-content-sync/
Scraped_At: 2025-06-02T19:59:26.124825

Contact
Forums
Contact support
The Netlify Visual Editor stores content back to the appropriate source, while also listening for changes from each source.
The visual editor provides a two-way content-syncing mechanism between all of your content sources. It enables your editors to make changes using the visual editor, while also listening for changes in the content source to ensure you’re previewing the most recent
draft
content at all times.
#
Content flows for visual editor
Understanding the content flows requires prerequisite knowledge on the mechanisms at work while content is being updated.
#
Development processes
As you may have learned in
How the visual editor works
, running Visual Editor in local development mode means running two processes:
Site Development Server:
The server that you would typically run while working on your site locally.
Visual Editor Dev
:
The process running on your machine that enables you to run Visual Editor while in development.
#
Visual Editor dev application
Although there is some intricacy and nuance in the various components of Visual Editor application, it’s most important to understand the following points:
Editing controls
(everything that isn't the preview of your website) are being run from Visual Editor application (create.netlify.com).
Visual Editor Dev
launches a local server (on port
8090
) that combines your development server, along with a script to enable visual editing, and some server-side functionality for storing and retrieving content. (This is the vital piece in content-updating flows shown below.)
The preview
is just an
<iframe>
loading the content of localhost:8090.
#
Differences with cloud setup
The flows we'll show throughout this document assume you're working in local development. Thus, the critical piece is labeled as
Stackbit Dev (Visual Editor Dev)
.
To translate this to how content is updated with the cloud setup (not local development mode),
replace
Visual Editor Dev
with a virtual container running in the cloud
. The process itself is nearly identical.
#
Work with draft content
To ensure that editors working concurrently see the same content at the same time, Visual Editor relies on a two-way content sync mechanism that stores all changes back to the source, while constantly listening for updates made to the source.
As a result, every editor works with content as it exists
in the most recent draft state
in the source of truth.
Need a different workflow?
If you have a need to work with content in some other way, we can likely accommodate your workflow.
Send us a message
to learn more.
#
Content editing methods
Before we get into the flows, let's look at the content-editing methods with Visual Editor:
Content Editor
:
A more traditional CMS-like method for editing any one of your content models without the preview context.
Page Editor
:
Field-based editing within the context of a specific page, and with real-time updates to the preview.
Inline Editing
:
Editing inline and in-context using highlights on the preview.
Source Editing
:
Using some other method to update content at the source.
Each of these actions prompts a specific content update flow that is explained in further detail below.
#
Content editor
The content editor is the most traditional means of editing content with Visual Editor. It prompts the simplest update flow, because there is no preview to update.
Learn more about the content editor
.
#
Page editor
The page editor is a form-based editor, but appears within the context of the active page in the preview window. The content flow here is slightly more advanced, as it requires that the preview also be updated when the content changes at the source.
#
Inline editing
Inline editing is the most advanced form of editing. It enables editors to click on content within the preview and edit in place. Visual Editor must then update the content in the page and content editor, while also updating the source and the preview (after the highlight is blurred).
#
Source editing
Finally, you're always free to edit content outside the context of Visual Editor. For example, if you are storing content in Contentful, you can still update content in Contentful. Visual Editor listens for content changes and pulls them into each of the editing techniques above in real time.
Some content sources also have other means of updating content, such as through an API. Visual Editor will also pick up these changes to reflect the most recent draft content in the preview and editor panels.
#
Content sync flows
Let's look at Visual Editor’s standard two-way content syncing mechanism, which saves content back to the source, while also listening for changes made from other Visual Editor users or content updates made directly to the source.
This method serves both the standard content editor and page editor, with a slight difference, as noted below.
#
Send changes to the source
Regardless of whether you're working with the
content editor
or
page editor
, here's what happens when you make a change to a form field value in Visual Editor while working locally:
Visual Editor notifies Visual Editor dev server of the content change.
Visual Editor Dev updates the appropriate content in the content source.
Visual Editor app notifies Visual Editor script (via
postMessage
to the
<iframe>
), which leads to automatically updating content on your site, optimized for your chosen site framework.
There's a bit of detail missing from this process, which we'll fill in below.
#
Reactive content updates
Visual Editor Dev also listens for content changes coming from the content source. This is how the values within both the form fields (content and page editing) and the preview (page editing only) stay up to date.
When content is updated, whether by you, another Visual Editor user, or at the source, here's what happens:
Visual Editor Dev identifies the update from the content source (via polling).
Visual Editor Dev notifies Visual Editor app of the content change. The app updates the appropriate field values.
Like above, Visual Editor app notifies the preview's visual editing script of the change, leading to updated content on the page.
#
Detailed content flow
With that, let's break each of these steps up and look at the entire flow of a content update, originating with a change to a form field.
A change is made to a form field. Visual Editor app notifies Visual Editor Dev of the change.
Visual Editor Dev's CMS utilities update content in the content source.
Visual Editor Dev's
content listener
polls the content source for changes. After content is updated in the source, Visual Editor Dev retrieves the new content.
Visual Editor Dev sends the updated content to Visual Editor app.
The app notifies Visual Editor script (in the preview
<iframe>
) of the change (via
postMessage
). The script triggers an efficient content reload for your framework (as described in
automatic content reload
, below).
Your dev server reacts to this trigger by retrieving content from the content source. This is the code you've written to fetch and render content for your pages and components.
After retrieving that content, your dev server reloads the DOM, making the updated content appear in the
<iframe>
preview.
#
Work with file-based content
If using local files as the content source (Git CMS), the content flow is similar, but the effect is slightly different:
Local Development:
Files are changed directly by Visual Editor Dev, but left uncommitted on your local machine.
Visual Editor Project:
Every content change becomes a Git commit on
the working branch
, and is then pushed to the content source (e.g. GitHub).
#
Automatic content reload
When Visual Editor updates the content on your page (#5 in the graphic above), this is what we call
automatic content reloading
.
How exactly this works is determined by the
ssgName
configuration property
. For example, if using Next.js, Visual Editor knows to call
router.replace()
to reload the content without a full page reload.
For custom usage or frameworks not yet supported, you can also override this behavior by listening for an event sent by Visual Editor when content updates.
Learn more about automatic content reload
.
#
Inline editing content flow
When a change is made inline (rather than a form field), the content flow is
nearly
identical to the detailed flow discussed above.
The only difference (marked as * above) comes at the beginning of the flow. The visual editing script notifies Visual Editor app about the change (again via an iframe message). The rest of the flow then continues as before.
#
DOM reloading
Step #7 may feel odd in this case, given that we shouldn't need to update the preview when the content has already been updated.
But there are two reasons why this is necessary:
Visual Editor doesn't know how to render all changes. Inline text may seem easy, but if the change was to add a button — Visual Editor can prompt the
content
change, but needs to wait to react to how your site handles the
rendering
of that change.
If another user is editing the site, we also want to show that content has changed, so that they can continue working with the most updated content.
Last updated: July 12, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_content-presets.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/content-presets/
Scraped_At: 2025-06-02T19:59:26.964761

Contact
Forums
Contact support
Presets are predetermined variations of content that can be used to provide content editors with a quick way to create new, visually-rich pages and components.
With Visual Editor, both pages and components are
represented by content models
, and presets must be defined against a specific model.
#
How presets work
Preset definitions are read by Visual Editor, and the results displayed when a content editor chooses to create a page or new component. When the page is created or the component added to a page, Visual Editor adds the new content to the site based on the preset's configuration.
An example of adding a new component from a preset can be seen in the image above.
By default, presets are stored in files in the
.stackbit/presets
directory within your repository. However, presets can be stored in a remote content source if configured correctly. See below for more information on both of these scenarios.
#
File-based presets
By default, Visual Editor looks for presets defined in the
.stackbit/presets
directory. This can be customized using the
presetSource
option.
Preset files each define one or more presets for one particular content model used in your site.
Learn more about the preset configuration API
.
{
"model"
:
"Card"
,
"presets"
:
[
// preset config ...
]
}
#
API-based presets
Visual Editor will store presets in a remote content source under the following conditions:
The
contentSources
property
is used to define the content source.
A defined content source includes a
stackbitPreset
model, with the following fields:
label
(string)
thumbnail
(media/image)
data
(json/text)
Note
After configuring the visual editor in the cloud, the container must be restarted for the remote preset source to be picked up.
Using this feature has the following side-effects and conditions:
Visual Editor will use the first
stackbitPreset
model it finds from sources defined in
contentSources
, starting from the first element in the array.
File-based presets can not also be used and
the
presetSource
property
will be ignored.
#
Create presets
The easiest way to create presets is to use the
Save as Preset
feature, available to content editors.
#
How
Save as Preset
works
When a preset is created, Visual Editor does the following:
Stores the preset's content in the appropriate location, based on configuration.
Generates a thumbnail preview of the component, and places the file in the appropriate source. (For file-based presets, this is in the
.stackbit/presets/images
directory.)
#
Use
Save as Preset
To save a component as a preset, select it by clicking on it in Visual Editor and then choosing the
Save as preset
icon.
For pages, the icon looks the same, but is shown at the top of the page editor panel.
#
Preset categories
Categories provide a means for you to organize your presets however you would prefer. You can create new categories when creating new presets.
These categories are then surfaced when creating a component from a preset.
#
Build presets from scratch
Because presets are stored as JSON files or records in your content source, you can also build presets from scratch.
If doing so, we recommend
working locally
and using
the preset configuration API reference
to see the available options.
Tip
Be sure to add a thumbnail images to your presets when creating manually so your editors know how the new component is going to appear on the page.
#
Edit presets
Presets can not be edited through Visual Editor. Unless you want to write code, the easiest thing to do is to:
Create a component from the saved preset
Adjust necessary values
Delete the existing preset (see below)
Save a new preset with the adjusted content
If you want to edit directly instead,
see the API reference
to learn about preset files and their structure.
#
Delete presets
Not all presets are able to be deleted. If a preset can be deleted, there will be a trash can icon when you hover on the preset in the new preset menu.
#
Share presets across projects
Note
This applies to file-based presets only. Presets stored in a remote content source are automatically shared among projects using that source.
The
presetSource
property
makes it possible to load presets from the
node_modules
directory in your project. This unlocks the ability to share presets across multiple projects.
To add shared presets to your project:
Publish your shared presets to NPM (or similar registry)
Add the package as a dependency in your project
Use the
presetSource
option to add the proper path to the directory in the package containing the presets
export
default
{
presetSource
:
{
type
:
"files"
,
presetDirs
:
[
"node_modules/some-package/.stackbit/presets"
,
"my-presets"
]
}
// other properties ...
}
;
#
Develop shared presets
When building shared presets, you want to make sure they are going to be available to your shared projects before publishing. To do so, we recommend
working locally
with an example project that links to some other local directory (or Git submodule) to ensure the presets are configured properly.
#
Handle nested objects
When a content source supports nested content, Visual Editor will store presets with appropriately nested content. As a result, a preset may contain information relating to more than one model.
#
Standalone child presets
Any component represented by a model can also have standalone presets. For example, a
CardGrid
preset could include
Card
presets, and you could also have separate presets for
Card
objects.
The benefit of this is that:
When an editor adds the grid preset, they have some placeholder content for cards (rather than an empty space).
Editors also have a series of options when creating new cards. After they've added a grid, they can then move quickly in adding new cards as needed.
#
Handle references
When a component contains a reference field, how the reference is created
depends on your configuration
.
Note
Changes you make to the global configuration of presets
only apply to new presets
, given that presets are stored as files.
Last updated: June 18, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_content-sources_overview.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/content-sources/overview/
Scraped_At: 2025-06-02T19:59:28.411647

Contact
Forums
Contact support
Connect content sources to Visual Editor using the Content Source Interface (CSI).
Content Source Interface (CSI)
provides a
two-way synching mechanism
between the visual editor and your content source(s) (API-based CMS, remote database, files, etc.).
CSI defines methods to load the content and its schema from the underlying content source, perform CRUD operations (create/read/update/delete) on the content, upload assets, and other content-related operations.
Some modules are
developed & supported by Visual Editor
, but you can
build your own content sources
as well.
#
Example usage
Enabling this feature for any content source requires instantiating a module within
the
contentSources
config property
. Here's an example using Contentful.
// stackbit.config.js
import
{
ContentfulContentSource
}
from
"@stackbit/cms-contentful"
;
export
default
{
contentSources
:
[
new
ContentfulContentSource
(
{
spaceId
:
process
.
env
.
CONTENTFUL_SPACE_ID
,
environment
:
process
.
env
.
CONTENTFUL_ENVIRONMENT
,
previewToken
:
process
.
env
.
CONTENTFUL_PREVIEW_TOKEN
,
accessToken
:
process
.
env
.
CONTENTFUL_MANAGEMENT_TOKEN
}
)
]
// ...
}
;
If configured properly, you will immediately be able to see your models in the content panel.
You can then drill into any object and see two-way sync in action. Edit it in Visual Editor, and the source gets updated. Edit it in the source, and within moments Visual Editor will show the updated value.
#
CSI and your code
CSI modules and the
stackbit.config.js
file are
not loaded by your site's code
. Rather, these are used by Visual Editor’s dev server to load and modify data through Visual Editor.
Your own code for fetching data from any of its content sources is not impacted or replaced by the CSI, at all. This means that:
You are still responsible for writing the code that retrieves content from your source(s) and feeds them into your pages and components.
You don't have to make changes to your site to be able to use CSI (assuming that your content is not hard-coded into your code)
Any dependencies needed for CSI can be installed as development dependencies, and are not needed for your live site.
#
Supported sources
The following modules are supported directly by Visual Editor:
Contentful
Contentstack
DatoCMS
Git CMS
Hygraph
Sanity
#
Experimental sources
We're currently experimenting with these additional sources:
Strapi
Shopify
Figma
For inquiries and requests regarding new sources, please
contact us
.
#
Use a content source
Working with a supported content source takes just a few steps. Assuming you already have the source itself (e.g. the CMS) ready to go, the process usually looks like this:
Install the NPM package for the module (as a
development
dependency).
Add the content source to
the
contentSources
array
in your configuration file.
Here's an example that adds Contentful as a content source.
// stackbit.config.js
import
{
ContentfulContentSource
}
from
"@stackbit/cms-contentful"
;
export
default
{
contentSources
:
[
new
ContentfulContentSource
(
{
spaceId
:
process
.
env
.
CONTENTFUL_SPACE_ID
,
environment
:
process
.
env
.
CONTENTFUL_ENVIRONMENT
,
previewToken
:
process
.
env
.
CONTENTFUL_PREVIEW_TOKEN
,
accessToken
:
process
.
env
.
CONTENTFUL_MANAGEMENT_TOKEN
}
)
]
// ...
}
;
#
Add multiple sources
Because
contentSources
is an array of instantiated classes, adding another source is a matter of adding a new item to the array.
This means that using two accounts from the same service provider is also possible. Here's an example:
// stackbit.config.js
import
{
ContentfulContentSource
}
from
"@stackbit/cms-contentful"
;
export
default
{
contentSources
:
[
new
ContentfulContentSource
(
{
spaceId
:
process
.
env
.
CONTENTFUL_SPACE_ID_01
,
environment
:
process
.
env
.
CONTENTFUL_ENVIRONMENT_01
,
previewToken
:
process
.
env
.
CONTENTFUL_PREVIEW_TOKEN_01
,
accessToken
:
process
.
env
.
CONTENTFUL_MANAGEMENT_TOKEN_01
}
)
,
new
ContentfulContentSource
(
{
spaceId
:
process
.
env
.
CONTENTFUL_SPACE_ID_02
,
environment
:
process
.
env
.
CONTENTFUL_ENVIRONMENT_02
,
previewToken
:
process
.
env
.
CONTENTFUL_PREVIEW_TOKEN_02
,
accessToken
:
process
.
env
.
CONTENTFUL_MANAGEMENT_TOKEN_02
}
)
]
// ...
}
;
#
Authenticate content editor accounts
To be able to make changes to content in the source requires connecting a Visual Editor user account to an account to the content source. Here’s the process for making these connections:
From the visual editor dashboard, in the top right, select your avatar. Next, select
Linked accounts
.
Next to the content source you want, choose
Connect
.
Follow the prompts to connect with your content source.
#
Supported connections
The following third-party connections are available:
Contentful
Contentstack
DatoCMS
GitHub
Sanity
#
Bring your own source
Because content source modules are defined as instantiated JavaScript classes in the configuration file, you can bring your own content source, even if not officially supported by Visual Editor.
Use
the CSI API reference
to ensure you're implementing the JavaScript class properly.
#
Module requirements
Any content source
that can read and write data via an API or direct local access
can be used as a content module. This includes:
Headless (or API-based) CMS (e.g. Contentful)
Database as a Service (e.g. PlanetScale)
Internal product database (e.g. PostgreSQL)
Non-traditional services (e.g. Figma)
File-based content (e.g. Markdown files)
#
Using TypeScript
We recommend using TypeScript in your CSI module. This benefits both you by ensuring that you implement all necessary methods. It also benefits developers that using the module by making it easier to discover required options when instantiating the class in their configuration file.
#
Migrate to a new source
CSI makes it trivial to migrate to a new content source without sacrificing content downtime or adding complexity to your code.
You can move one page at a time from the old source to the new source as long as:
You have properly configured the content sources, and ...
Your front-end code supports the content structure from both sources.
#
Configuration example
Ensure that you're adding both sources to your config file:
// stackbit.config.js
import
{
MyOldSource
}
from
"my-old-source"
;
import
{
MyNewSource
}
from
"my-new-source"
;
export
default
{
contentSources
:
[
new
MyOldSource
(
{
// configuration options ...
}
)
,
new
MyNewSource
(
{
// configuration options ...
}
)
]
// ...
}
;
Then you can add a new page to the new source and delete the old page from the old source. Do this one at a time until you've moved all the content to the new content source.
Last updated: February 25, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_custom-actions.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/custom-actions/
Scraped_At: 2025-06-02T19:59:29.451681

Contact
Forums
Contact support
Integrate workflow, automation and other custom tasks into Visual Editor. Custom actions create the ability to perform site and content tasks in a single location.
Visual Editor already handles normalizing and syncing content among any number of content sources. This makes the visual editing environment the perfect candidate for triggering content, workflow, automation, and other tasks for a site.
There are multiple points at which actions can hook into Visual Editor and content flow. See below for explanations, use cases, and examples.
#
Types of actions
There are four types of actions:
Global actions
Bulk document actions
Model actions
Field actions
Each action differs in the following ways:
Trigger location (in the UI)
Configuration options
Callback parameters
See below for use cases and further instruction on working with each of these types.
#
Global actions
Global actions are performed on the site as a whole. For example:
Trigger a deploy preview for the current version of a site.
Send a custom workflow event to reviewers.
Run a performance test on the entire site.
Check for broken links throughout the site.
These actions are triggered from the top bar, next to the site name.
Global actions are configured as a property in the main configuration object.
//stackbit.config.ts
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"0.6.0"
,
contentSources
:
[
/* ... */
]
,
actions
:
[
{
type
:
"global"
,
name
:
"name_of_action"
,
run
:
async
options
=>
{
// Perform the action ...
}
// Other options ...
}
]
}
)
;
See the configuration reference
for more information.
#
Bulk document actions
Bulk document actions are performed on a selected set of documents. For example:
Send a set of pages to a translation service.
Editors can choose the set of documents on which to trigger the action.
Like global actions, bulk actions are configured as a property in the main configuration object, specified by the
type
property.
// stackbit.config.ts
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"0.6.0"
,
contentSources
:
[
/* ... */
]
,
actions
:
[
{
type
:
"bulk"
,
name
:
"name_of_action"
,
run
:
async
options
=>
{
// Perform the action ...
}
// Other options ...
}
]
}
)
;
See the configuration reference
for more information.
#
Model actions
Model actions are performed on an individual document. For example:
Cloning an object based on input values
Sending a document to a translation service
Taking a snapshot of a document in its current state
These actions can be triggered where the document context is presented. When defined, it will always appear near the title in page and content editing modes.
If using inline editing and if a proper
data-sb-object-id
annotation has been provided, the triggers will also be available in the toolbar when highlighting the document.
Model actions are configured directly on the model definition. (When using a headless CMS, the model definition is an extension of the schema defined in the source.)
import
{
PageModel
}
from
"@stackbit/types"
;
export
const
Post
:
PageModel
=
{
name
:
"Post"
,
type
:
"page"
,
fields
:
[
]
,
// Other properties ...
actions
:
[
{
name
:
"generate-title"
,
label
:
"Generate Title"
,
run
:
async
options
=>
{
// Perform the action ...
}
}
]
}
;
See the reference
for more information.
#
Field actions
Field actions are performed against a field on a document. For example:
Generate AI content for a specific field (optionally based on some input).
Suggest fixing spelling and grammar.
Fill certain fields with custom data from an external API.
Translate a field using an external API.
These actions can be triggered wherever the field input is displayed.
If using inline editing and proper
data-sb-object-id
and
data-sb-field-path
annotations have been provided, the triggers will also be available in the toolbar when highlighting the field.
Field actions are configured as a property on a field within a model definition.
When using a headless CMS, the model definition is an extension of the schema defined in the source. Adding an action on a field that has been defined in an external schema only requires adding the
name
to identify the field.
import
{
PageModel
}
from
"@stackbit/types"
;
export
const
Post
:
PageModel
=
{
name
:
"Post"
,
type
:
"page"
,
fields
:
[
{
name
:
"title"
,
actions
:
[
{
name
:
"sanitize-title"
,
label
:
"Sanitize Title"
,
run
:
async
options
=>
{
// Perform the action ...
}
}
]
}
]
// Other properties ...
}
;
See the reference
for more information.
#
Accept input
Actions can accept input from editors by supplying the
inputFields
property with field definitions. These field definitions are identical to
Visual Editor schema field definitions
.
#
Supported field types
The following field types are supported:
boolean
color
date
datetime
enum
html
markdown
number
reference
slug
string
text
url
#
Use input data
The input data is passed to the
run
function in an
inputData
object, where the key is the name of the field and the value is the user value. Here's a simple example:
// stackbit.config.ts
export
default
defineStackbitConfig
(
{
actions
:
[
{
type
:
"bulk"
,
name
:
"name_of_action"
,
inputFields
:
[
{
name
:
"prompt"
,
type
:
"string"
,
required
:
true
}
]
,
run
:
async
options
=>
{
const
{
prompt
}
=
options
.
inputData
;
// Do something with `prompt` ...
}
}
]
}
)
;
#
Handling state
The action trigger can be given a state to provide feedback to the user.
The state can be set in the return object from the
run
function. Visual Editor will also check for updates to the state using the
state
property.
#
Supported state
The following states are supported:
enabled
disabled
hidden
running
#
State example
The state function is most useful in long running actions when the state of the action may depend on external factors or maybe the field values of the document itself.
Let's assume the
run
function calls a translation API that submits a whole document and requires humans to translate the content.
The whole translation process may take several days. We don't expect the
run
function to run for several days. Instead, after calling the translation API, the run function will return immediately and return the proper state.
const
actions
=
[
{
run
:
async
options
=>
{
// Do something with the translation API ...
return
{
state
:
"running"
}
;
}
}
]
;
This overrides the default Visual Editor behavior, which would change the state back to
enabled
.
Every time the Studio requests the document with that action, the
state
function will check with the translation service if that document is still being translated or is finished, and return a matching state.
const
actions
=
[
{
state
:
async
options
=>
{
// Check translation status ...
return
{
state
:
"..."
}
;
}
,
run
:
async
options
=>
{
// ...
}
}
]
;
#
Examples
Here are a few more complete examples to help get started with custom actions.
#
Generate a title
This is a model action that uses
Faker
to generate a random title. This is shared for brevity. A more useful application might send a user prompt to an AI service.
import
{
PageModel
}
from
"@stackbit/types"
;
export
const
Post
:
PageModel
=
{
name
:
"Post"
,
type
:
"page"
,
fields
:
[
{
name
:
"title"
/* ... */
}
]
,
actions
:
[
{
name
:
"generate-title"
,
label
:
"Generate Title"
,
run
:
async
options
=>
{
const
{
faker
}
=
await
import
(
"@faker-js/faker"
)
;
const
document
=
options
.
currentPageDocument
;
if
(
!
document
)
return
;
// Send feedback in the appropriate context
const
logger
=
options
.
getLogger
(
)
;
logger
.
debug
(
`
Running generate-title action on page:
${
document
.
id
}
`
)
;
// Generate title
const
newTitle
=
faker
.
lorem
.
words
(
4
)
;
logger
.
debug
(
`
Setting title to:
${
newTitle
}
`
)
;
// Update the document with the new random title
options
.
contentSourceActions
.
updateDocument
(
{
document
,
userContext
:
options
.
getUserContextForContentSourceType
(
document
.
srcType
)
,
operations
:
[
{
opType
:
"set"
,
fieldPath
:
[
"title"
]
,
modelField
:
options
.
model
.
fields
!
.
find
(
field
=>
field
.
name
===
"title"
)
as
FieldString
,
field
:
{
type
:
"string"
,
value
:
newTitle
}
}
]
}
)
;
logger
.
debug
(
"Finished generate-title action"
)
;
}
}
]
}
;
#
Fix formatting on field
In this example, we can force a field into a specific format. (Note that you could more strictly enforce this behavior with document hooks.)
import
{
PageModel
}
from
"@stackbit/types"
;
export
const
Post
:
PageModel
=
{
name
:
"Post"
,
type
:
"page"
,
fields
:
[
{
type
:
"string"
,
name
:
"title"
,
required
:
true
,
actions
:
[
{
name
:
"sanitize-title"
,
label
:
"Sanitize Title"
,
inputFields
:
[
]
,
run
:
async
options
=>
{
const
document
=
options
.
currentPageDocument
;
if
(
!
document
)
return
;
// Send feedback to the appropriate context
const
logger
=
options
.
getLogger
(
)
;
logger
.
debug
(
`
Running sanitize-title action on page:
${
document
.
id
}
`
)
;
// Get the current title
const
currentTitleField
=
document
.
fields
.
title
;
if
(
!
currentTitleField
||
!
(
"value"
in
currentTitleField
)
)
return
;
// Clean it up
const
sanitizedTitle
=
currentTitleField
.
value
.
replace
(
/
\b(\w)
/
g
,
s
=>
s
.
toUpperCase
(
)
)
.
trim
(
)
;
// Store the updated title on the document
options
.
contentSourceActions
.
updateDocument
(
{
document
,
userContext
:
options
.
getUserContextForContentSourceType
(
options
.
parentDocument
.
srcType
)
,
operations
:
[
{
opType
:
"set"
,
fieldPath
:
[
"title"
]
,
modelField
:
options
.
modelField
,
field
:
{
type
:
"string"
,
value
:
sanitizedTitle
}
}
]
}
)
;
logger
.
debug
(
"Finished sanitize-title action"
)
;
}
}
]
}
]
}
;
#
Status messages
Status messages allow you to customize a success, error, or other type of message to show users in the visual editor.
Custom actions used for status messages use the
run
method.
If a custom action is run from custom control, then the
result
property can be used.
The result is returned to the user when the user executes a custom action in custom control using
window.stackbit.runCustomAction
:
const
result
=
await
window
.
stackbit
.
runCustomAction
(
{
actionName
:
'test'
}
)
;
console
.
log
(
result
)
;
// result is either `result` attribute returned by custom action
// or success/error messages if no `result` provided
#
Success status example
To return a success notification, the action’s run method needs to return an object with a success property containing the success message (this is also included in the return type of the run method):
{
run
:
async
(
options
)
=>
{
return
{
success
:
'Action complete 🎉'
}
}
}
#
Error status example
To return an error status, the custom action’s run method needs to return an object with an error property containing a human readable error message.
This message can be returned as a result of running
customAction
from the custom control.
The error message will be shown in a standard red notification in the visual editor:
run
:
async
(
options
)
=>
{
return
{
error
:
'oops, something went wrong'
}
}
The custom action’s run method can also throw an error object. In this case, the error’s message
run
:
async
(
)
=>
{
throw
new
Error
(
'oops, something went wrong'
)
;
}
Or, if the run function is asynchronous, it can reject with an error object:
run
:
async
(
options
)
=>
{
await
new
Promise
(
(
resolve
,
reject
)
=>
{
setTimeout
(
(
)
=>
{
reject
(
new
Error
(
'oops, something went wrong 😱'
)
)
}
,
3000
)
}
)
}
If your handler
run
method throws an error, the message of the error will be returned as an error property with the prepended string
Error running action
:
async
run
(
)
{
throw
new
Error
(
'oops'
)
Last updated: August 29, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_document-hooks.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/document-hooks/
Scraped_At: 2025-06-02T19:59:30.466353

Contact
Forums
Contact support
When a content editor makes an altering action on a document, you can make programmatic adjustments to your content based on that action, before the change is stored in the content source.
#
Object processing methods
There is a single object-processing method that is triggered when a user creates a new document —
onContentCreate
. This method returns an object representing the fields to be used when calling the create operations for the document (or related/nested documents).
This makes it possible to set up Visual Editor to create related and nested content when a new document is created. A common example is to use this field for
dynamic
default values — content created based on content input by the user.
#
Example: adding nested section
Suppose a
Page
model had an open-ended array of
sections
that were mapped to individual nested objects. Every time a page is created, you want to pre-populate the
sections
field with a
Hero
section that uses the page title as the main heading.
Here's a simple example of what the code for that hook might look like:
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
onContentCreate
:
options
=>
{
const
{
object
}
=
options
;
// Add a nested placeholder hero section to a page.
if
(
options
.
model
.
name
===
"Page"
)
{
object
.
sections
=
[
{
$$type
:
"HeroSection"
,
heading
:
object
.
title
||
"[not set]"
}
]
;
}
// Return the adjusted object.
return
object
;
}
}
)
;
#
Use
$$type
and
$$ref
The reserved keys —
$$type
and
$$ref
are used for creating nested and related content, along with the original document, following these patterns:
These work identical to the matching properties in
the Presets API
. In general:
Use
$$type
to create a new nested object for the model of the specified
$$type
.
$$type
can also be used to create a new document and link it to a reference field.
To link an image or reference field to existing entities, set
$$ref
to the ID value of the object to reference. (Note that Git CMS uses local file paths for ID values.)
Keys can be included alongside these reserved properties, as shown in the usage example above.
#
Empty values
If values are removed or not set in the return object, Visual Editor uses the
default
setting to attempt to fill in the value.
#
Document operation methods
There are four lifecycle methods, available as configuration properties:
onDocumentCreate
onDocumentDelete
onDocumentsPublish
onDocumentUpdate
#
Lifecycle behavior
These methods are triggered between the time an editor makes a change to a document and the time the change is committed to the content source.
In general, the process flows like this:
Document is changed in Visual Editor.
Document hook is fired, based on the type of change event.
Change is committed to the content source, including any alterations made during the hook.
#
Method usage
Each hook is a configuration property, where the value is a function that accepts a single
options
argument. There are
shared properties
within
options
, which can be used to access other entities within your content system. (
More on this below
.)
options
also includes two properties unique to each method:
A function used as the return value for the method (e.g.
createDocument
)
A specific set of options to send to the return value (e.g.
createDocumentOptions
)
Here's the basic shape of the
onDocumentCreate
method:
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
onDocumentCreate
:
options
=>
{
const
{
createDocumentOptions
,
createDocument
}
=
options
;
// Transform `createDocumentOptions` object ...
// Then pass to `createDocument` as the return value
return
createDocument
(
createDocumentOptions
)
;
}
}
)
;
#
Basic example: computing a field
A simple example might be computing some field based on the value of another field. For example, suppose you had two required fields on a model —
firstName
and
lastName
. Rather than needing to stitch these together throughout your front-end code, you could do this by adding a
readOnly
field to the model and setting that after a create or update operation.
Here's an example of what the create method might look like.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
// ...
]
,
onDocumentCreate
:
options
=>
{
// Retrieve the first and last name values.
const
firstNameField
=
options
.
createDocumentOptions
.
updateOperationFields
.
firstName
;
const
lastNameField
=
options
.
createDocumentOptions
.
updateOperationFields
.
lastName
;
let
fullName
=
''
;
if
(
firstNameField
&&
'value'
in
firstNameField
&&
lastNameField
&&
'value'
in
lastNameField
)
{
fullName
=
`
${
firstName
.
value
}
${
lastName
.
value
}
`
;
}
// Transform createDocument method options
let
createOptions
:
typeof
options
.
createDocumentOptions
=
{
...
options
.
createDocumentOptions
,
updateOperationFields
:
{
...
options
.
createDocumentOptions
.
updateOperationFields
,
fullName
:
{
type
:
"string"
,
value
:
fullName
}
}
}
;
// Return the createDocument function
return
options
.
createDocument
(
createOptions
)
;
}
}
)
;
#
Work with documents
There are a number of ways to manipulate the current document being operated upon, or to affect other documents in any one of a project's content sources.
These operations are performed through the
shared
options
properties
or those properties unique to the individual method.
#
Filter behavior by model
As an example, suppose you wanted to perform an operation only for a document of a specific type. You can target the model name of the current document to add an exit condition to the method.
On create, the model name is separated from the fields being modified.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
// ...
]
,
onDocumentCreate
:
options
=>
{
if
(
options
.
createDocumentOptions
.
model
.
name
!==
"Page"
)
{
return
options
.
createDocument
(
options
.
createDocumentOptions
)
;
}
// Transform document ...
}
}
)
;
When the document already exists, the
modelName
property is available on the current document.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
// ...
]
,
onDocumentUpdate
:
options
=>
{
if
(
options
.
updateDocumentOptions
.
document
.
modelName
!==
"Page"
)
{
return
options
.
updateDocument
(
options
.
updateDocumentOptions
)
;
}
// Transform document ...
}
}
)
;
#
Adhere to the schema
With this approach, you can manipulate documents within your content system in any way, as long as your operations are valid within the appropriate content schema.
If you have questions about what's possible within these methods,
contact us
.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_editorial-permissions.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/editorial-permissions/
Scraped_At: 2025-06-02T19:59:31.438568

Contact
Forums
Contact support
Optimize your publishing workflows for the needs of each project with editorial permissions and member groups.
#
Overview
To help you optimize your workflow for the needs of each project, you can give members different editorial permissions across different projects and organize them into member groups in Visual Editor.
#
Editorial permissions
You can customize editorial permissions by creating and naming a new set of permissions for use in Visual Editor or by giving members the default editorial permissions of a Reviewer, Content Editor, Publisher, or Developer.
For example, a member can have a team role of Content Editor and have these different editorial permissions for different projects:
Project A:
Content Editor permissions, which are detailed in
this table
Project B:
Publisher permissions, which are detailed in
this table
Project C:
Content Lead permissions, which is the name given to a set of custom editorial permissions that have all the permissions of a Publisher except the ability to manage project collaborators in Visual Editor.
This person will still have the Content Editor role in your team.
To assign editorial permissions, you must have a Team Owner, Developer, or Publisher role, or be given the
Manage collaborators
permission in Visual Editor. The
Manage collaborators
permission allows you to add members to a project from your Netlify team, create and manage member groups, and create and manage editorial permissions.
#
Manage roles with SSO
Note that if you are using single sign-on (SSO) to manage your Netlify team roles, we recommend you use
Organization SAML single sign-on
.
Also, if you manage Netlify roles through your identity provider using SSO or
SCIM Directory Sync
, note that you’ll still have to set and customize editorial permissions separately in the visual editor.
#
Default editorial permissions
Editorial
permissions
in Visual Editor
Reviewer
Content Editor
Publisher
Developer
Preview site
✓
✓
✓
✓
Edit content
✓
✓
✓
Assets access
✓
✓
✓
Publish content
✓
✓
Restart container/preview
✓
Manage collaborators in a
project in Visual Editor
✓
✓
Note that the
Manage collaborators
permission means you can manage project collaborators by managing member groups, adding members to projects, and assigning editorial permissions.
#
Member groups
Member groups give you a way to quickly assign access to people in different roles or with different editorial permissions to a project. Member groups are only visible in Visual Editor and can be assigned to projects.
For example, you can create a new member group called Spring Sales Campaign and add a Content Editor, Publisher, and Developer by their email addresses. These members must already be invited to the Netlify team. Next, you can assign this member group to a specific project.
To create a member group, you must be an Owner, Developer, Publisher, or given the ability to create member groups through the
Manage collaborators
permission.
#
Definitions
Here are the latest definitions of Visual Editor’s user access control options.
Developer:
team role that edits and publishes content and code; can also invite collaborators and manage visual editor settings (integrations, publishing workflows setup, etc.). Can manage custom editorial permissions and member groups in Visual Editor. Learn more about
this role’s access and permissions across the Netlify platform
.
Editorial permissions:
permissions for using Visual Editor for a project. A member can be assigned custom editorial permissions for a project or default editorial permissions for a project that apply visual-editor only permissions from the Reviewer, Content Editor, Publisher, or Developer role.
Content Editor:
team role that can make changes to content and layout but cannot publish content changes or create new projects. Can preview site, edit content, and access assets.
Project:
a project appears in your visual editor dashboard as a site you can edit with Visual Editor.
Publisher:
team role that can do everything an editor can do but can also publish content changes and manage custom editorial permissions and member groups in Visual Editor. Cannot access developer-only settings, create new projects, or invite members to the team.
Reviewer:
can access preview links of your project site in Visual Editor with read access only. Formerly called the Viewer role in Visual Editor.
Team:
the Netlify team that owns sites that can be enabled and configured for Visual Editor.
Member group:
functional groups of members you can set up in Visual Editor, where each group member can have a unique role or editorial permission within that group. For example, you can create a new member group called Spring Sales Campaign and add a Content Editor, Publisher, and Developer. Next, you can assign this member group to a specific project.
#
Manage editorial permissions
To manage editorial permissions, you must have a Team Owner, Developer, or Publisher role, or be given the
Manage collaborators
permission in Visual Editor.
#
Create custom editorial permissions
You must create and name a set of editorial permissions before you can assign them to members or member groups.
To create a custom editorial permission set:
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
Near the top of Visual Editor dashboard, select
Manage editorial access
or
Manage editorial permissions
.
Select the
Editorial permissions
tab.
Select
Add Custom
, then add details for your new editorial permission set, including a name and permissions and select
Save
.
Now you’ve created a custom set of editorial permissions that you can assign to a member or member group in a project.
#
Assign editorial permissions for a project
You can assign a set of custom editorial permissions to multiple people at once for a single project.
To assign editorial permissions for a project:
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
Select your site from the visual editor dashboard, which shows all sites in your team with visual editing enabled. Visual Editor dashboard.
In the top right of your project, select
Share
.
Optionally,
add a member group
if needed.
For each member and member group added to your project, choose their editorial permissions.
For example, you can give a person who has a Reviewer role in the team the default editorial permissions of a Publisher just for that project.
You can also assign an entire member group one set of editorial permissions. Learn more about your
editorial permissions options
.
#
Delete or edit custom editorial permissions
You can edit custom editorial permissions at any time but you can only delete custom editorial permissions if these permissions are not assigned to a user.
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
In Visual Editor dashboard, select
Manage editorial permissions
.
Select the
Editorial permissions
tab.
On the right, hover over the editorial permission name you want to edit or delete.
Select the edit or delete icon.
#
Manage members in visual editor
To manage members in Visual Editor, you must have a Team Owner, Developer, or Publisher role, or be given the
Manage collaborators
permission in Visual Editor.
#
Add members to a project
Team members are automatically added to a Visual Editor project when they are part of your Netlify team and have access to the site in Netlify.
To invite new members to your Netlify team, you must be an Owner and have access to team settings or have admin access to the identity provider that manages SCIM for your Netlify team.
Learn more about
adding new team members
and
managing site member access
.
After you add the member to your team and they have access to the site, you can
edit their individual editorial permissions
or add them to a
member group
with specific permissions.
#
Create a member group
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
From your site workspace in the visual editor, select
Manage editorial permissions
.
Select
+ New member group
and give it a clear name.
Select
Add member
and enter an email address to add one member at a time. If you can’t find someone, you may need a Team Owner or identity provider admin to
invite that person
to your team first.
#
Edit or delete a member group
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
From your site workspace in the visual editor, select
Manage editorial permissions
.
On the right, select a member group.
Next to the
Add member
button, select the three vertical dot icon.
Choose whether to
Edit member group name
or
Delete member group
.
#
Add a member group to a project
To add a member group to a project, you must be an Owner, Developer, or Publisher.
Go to the visual editor dashboard for your team, which shows all sites in your team with visual editing enabled.
As a Developer or Team Owner, select
Visual editor dashboard
in the navigation for your team.
As a Publisher or Content Editor, you’re directed to the visual editor dashboard by default when you log in to Netlify. If you have issues logging in,
contact Support
.
Select your site from the visual editor dashboard, which shows all sites in your team with visual editing enabled.
In the top right of your project, select
Share
.
Under
Add member group
, enter the member group name, then select
Grant access
.
Next to the member group, choose whether you want members to have the editorial permissions of their default roles or whether you want to give all the people in the member group the same set of editorial permissions.
#
Remove members
To remove members from projects in Visual Editor but to prevent someone from ever getting adding to a project, you must remove them from your Netlify team. To remove members from the Netlify team, you must be an Owner and have access to team settings or have admin access to the identity provider that manages SCIM for your Netlify team.
Learn more about
managing team members
as a Team Owner.
Last updated: November 4, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_frameworks_overview.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/frameworks/overview/
Scraped_At: 2025-06-02T19:59:32.347776

Contact
Forums
Contact support
Visual Editor is not framework-specific in any way and does not require using framework-specific libraries. Rather, it has certain requirements that websites built with virtually all modern frameworks can satisfy.
It's highly recommend to read
How the visual editor works
before diving further. In this article we assume that you're up to speed on
content-driven development
and
working modes
(local development vs. a hosted Visual Editor project).
#
Requirements
To use Visual Editor with your framework, follow the below instructions to make your site editable and to configure how Visual Editor should run and deploy your website.
#
Make your site editable
To run in any environment, including local development, you need the following:
A valid configuration file
(
reference
). Make sure to specify which content models represent pages, and what is their
URL path
.
Support for Content Reload
(
guide
). This typically requires adding code to your site. See specific framework guides for
[Optional]
Annotations:
HTML data attributes marking where in the page content objects and their fields are found. Annotations enable
visual highlighting
in the editor.
When content changes are made by anyone, Visual Editor detects the change automatically. Then, gracefully reloading on-page content
without
a full-page reload is essential for the user experience.
Reloading can be handled by Visual Editor in "fully-automatic" mode for certain frameworks (currently
Next.js, Angular and Gatsby
). For other frameworks, your website's code should implement a listener on content change events and efficiently refresh the page contents. These events are only fired when working with Visual Editor - your production site is never affected.
In each of the framework guides below we link to a concrete code example and explain how content reload was implemented in it.
#
Configure how to run your website
When you create a hosted Visual Editor Project (either by
choosing
a starter or
importing
an existing repository), Visual Editor runs your website in a cloud-based container. Inside that container, we run your site's server.
Your website server should be run in your web framework's development mode, in which any code changes trigger a refresh and any statically-generated pages can be re-created on content changes.
For a few frameworks (currently
Next.js, Angular and Gatsby
) the needed configuration is all set by default. For others, see the guide to
bringing your own framework
.
#
Configure how to deploy your live website
To deploy your site on Netlify, you also need to include a
Netlify configuration file
netlify.toml
in your repository. All starters & examples include this file.
#
Framework-specific notes
Angular
:
how to use Visual Editor with an Angular-based website
Astro
:
how to use Visual Editor with an Astro-based website
Bring your own
:
how to use Visual Editor with any framework
Eleventy
:
how to use Visual Editor with an Eleventy-based website
Hydrogen
:
how to use Visual Editor with a website that uses Shopify’s Hydrogen
Next.js
:
how to use Visual Editor with a Next.js-based website
Nuxt 3
:
how to use Visual Editor with a Nuxt 3-based website
SvelteKit
:
how to use Visual Editor with a SvelteKit-based website
Last updated: October 31, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_get-started_get-started-overview.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/get-started/get-started-overview/
Scraped_At: 2025-06-02T19:59:32.970249

Contact
Forums
Contact support
Get started with the Netlify Visual Editor by choosing your setup path and checking that your site meets the requirements to use the visual editor.
Netlify Visual Editor is an environment for content editors to work with structured content in a visual way. It is designed for composable architectures, and is compatible with any site framework and API-enabled content source.
The visual editor is optimized for giving Developers the most flexibility in setting up a visual editing environment and custom workflow for a Content team.
This allows
Content editors and other custom roles
to build new pages with ease and publish content in a streamlined workflow.
Learn more about
how the visual editor works
or learn as you go by getting started.
#
Setup pathways
There are several ways to start setting up the visual editor. We recommend you set up in different ways based on what you are optimizing for.
Optimizing for
Site Type
Setup guide
Fastest way to try out visual editor experience on Netlify with new site
New site using a pre-configured template
Visual Editor Quickstart
Configuring more than one content source & advanced customization
An existing site or new template site
Set up visual editor locally
Existing sites deployed on Netlify with simpler customization
Existing sites
Visual editor walkthrough setup guide
After your initial setup of the visual editor, we recommend you customize the visual editor for your site and workflow needs. Learn more in the
customize editing experience docs
.
#
Visual Editor Support Requirements
For the most success getting visual editing working for your site, you should have the following:
Site framework
that runs a development server on a local port using Node.js v16 or later.
Content stored in
a supported headless CMS
or in individual content files separated from code.
If your site doesn't meet these requirements, you can likely still get visual editing working with additional code and configuration.
Contact us
for help.
#
Site repository requirements
When you set up the visual editor for your site you need to have access to the site repository, including the remote site repository once your site is deployed to Netlify.
The visual editor only supports site repository syncing from these Git providers at this time:
GitHub
BitBucket
Your site repository also needs a unique working branch for visual editor changes. The default working branch is
preview
.
#
Content source requirements
If using an API-based CMS, you must also have a user account with read and write access to that content source.
If using file-based content, the content must be defined by a schema that the visual editor can understand. This requires adding
content modeling properties
to your visual editor configuration file. We'll cover a bit on configuration later in this guide.
Learn more about how Visual Editor works with structured content
.
#
Example template sites
Explore a template site pre-configured for visual editing. Consider starting with the quickstart or local setup guide for a template site that is closer to your site’s needs.
Site repository
Content source
Optimized for
TypeScript + MUI Starter
Git CMS
- a tutorial-like experience
- learning about visual editor capabilities
ContentOps Starter
Git CMS
- learning about content types with over 35 content types
- try more complex content type scenarios
Auto-annotated portfolio
Git CMS
- learning about auto annotating your site
- lots of auto annotated components
Next.js & Contentful Starter
Headless CMS: Contentful
getting started with Contentful
Astro & Sanity Starter
Headless CMS: Sanity
getting started with Sanity
#
Troubleshooting help
For help getting the visual editor setup, check out
troubleshoot visual editor setup
.
Last updated: January 31, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_global-styles.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/global-styles/
Scraped_At: 2025-06-02T19:59:33.866242

Contact
Forums
Contact support
Enable content editors to set site-wide styling options in Visual Editor.
"Global styles" isn't a hard-coded feature - it is a popular pattern you can implement to allow content editors control of site-wide visual styling, from a centralized configuration.
#
How it works
Here's a high-level overview of implementation. A concrete example follows below.
First,
define a content model
with fields for all site-wide styling options you want editors to control. We offer various field types suited for editing visual properties (e.g.
color fields
and
customized enum fields
).
Create one instance
(i.e. one content item) of this model type to hold current values.
Add a
sidebar button
for quick access to this content object (by its model name or its content ID).
The final step differs by your CSS framework and the CMS of choice:
Tweak the configuration file of the CSS framework you're using
(e.g.
tailwind.config.js
) to read the values in the content object, rather than hard-coded values.
If you're using Git CMS, the framework's config file can read the content file directly.
If you're using an API-based headless CMS, a piece of code should be added to write up-to-date style values from CMS to a local file - making it readable from the framework's config file.
The key to implementing global styles is a JavaScript-based CSS pipeline, where a content file (JSON, Markdown, etc.) can be imported into a main CSS configuration file that is used to set global style rules.
While you can roll your own DIY solution for this, note that nowadays the major CSS frameworks like
Tailwind CSS
(and MUI, Chakra, etc.) already work this way.
#
Example with Tailwind CSS
Assume a content file that has editor-configurable values. We'll get to how this file is created in a minute, depending on your content source of choice.
{
"primaryColor"
:
"#f6f1ed"
// ...
}
Tailwind uses a
tailwind.config.js
file to set default values for your styles. Here's a simple example of reading a value from your content file into Tailwind's configuration:
// tailwind.config.js
const
globalStyles
=
require
(
"./content/data/style.json"
)
;
module
.
exports
=
{
theme
:
{
colors
:
{
primary
:
globalStyles
.
primaryColor
// ...
}
}
// ...
}
;
Now that you've
added a custom color
to your Tailwind theme, this color is immediately usable with Tailwind utility classes, e.g.
text-primary
or
bg-primary
.
You can also use Tailwind's
@apply
directive to apply these classes to other CSS classes:
.button
{
@apply
text-primary
;
}
#
The global styles content model
This model can be designed just like any other model with Visual Editor, with the nuances for particular content sources noted below.
#
Use files as content source
If using Git CMS (file-based content), define the content model as a JS/TS object.
Here's an example model definition for allowing an editor to switch between light & dark modes, plus specifying primary and secondary colors:
// .stackbit/models/GlobalsStyles.js
export
const
GlobalStyles
=
{
type
:
"data"
,
label
:
"Global styles"
,
file
:
"style.json"
,
fields
:
[
{
type
:
"enum"
,
name
:
"mode"
,
controlType
:
"button-group"
,
options
:
[
{
label
:
"Light"
,
value
:
"light"
}
,
{
label
:
"Dark"
,
value
:
"dark"
}
]
,
default
:
"light"
}
,
{
type
:
"color"
,
name
:
"primaryColor"
,
label
:
"Primary color"
}
,
{
type
:
"color"
,
name
:
"secondaryColor"
,
label
:
"Secondary color"
}
]
}
;
This model should be added to the
models
array property in your configuration file:
// stackbit.config.ts
// imports ...
import
{
GlobalStyles
}
from
"./.stackbit/models/ThemeStyle"
;
const
sbConfig
=
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
new
GitContentSource
(
{
rootPath
:
__dirname
,
contentDirs
:
[
"content"
]
,
models
:
[
GlobalStyles
// other models ...
]
}
)
]
}
;
export
default
sbConfig
;
Note the following in the model definition above:
The model type is set to
data
(meaning non-page standalone content).
The
file
property is set to a fixed location where this data is found, as we only want to have a single instance of this model. Having a known location makes it easy to load the file in your CSS configuration code (see
tailwind.config.js
example above).
Typically, sites running in development mode also listen for any file changes, so any updates made to the file will immediately result in a hot module reloading - including the CSS framework's configuration code being re-run and grabbing up-to-date values from file.
In production, the latest version of the file is statically included in each deployment.
For a complete example that you can explore and run locally, see our
Typescript starter
.
#
Use a headless CMS
With a headless CMS, the model can be defined just like any other model in your CMS, but there is a bit of extra code needed to synchronize the up-to-date values in the content object to a file:
Add a helper function to fetch the global styles content object from the CMS and write it to a local file with a fixed name.
For your production build, make this code run once as part of the build process, so the resulting file is baked into the deployment. Any further style changes by editors will not be reflected in the production site until the changes are published & the site redeployed.
When your site runs in development mode (which is also how we run your code in a managed Visual Editor project), add a listener to content changes in your site, so that any change to the style values by anyone will trigger writing the local file again. Each CMS has its own mechanism for receiving content updates which you can use.
If your CMS supports it, it's recommended to make the model a
singleton model
so that only one instance can ever be created.
#
Add a sidebar button for styles
For quick access to the styles content object, you can
add a button
to the left sidebar in your configuration file:
// stackbit.config.js
export
default
{
// other config properties ...
sidebarButtons
:
[
{
type
:
"model"
,
label
:
"Global styles"
,
icon
:
"style"
,
modelName
:
"GlobalStyles"
}
]
}
;
Last updated: November 8, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_local-development.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/local-development/
Scraped_At: 2025-06-02T19:59:34.604265

Contact
Forums
Contact support
Develop and test your Visual Editor site in your local development environment.
Visual Editor supports developing your project's code locally, including the ability to view your running local site inside Visual Editor’s user interface with full visual editing.
This is a powerful way to iterate quickly when developing your site - especially when you're making changes to
content models
or
annotations
and want to immediately test these changes in the visual editing environment.
Note that viewing your local site within Visual Editor webapp is optional. You can develop locally with just Next.js, without having to run our tooling for visual editing.
#
Prerequisites
Operating system:
MacOS, Windows or Linux (the same as
Next.js supports
).
Node version:
v14 or later (which comes packaged with npm v6 or later).
Browser:
Google Chrome is currently required. Support for other browsers is planned.
Tip
You may want to use a tool like
nvm
to run your local site with the best matching Node and NPM versions, while not affecting other installed versions.
#
How to use
#
Run Next.js locally
Once the project’s repository was transferred to you, the
Settings
dialog will show you the commands to clone & run the project locally.
The commands shown in the dialog are similar to the below, with the repository URL already filled and for the
preview
branch - but you can create or pick any other branch to fit your needs.
git
clone git@github.com:
<
user
>
/
<
repository-name
>
cd
<
repository-name
>
git
checkout
<
branch
>
nvm use
# Optional - only if you're using nvm!
npm
install
npm
run dev
At this point, Next.js should be running in
dev mode
on localhost:3000. Check it out!
You can already make changes to code & content files, and Next.js will refresh the page automatically. Now, let's leave this process running and get your local site displayed within Visual Editor webapp.
#
Install & run the CLI
Install the Stackbit CLI for Visual Editor from the terminal:
npm
install
-g
@stackbit/cli
The above command specifies the
-g
flag to install the package globally and have its executable available everywhere. This may require installing with
sudo
, depending on your setup (not needed when using
nvm
).
Run from your local repository's directory:
stackbit dev
or run:
stackbit dev
-d
<
path-to-dir
>
Open
http://localhost:8090/_stackbit
in your browser. This will redirect you straight to Visual Editor editor showing your local site. You can bookmark this URL if you want.
You can now highlight elements, make content changes that will get reflected in your local files, or make code changes locally and see them reflected immediately. That's all there is to it!
Make sure to read
things to know
.
If something's wrong, jump to
troubleshooting tips
below.
#
How it works
By default, visual editor sites are backed by a remote container managed by us, which is running the site’s preview branch. What you're seeing in the webapp is that container's output, loaded through an code
iframe
and proxied by our servers to provide the highlighting and editing experience. Everyone working on the same site’s visual editing experience locally work with that container.
In local development mode, the webapp loads the iframe directly from your local proxy (the
stackbit dev
process). This proxy serves what your local SSG is rendering, but adds a layer on top to support visual highlights, authenticated content changes, and more.
The URL of the page (e.g.
https://create.netlify.com/studio/7620acff1hs75ak19ad
) is unique to you and is hard-wired to communicate with the
stackbit dev
process running on your local machine.
It will only work correctly when opened on your machine.
#
Things to know
Important
There is no association between local development mode and the regular Visual Editor project you've created through the UI. You can use local development to edit
any
repository that you have cloned locally.
Content editors and other Developers should keep working with the regular project accessible from the dashboard, as usual.
Regular Visual Editor projects always reflect the code in the project's preview branch. When you push code to that branch by whatever means, the webapp will update automatically and changes will be visible to anyone currently working on the project. So make sure to test beforehand.
If you have multiple projects in Visual Editor, you can use local development to work with any of them. To switch between code repositories, stop the
stackbit dev
process and re-run it from the relevant directory. Note: the shown URL
does not change per
repository.
Also note the following differences:
When the webapp is in local development mode, the buttons to share & publish are disabled, as these actions are not applicable.
Logs are not shown in the webapp. Check the logs locally (both the web server and
stackbit dev
emit logs to the terminal).
As mentioned above, you decide whether and when to commit and push, and which code repository and branch to work with.
stackbit dev
treats the runnable directory as the directory in which the command was run. You can change this with the
--dir
(alias:
-d
) option.
Tip:
during development, it's natural to make mistakes when defining models or manually editing content files, which can result in rendering errors and
stuff generally not working
. It's recommended to regularly run
stackbit validate
when making such changes to get a verbose check-up of content & models in your code.
#
Work with cookies
When working with cookies in your application, they are often set for the domain and port on which your development server is running (e.g. localhost:3000).
Because Visual Editor Dev proxies your dev server through local port
8090
, your cookies need to run on localhost:8090. You can achieve this by setting the following cookie:
SameSite
=
lax
#
Troubleshooting tips
If the webapp keeps showing
"Connecting to local dev environment"
with a loading animation:
This message means that the webapp cannot connect to the local
stackbit dev
process. Here's what to do:
Make sure
stackbit dev
is working on your local machine and its log shows no errors.
Make sure you're using Google Chrome as your browser, on that same machine.
If you use multiple user accounts on Visual Editor (this is normally not required, as the same user can be a member of multiple organizations): re-run
stackbit dev
after logging-in to the desired user, and click the shown URL to open the webapp.
When the connection to
stackbit dev
is re-established, the webapp should refresh automatically. If nothing of the above works, re-run
stackbit dev --log-level debug
and share the output with us.
If you're seeing
"Failed to connect to your site's local server"
:
This means that
stackbit dev
is working, but cannot access your Next's local dev server (launched with
npm run dev
). This usually happens only when Next.js is down or unresponsive.
Make sure that Next.js is running in its default port (3000).
Look for errors in the Next.js terminal output.
Try to restart Next.js. Hot module reloading in dev mode can sometimes get the server unstable.
Last updated: November 6, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_localization.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/localization/
Scraped_At: 2025-06-02T19:59:35.454002

Contact
Forums
Contact support
Manage localized content by editing from the content source or extending with Visual Editor.
New Feature
This a new feature. Implementation details are subject to rapid change. Please
contact us
for more information and to stay updated with the latest changes.
#
Requirements
This feature requires that content sources are managed via
Content Source Interface
, and is only available in the business and enterprise tiers.
#
Types of localization
Visual Editor supports two types of localization.
Object-level localization:
Each document or object is associated with a single locale.
Field-level localization:
A document or object may have multiple locales, as determined by the fields within that object.
#
Object vs field example
For example, consider a site that has a
Post
model with
title
and
body
fields, and serves content in both the
fr
(French) and
de
(German) locales.
If using
object-level localization
, there would be two documents of type
Post
, one for
fr
and another for
de
.
If using
field-level localization
, there would only be a single object, while
title
might be an object with properties
fr
and
de
, storing the string reference to the value in each locale.
How Visual Editor handles localization for you project depends on a number of factors, including the content source(s) being used, the site's localization strategy, along with the provided Visual Editor configuration.
#
Configure localization
Models or their fields need to set the
localized
property to
true
in the schema, and the content objects themselves to have a
locale
property assigned, where the value is the string reference to that field (e.g.
de
for German language content).
#
Override CSI modules
In some cases, locale behavior may be provided by the
CSI module
. If not, the CSI module can be extended to provide the appropriate logic to its internal methods, and to apply the appropriate properties to the models and documents.
// stackbit.config.js
export
default
{
contentSources
:
[
new
ContentfulContentSource
(
{
spaceId
:
process
.
env
.
CONTENTFUL_SPACE_ID
,
environment
:
process
.
env
.
CONTENTFUL_ENVIRONMENT
,
previewToken
:
process
.
env
.
CONTENTFUL_PREVIEW_TOKEN
,
accessToken
:
process
.
env
.
CONTENTFUL_MANAGEMENT_TOKEN
}
)
]
,
// Add `localized` property to localized models.
mapModels
(
{
models
}
)
{
return
models
.
map
(
model
=>
{
// `LOCALIZED_MODELS` is an array of model name strings.
if
(
LOCALIZED_MODELS
.
includes
(
model
.
name
)
)
{
return
{
...
model
,
localized
:
true
}
;
}
return
model
;
}
)
;
}
,
// Add `localized` field values to localized objects.
mapDocuments
(
{
documents
}
)
{
return
documents
.
map
(
document
=>
{
// `LOCALIZED_MODELS` is an array of model name strings.
if
(
LOCALIZED_MODELS
.
includes
(
document
.
modelName
)
)
{
// `getDocumentLocale` returns the appropriate locale string for the document.
const
locale
=
getDocumentLocale
(
document
)
;
return
{
...
document
,
locale
}
;
}
return
document
;
}
)
;
}
,
// Alternatively, use `models` to extend models in a more static way.
models
:
{
// ...
}
}
;
Tip
Here's a more complete example
using Contentful as the content source.
#
Access control
Access to one or more locales can be controlled through your visual editor settings.
When adding a member or a team to the project, they can be limited to a single locale or be given access to all locales (global). If nothing is selected in the restriction dropdown, the user will have full access to all locales (global).
See below for more information on locale modes (global vs specific).
#
Locale modes
There are 2 modes for the locale switcher:
global
and
locale
. These modes are used to handle access control, along with the current editing context.
When in
global mode:
Object-level:
Users can view, create, and publish objects of all locales.
Field-specific:
Objects are common across locales. Users can view, create, and publish all objects, with the ability to set field values in any locale.
When in
locale mode:
Object-level:
Users can view, create, edit, and publish only content entries within the selected locale. Non-localized objects can be viewed but not edited from a specific locale.
Field-specific:
Users can view, create, edit, and publish only fields of the content entry within the selected locale. Non-localized objects can be viewed but not edited from a specific locale.
The next section covers governance on field-level localization.
More on editing below
.
#
Governance for field localization
While you can control editing within a specific locale, full governance and publishing control is not available for field-level localization.
Localization method
Governance
Publishing
Object-level
✓
✓
Field-level
❌
❌
This is because editors will have access to view non-localized content. And there is no way to be able to publish only values within a specific locale for a specific field. More on both
editing
and
publishing
below.
#
Edit localized content
Managing localized content is done within the context of the current
locale mode
. This is controlled through the
locale switcher
, and it affects how objects are viewed, created, edited, published, and stored as presets.
#
Locale switcher
The current locale can be set via the locale switcher, found in the top bar controls within Visual Editor.
Making a selection here changes the editing context for all content in the site.
#
Default locale
There is always a
defaultLocale
(most commonly
en-US
, but it can be changed). The default locale is the one immediately below
Global
in the locale switcher dropdown.
#
Create new objects
Creating objects in Visual Editor differs depending on the chosen localization strategy:
When using
object-level
localization in
global mode
, there will be multiple tabs. The editor must fill out the required fields in each of the selected locales before being able to create the object. This results in multiple objects, one per selected locale.
When using
object-level
localization in
locale
mode, it is only possible to create a new object in that locale (set via the
locale switcher
).
When using
field-specific
localization, the editor must fill out values for the default locale (required to build the object's base fields), along with fields that are required and localized in other tabs.
This action creates only one object, while additional selected locales will be added as additional values to the existing object. To avoid editors accidentally generating content in multiple locales,
creating objects with field-specific localization is only possible within
global mode
.
#
Edit existing objects
The editing experience differs depending on the localization strategy being used.
Object-level:
In
global mode
, all objects are shown and editable. In
locale mode
, only objects of the selected locale can be edited, though objects without a locale will still be shown.
Field-specific:
Locale flags will show up next to objects and fields that are localized. In
global mode
, only fields of the default language are accessible. In
locale mode
, the fields of the selected locale will be shown.
#
Localized presets
Localized presets work differently depending on the localization strategy and mode being used:
In both object-level and field-specific, when in a specific locale, presets will be saved and visible only in the current locale as well as
global mode
. When in
global mode
, new presets will be visible to all other locales and can be used by all locales.
In the case of field-specific localization, the same (and unique) preset values will be used in any locale. Presets cannot store different values for different locales. Instead, save multiple templates, one for each desired locale.
#
Publish localized content
In a specific locale, the publish dropdown will only show objects that are localized to the currently-selected locale, along with objects that have localized fields.
Publishing can not be focused on a specific localized field value.
Users with access to the
Global
view will have visibility of changes and be able to publish all content.
#
Custom visual editing behavior
You can customize how your website preview responds to localization changes in Visual Editor using client-side JavaScript.
#
setLocale
Enables you to change the current locale, which will update the locale switcher.
window
.
stackbit
.
setLocale
(
locale
)
;
See the reference
for details.
#
stackbitLocaleChanged
Listen for an editor to interact with the locale switcher and change the current locale.
window
.
addEventListener
(
"stackbitLocaleChanged"
,
event
=>
{
const
locale
=
event
.
detail
.
locale
;
// Add custom behavior ...
}
)
;
This may be useful for redirecting the current page to a version with the newly-selected locale.
See the reference
for details.
Last updated: June 10, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_overview.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/overview/
Scraped_At: 2025-06-02T19:59:36.055727

Contact
Forums
Contact support
Netlify Visual Editor is an environment for content editors to work with structured content in a visual way. It is designed for composable architectures, and is compatible with any site framework and API-enabled content source.
Learn more about how Visual Editor works and what it can do for your team below. Or move on to
enable visual editing for your site
.
#
Key visual editing features
Content Source Interface:
an engine that makes content from any source editable with Visual Editor.
No production dependencies:
all required packages can be installed as development dependencies. You do not need to use Visual Editor in production.
Visual editing:
your site runs in a preview window inside Visual Editor. Content changes are reflected immediately in the preview.
Two-way content sync:
Visual Editor also listens for changes from content sources and updates the preview immediately.
Inline editing:
in addition to traditional form fields, Visual Editor makes it possible for editors to change content by clicking directly on elements in the preview window.
#
Learn how Visual Editor works
If you want a deeper understanding of how Visual Editor works, dig into our concept guides:
Visual Editor concepts overview
:
a deeper dive into how Visual Editor fits into your modern web stack and how its major elements work.
How the visual editor works
:
walk through the core concepts of how Visual Editor works by following a developer’s typical journey.
Content-driven development
:
empowering non-technical editors to make structural changes to a website without the help of a developer.
Reusable content
:
help content editors work faster by providing a starting point for content.
Structured content
:
how Visual Editor works with structured content, along with content modeling basics.
Two-way content sync
:
Visual Editor stores content back to the appropriate source, while also listening for changes from each source.
#
Supported tools, services, and frameworks
As part of the Netlify platform, Visual Editor supports most tools, services, and frameworks supported by Netlify. Find more information below on details specific to Visual Editor.
#
Supported frameworks
The visual editor is run in a Node-based environment by default, but can be customized to run any framework. Local development supports any framework that runs on a local port.
Enabling automatic content reloading (showing content updates in real-time in the visual editor UI) may require additional code and configuration in some frameworks. See
framework integration guides
for specific cases.
#
Supported content sources
Content Source Interface (CSI) supports any structured content source with read and write abilities via an API.
There are several content sources
supported by default
, though you can always
build your own CSI module
or
contact us
for additional support.
#
Unsupported tools
Visual Editor is designed to be composable and flexible, and we’re always working to expand our integrations. If your tool isn’t supported,
get in touch
to discuss your needs.
It is likely that if we aren’t already working on support for your desired integration, you can create the necessary support through code and configuration.
Last updated: January 29, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_personalization.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/personalization/
Scraped_At: 2025-06-02T19:59:36.964422

Personalization Example
Personalization example built with Next.js, using Contentful to store content and Ninetailed for audience control.
Check out the example code
###End of file##

-------- visual-editor_preview-controls.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/preview-controls/
Scraped_At: 2025-06-02T19:59:37.916996

Contact
Forums
Contact support
Preview controls enable content editors to adjust some given context within the preview, without the need to edit the source content. Preview controls are fields that only affect the preview in the current context, and do not affect the source content or context for other editors.
This is useful in a number of scenarios, such as:
User-context behavior, such as light/dark modes based on operating system preferences
Editor-only insights, such as showing warnings for missing content
#
How preview controls work
Most features that customize the visual editing experience require a definition with Visual Editor configuration file. Preview controls are unique in that they are handled exclusively on the client side.
The injected JavaScript snippet looks for a
stackbitPreviewControls
object on the
window
object, as an array of individual control definitions.
These controls are then rendered in the proper context in Visual Editor. And when an editor changes the value of a control, the
onChange
callback is triggered, which can be used to update the preview in any way.
#
Control contexts
There are two types of contexts for preview controls:
global
and
field
. These contexts determine where the control is rendered.
#
Global context
The global context is rendered in the top bar of Visual Editor, available on all pages. This is useful for controls that affect the entire preview, such as a light/dark mode toggle.
#
Field context
The field context requires additional information and has multiple rendering locations. A content source and a document within that source must be specified. Without further details, the control is shown in the page editor, near the title of the document.
If a field path is provided, the control is rendered in the page editor, near the field.
#
Usage example
Here is a simple example to demonstrate how preview controls can be used.
#
Light/Dark toggle with React
When working with a React framework, you can interact with the global
window
object through a
useEffect
hook. This also provides the ability to use TypeScript and ensure the control objects are properly defined.
This is a Next.js example that defines a
theme
control, which allows editors to toggle between light and dark mode, directly on the
_app
component.
//_app.ts
import
type
{
PreviewControl
}
from
'@stackbit/types'
import
{
useEffect
,
useState
}
from
'react'
import
'styles.css'
function
MyApp
(
{
Component
,
pageProps
}
)
{
const
[
currentTheme
,
setCurrentTheme
]
=
useState
<
'light'
|
'dark'
>
(
'light'
)
useEffect
(
(
)
=>
{
if
(
typeof
window
===
'undefined'
)
return
const
themeControl
:
PreviewControl
=
{
name
:
'theme'
,
label
:
'Theme'
,
context
:
'global'
,
type
:
'enum'
,
options
:
[
{
value
:
'light'
,
label
:
'Light'
}
,
{
value
:
'dark'
,
label
:
'Dark'
}
,
]
,
required
:
true
,
value
:
currentTheme
,
onChange
:
(
value
)
=>
{
console
.
log
(
'theme changed to'
,
value
)
setCurrentTheme
(
value
as
'light'
|
'dark'
)
}
,
}
const
myWindow
=
window
as
any
myWindow
.
stackbitPreviewControls
=
[
themeControl
]
return
(
)
=>
{
myWindow
.
stackbitPreviewControls
=
[
]
}
}
,
[
currentTheme
]
)
return
(
<
div
      style
=
{
{
backgroundColor
:
currentTheme
===
'dark'
?
'#444444'
:
'#ffffff'
,
}
}
>
{
/* ... */
}
<
/
div
>
)
}
export
default
MyApp
Tip
This example was written for simplicity. In a production-ready application, it's typically a better practice to define a custom hook to abstract the common properties, making it easier to add controls throughout the application.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_sitemap-navigator.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/sitemap-navigator/
Scraped_At: 2025-06-02T19:59:38.786251

Contact
Forums
Contact support
Populating the sitemap navigator allows you to use it for navigating website pages. The sitemap navigator provides a single point from which to access all editable pages on a website.
#
Navigate the sitemap
The sitemap provides two ways to navigate:
Tree view
Searching page names and paths
#
Tree view
The sitemap is built in a hierarchical way using the
urlPath
from page documents. (More on this below.)
It is collapsed by default, so that only top-level pages are visible. Each page can be expanded and collapsed as needed.
#
Search pages
On larger sites, it's usually easier to search for a page. The search field is automatically focused when opening the sitemap. Search values query a page document's
title
and
urlPath
properties.
#
Populate the sitemap
The sitemap will be populated by default, according to your content schema. If the slug of the page is not part of the content schema, you need to
override the default sitemap behavior
.
#
Default sitemap from pages
By default, the sitemap is populated by retrieving the
urlPath
value from all documents of models with the
type
property set to
page
.
If your content source uses inferred schemas (most headless CMSs) or does not have the
concept of pages
, you need to extend the models that represent pages.
Make sure the
name
of the page model object corresponds to the name in the json schema that appears in the headless CMS.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
contentSources
:
[
// ...
]
,
modelExtensions
:
[
{
name
:
"page"
,
type
:
"page"
,
urlPath
:
"/{slug}"
}
,
{
name
:
"post"
,
type
:
"page"
,
urlPath
:
"/blog/{slug}"
}
]
}
)
;
In this case, all pages and posts will show up in the sitemap.
#
Custom sitemap
To override default behavior, use the
siteMap
property.
The
siteMap
property provides an array of
SiteMapEntry
objects. These objects can specify URL paths or be tied directly to a document. We suggest using TypeScript to introspect the expected properties.
Here’s an example that implements a similar approach to the default sitemap behavior. To ensure
stableId
is set to a value that will not change, the example includes logic to set a unique
pageId
for each page, if one doesn’t exist already. The
pageId
is then used for the
stableId
when generating the
siteMap
.
// stackbit.config.ts
import
{
defineStackbitConfig
,
getLocalizedFieldForLocale
,
SiteMapEntry
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
// ...
]
,
// 1: add the `pageId` field here
modelExtensions
:
[
{
name
:
"page"
,
type
:
"page"
,
urlPath
:
"/{slug}"
,
fields
:
[
{
name
:
"pageId"
,
type
:
"string"
,
hidden
:
true
}
]
}
]
,
// 2: add this method to create the ID when creating a page
async
onContentCreate
(
{
object
,
model
}
)
{
if
(
model
.
type
!==
"page"
)
{
return
object
;
}
// for pages that already have a pageId field, use that value; if not, generate one
const
hasPageIdField
=
!
!
model
.
fields
?.
find
(
field
=>
field
.
name
===
"pageId"
)
;
if
(
hasPageIdField
&&
!
object
.
pageId
)
{
object
.
pageId
=
Date
.
now
(
)
.
toString
(
)
;
}
return
object
;
}
,
siteMap
:
(
{
documents
,
models
}
)
=>
{
const
pageModels
=
models
.
filter
(
m
=>
m
.
type
===
"page"
)
.
map
(
m
=>
m
.
name
)
;
return
documents
.
filter
(
d
=>
pageModels
.
includes
(
d
.
modelName
)
)
.
map
(
document
=>
{
// 3: use the pageId value for the stableId
const
slugField
=
document
.
fields
.
slug
.
type
===
"slug"
?
document
.
fields
.
slug
:
undefined
;
const
pageIdField
=
document
.
fields
.
pageId
.
type
===
"string"
?
document
.
fields
.
pageId
:
undefined
;
const
slug
=
getLocalizedFieldForLocale
(
slugField
)
;
const
pageId
=
getLocalizedFieldForLocale
(
pageIdField
)
;
if
(
!
slug
.
value
||
!
pageId
.
value
)
return
null
;
const
urlPath
=
"/"
+
slug
.
value
.
replace
(
/
^\/+
/
,
""
)
;
return
{
stableId
:
pageId
.
value
,
urlPath
,
document
,
isHomePage
:
urlPath
===
"/"
}
;
}
)
.
filter
(
Boolean
)
as
SiteMapEntry
[
]
;
}
}
)
;
Last updated: November 4, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_tree-view.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/tree-view/
Scraped_At: 2025-06-02T19:59:39.681788

Contact
Forums
Contact support
A tree view represents the site content within a controlled, hierarchical view in the content editor.
After configuring a content source, Visual Editor automatically lists models in the
content editor
, separated by model type (only
page
and
data
models are shown).
A tree view can be added using the
treeViews
property
, which provides the ability to create a customized representation of the site content.
#
Tree node types
Nodes can be one of two types:
Text Node:
A label that groups multiple documents together.
Document Node:
A node that represents a document, which can be edited from the document list on the right side of the screen.
See
the reference
for how the objects differ between the node types.
#
Build a tree
Building a tree typically involves fetching and filtering documents, then building a recursive list of
TreeViewNode
objects
.
#
Display children
As nodes in the tree are highlighted, their children are displayed in the panel to the right of the tree, providing the option to edit document nodes.
Note that
all root nodes must have
children
, otherwise the tree will not be rendered.
#
Edit documents
Document nodes can be edited by clicking the Edit button when they appear in the panel on the right (when their parents is the active tree item).
#
Fetch documents
The typical pattern for building a tree begins with fetching content from the site. This is usually done via the
getDocuments()
method provided to the
treeViews
within the options parameter.
export
default
defineStackbitConfig
(
{
treeViews
:
async
options
=>
{
const
allPages
=
options
.
getDocuments
(
)
.
filter
(
document
=>
document
.
modelName
===
"Page"
)
;
//
// Build the tree ...
//
}
}
)
;
#
Examples
Here are a few very simple examples to get started. Both were built using Git CMS, but can be applied to any content source.
#
List of page documents
This example creates a root node called "Site Pages" and lists all document of model
Page
under it.
//stackbit.config.ts
import
{
defineStackbitConfig
,
DocumentWithSource
,
TreeViewNode
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
/* ... */
]
,
treeViews
:
async
(
{
getDocuments
}
)
=>
{
const
children
:
TreeViewNode
[
"children"
]
=
getPages
(
getDocuments
(
)
)
.
map
(
document
=>
(
{
document
,
label
:
getFieldValue
(
document
,
"title"
)
}
)
)
;
return
[
{
label
:
"Site Pages"
,
children
,
stableId
:
"pages-tree"
}
]
as
TreeViewNode
[
]
;
}
}
)
;
function
getFieldValue
(
page
:
DocumentWithSource
,
field
:
string
)
{
const
fieldObject
=
page
.
fields
[
field
]
;
if
(
!
fieldObject
||
!
(
"value"
in
fieldObject
)
)
return
;
return
fieldObject
.
value
;
}
function
getPages
(
documents
:
DocumentWithSource
[
]
)
{
return
documents
.
filter
(
document
=>
document
.
modelName
===
"Page"
)
;
}
#
List pages by URL path
Here's a more complex example, which builds a tree based on a nested URL structure, similar to how the sitemap navigator behaves.
//stackbit.config.ts
import
{
defineStackbitConfig
,
DocumentWithSource
,
TreeViewNode
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
ssgName
:
"nextjs"
,
nodeVersion
:
"16"
,
contentSources
:
[
/* ... */
]
,
treeViews
:
async
(
{
getDocuments
}
)
=>
{
type
UrlTree
=
{
[
key
:
string
]
:
UrlTreeNode
;
}
;
type
UrlTreeNode
=
{
id
:
string
;
document
?
:
DocumentWithSource
;
slug
?
:
string
;
children
?
:
UrlTree
;
}
;
type
ReducedUrlTree
=
{
tree
:
UrlTree
;
urlPath
?
:
string
;
}
;
let
urlTree
:
UrlTree
=
{
}
;
getPages
(
getDocuments
(
)
)
.
forEach
(
page
=>
{
const
urlParts
=
getUrlParts
(
page
)
;
let
docNode
;
urlParts
.
reduce
<
ReducedUrlTree
>
(
(
acc
,
part
)
:
ReducedUrlTree
=>
{
const
id
=
acc
.
urlPath
?
`
${
acc
.
urlPath
}
__
${
part
}
`
:
part
;
if
(
!
acc
.
tree
[
part
]
)
acc
.
tree
[
part
]
=
{
id
}
;
if
(
!
acc
.
tree
[
part
]
.
children
)
acc
.
tree
[
part
]
.
children
=
{
}
;
docNode
=
acc
.
tree
[
part
]
;
return
{
tree
:
acc
.
tree
[
part
]
.
children
||
{
}
,
urlPath
:
id
}
;
}
,
{
tree
:
urlTree
}
)
;
docNode
.
document
=
page
;
docNode
.
slug
=
urlParts
[
urlParts
.
length
-
1
]
;
}
)
;
function
pagesTree
(
tree
?
:
UrlTree
)
:
TreeViewNode
[
]
{
if
(
!
tree
||
Object
.
keys
(
tree
)
.
length
===
0
)
return
[
]
;
return
Object
.
entries
(
tree
)
.
map
(
(
[
slug
,
node
]
)
=>
{
const
children
=
pagesTree
(
node
.
children
)
;
const
label
=
slug
===
"/"
?
"Home Page"
:
`
/
${
slug
}
`
;
if
(
node
.
document
)
{
return
{
document
:
node
.
document
,
children
,
label
}
;
}
return
{
label
,
children
,
stableId
:
node
.
id
}
;
}
)
.
filter
(
Boolean
)
as
TreeViewNode
[
]
;
}
const
tree
:
TreeViewNode
[
]
=
[
{
label
:
"Site Pages"
,
children
:
pagesTree
(
urlTree
)
,
stableId
:
"pages-tree"
}
]
;
return
tree
;
}
}
)
;
function
getFieldValue
(
page
:
DocumentWithSource
,
field
:
string
)
{
const
fieldObject
=
page
.
fields
[
field
]
;
if
(
!
fieldObject
||
!
(
"value"
in
fieldObject
)
)
return
;
return
fieldObject
.
value
;
}
function
getPages
(
documents
:
DocumentWithSource
[
]
)
{
return
documents
.
filter
(
document
=>
document
.
modelName
===
"Page"
)
;
}
function
getUrlParts
(
page
:
DocumentWithSource
)
{
const
urlParts
=
`
/
${
getFieldValue
(
page
,
"_filePath_slug"
)
}
`
.
replace
(
/
^[\/]+
/
,
"/"
)
.
replace
(
/
\/index$
/
,
""
)
.
split
(
"/"
)
.
filter
(
Boolean
)
;
if
(
urlParts
.
length
===
0
)
urlParts
.
push
(
"/"
)
;
return
urlParts
;
}
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_troubleshoot.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/troubleshoot/
Scraped_At: 2025-06-02T19:59:40.621242

Contact
Forums
Contact support
Here you will find a collection of troubleshooting tips for common issues with Visual Editor.
#
Cannot find my site
There are a couple reasons you may not be able to find a site with visual editing enabled.
First, ensure that you have migrated any legacy projects with this
Official Support guide on connecting legacy projects with a deployed Netlify site
.
#
Missing site from visual editor dashboard
If you’re having trouble finding your site in the visual editor dashboard and your access to the site has not changed, then you may have encountered a migration error.
For help, you can reach out to
Support
or share your experience on our
Netlify Forum
.
If you’re a Content Editor or Publisher, you may want to reach out to a Developer or Owner who can check your site access and permissions.
#
Missing site from app.netlify.com
As a
Developer
or
Owner
, to find a site with visual editing enabled, go to your team’s
Projects
page and select a project with the visual editing icon or the
Open in visual editor
link.
Filter sites list
To filter your sites list for sites with the visual editor enabled, you can append
?visual_editor=true
to your sites list URL like this:
https://app.netlify.com/teams/{team_name}/projects/?visual_editor=true
.
#
Development server is stuck
Just as when you're working locally, there are a number of factors that may result in needing to restart your development server.
If you run into an issue in which Visual Editor or your website isn’t behaving as you’d expect, try this series of steps:
Refresh your browser:
Can be fastest option and often resolves minor issues.
Restart visual editor preview:
Second fastest option. Usually takes about as long as it does to boot your local development server.
From your site workspace in the visual editor, select the options icon next to your site name to find this option.
From your Site overview, go to
Project configuration
>
Visual Editor
>
General
. Then select
Restart visual editor
and
Restart visual editor preview
.
Restart visual editor container:
If you still haven’t cleared the issue, choose the
Restart visual editor container
option. This restarts the entire editing experience, which usually takes a few minutes to complete.
From your site workspace in the visual editor, select the options icon next to your site name to find this option.
From your Site overview, go to
Project configuration
>
Visual Editor
>
General
. Then select
Restart visual editor
to find this option.
If you’re still having trouble after following these steps, you can
contact us
.
#
Site preview doesn’t load
There could be a number of reasons why your preview isn't working properly. The subsections below outline the most common solutions. If these don't solve your issue,
contact support
.
#
Restart to fix temporary issues
If the preview was previously working but is experiencing issues, try restarting the server.
In local development, restart your framework server and the
stackbit dev
server.
Otherwise, choose the
Restart visual editor preview
option in the Netlify UI:
- From your site workspace in the visual editor, select the options icon next to your site name to find this option.
- From your Site overview, go to
Project configuration
>
Visual Editor
>
General
. Then select
Restart visual editor
and
Restart visual editor preview
.
If you can’t find this option, confirm you have the
Developer or Owner role and permissions
.
If you’re still having trouble after following these steps, you can
contact us
.
#
Address unique configuration options
Some frameworks require additional configuration options specific to that framework. Read the appropriate
framework guide
for required configuration for that framework.
#
Audit security headers
Visual Editor attempts to remove headers that block a site from loading in an iframe, which is how the preview is presented in Visual Editor.
In some cases, a header may be blocking Visual Editor from loading your site in the preview iframe. Open the console to identify the blocking header and, if possible, adjust.
Be sure to only apply changes in development.
If you can't identify the header or are not able to make this change,
contact us
so we can work together on a resolution.
#
Origin sensitivity
Your development server is accessed through a proxy in our application. Some development server configurations expect a specific origin or have other rules in place that Visual Editor application is not expecting.
This is typically caught and handled automatically, with the help of the
ssgName
configuration property.
If you believe this to be the issue, please
contact us
. We'll help resolve and put further checks in place to help other users.
#
Content source connection errors
When you are seeing an issue with content not loading or have received an error about connection issues with the CMS source, there are a few troubleshooting methods you can try.
#
Environment variables
When using
the
contentSources
property
to configure your content source, you are often required to use environment variables. Check that:
The environment variables you’re specifying in the code resolve to the expected value.
You’re using all required variables and options for that particular content source.
You can refer to the configuration guide within
the appropriate integration section
for a reference on how to configure that particular source.
To add, remove, or optionally to edit environment variables using the Netlify UI:
From your Site overview, go to
Project configuration
>
Visual Editor
>
Environment variables
. Note you must have the Developer or Owner role to access these settings.
Add, remove, or edit your variables. You can lock a variable to prevent others with access from changing the variable.
To confirm, select
Save and restart
. The visual editor container will automatically restart. This can take a few minutes.
#
Custom sources
If using a custom or experimental content source,
contact support
with details if you are having connection issues.
#
Application connections
Working with an external content source requires that you establish an authentication connection to be able to edit content.
You can confirm that the connection is established in your
account settings
.
#
Mismatched users
Some external content providers require that the writable API key match to the user account that is connected via Visual Editor.
If there is a possibility these are mismatched, disconnect and reconnect the account.
#
More resources
If you have additional concerns that aren’t answered in this doc, you can visit our
Forums
to find more information in our verified Support Guides and ask questions.
Last updated: May 13, 2025
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_version-control.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/version-control/
Scraped_At: 2025-06-02T19:59:41.635741

Contact
Forums
Contact support
When a content source module supports version control, Visual Editor provides the ability to view and restore previous versions of a document.
#
View & restore versions
When version control is enabled, the document editor displays a list of versions for the document.
Clicking on a version in the list populates the fields for that version of the document. Clicking
Restore
when viewing a version restores the document to that version.
Note the following from the image above:
Fields that are different from the current version are highlighted in blue.
The version can be restored or the editor can be closed without restoring the version by using the
Restore
and
Don't restore
buttons.
Switch to other versions by opening the versions list.
#
Restore a version
When a version is restored, the document is updated with the values from that version.
The updated list of versions is then again retrieved using the
getDocumentVersions
method. The affect of restoring a version on the list of versions is determined by the implementation of the
getDocumentVersions
method, which is dependent upon the capabilities of the content source.
#
Supported content sources
This feature is supported in the following content sources:
Contentful
DatoCMS
Sanity
#
Implement version control
When implementing
a custom CSI module
, version control is enabled when the
getDocumentVersions
method is implemented.
#
Retrieve versions
When a document is active in a relevant editing context, the
getDocumentVersions
method is called to retrieve the list of versions for the document.
Some content sources may not provide the ability to attach a
document
object to each version without additional API requests. In these cases, it is not necessary to populate the
document
object.
#
Display a version
When a previous version is previewed, if the
document
object was attached to that version in the
getDocumentVersions
response, the
document
object is used to populate the field values in the editor.
If the
document
object was not attached to the version, the
getDocumentForVersion
method is called to retrieve the document for the selected.
#
References
DocumentVersion
getDocumentVersions
getDocumentForVersion
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/
Scraped_At: 2025-06-02T19:59:42.273799

Contact
Forums
Contact support
Understand methods for adjusting code and content in Visual Editor.
#
Editing methods
The visual editor is an editing application that provides three different ways to directly edit code and content.
Page Editor
: editing panel that changes based on the context of the current page in the preview.
Content Editor
: classic CMS mode, with the ability to edit content within page and data models.
Inline Editor
: highlights around elements in the preview that enable direct, in-place editing.
While inline editing is done directly on the preview, all others are enabled through icons on the left sidebar in the visual editing application.
#
Page editor
The page editor is a panel on the left side of the screen that changes context based on actions taken within the preview and sitemap navigator.
Learn more about Visual Editor’s page editor
#
Content editor
The content editor provides a means to quickly edit structured pages and data objects. This is similar to traditional form-based editing within a CMS.
Learn more about Visual Editor’s content editor
#
Inline editor
Visual Editor provides the ability to make changes directly in the preview by clicking directly on editable content.
Learn more about Visual Editor’s inline editor
#
Editor extensions
These editing methods can be further customized with various editing features.
Sidebar Shortcuts
customize sidebar buttons in Visual Editor.
Field Controls
: how form fields are displayed for content editors.
Field Groups
: tidy up form fields into tabbed groups.
Custom Fields
: bring your own field controls.
#
Sidebar shortcuts
Custom buttons can be added to the sidebar as direct links and shortcuts to content or editing controls.
Learn more about customizing the sidebar
#
Field controls
Visual Editor infers field editor controls as best as possible. Fields can then be further customized through model extensions.
Learn more about customizing field controls
#
Field groups
Fields can be broken up into tabbed groups for better organization when using the page or content editors.
Learn more about grouping fields
#
Custom fields
When the default field controls are not enough, you can bring your own custom field controls.
Learn more about custom fields
#
Additional features
This section contains additional features to aid with visual editing.
#
Document statuses
Document titles are paired with labels (in some cases) to indicate their current status, providing a quick visual representation of the state of content.
Learn more about document status labels
Last updated: July 15, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_content-editor.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/content-editor/
Scraped_At: 2025-06-02T19:59:44.031125

Contact
Forums
Contact support
The content editor is a way to quickly edit structured pages and data objects. This is similar to traditional form-based editing within a CMS.
The editor distinguishes between models (content types, collections, etc.) that represent pages and those that may globally affect any page on the site.
The editor can always navigate content by content type using the list view. Additionally, teams have the option of implementing a dedicated
tree view
, for example, for sitemap navigation or to navigate content using categories.
#
Configure columns
The table in the content editor can be customized by clicking on the gear icon to the right of the column headers.
The columns available are dependent on the current context.
Document metadata is always available.
When filtering by a content type, fields specific to that content type will also be available.
This selection
is unique to each user
and will not affect views for other users.
#
Filter documents
Various filtering methods make it easier to pinpoint specific documents (entries, items, etc.) within the available models.
#
Search
Using the search field will look into all documents (of all content types) and return results for that search.
To get all the matches for a particular content type, use the Type filter:
Within a model, searching filters the list of visible documents based on the query.
#
Field filters
It is possible to filter content entries both by metadata (e.g. the shared
createdAt
property, document status, etc.) or by individual fields, including references (e.g. posts with a specific author).
#
Filter control
Field filters are controlled by the filter button next to the search input.
Add as many filters as necessary to pinpoint the right subset of content.
#
Available field controls
The available fields change context based on documents available in the current view:
When viewing documents within a model, fields for that model will be shown.
When viewing a models list, Visual Editor metadata fields will be available (
createdAt
,
updatedAt
,
status
,
scheduledForPublish
,
scheduledDate
).
Content source exceptions
Git CMS
doesn’t provide accurate metadata for “Created” and “Modified” dates by default since data is only read from your working branch. These columns are therefore not available in the content editor.
#
Multiple filters
Filters can be combined with an option to match
any
(OR) or
all
(AND) of the filters.
When more than two filters are used, all filters inherit the first chosen operator (AND/OR).
#
Filter groups
Filters can be grouped together to create more complex filters.
When using groups with multiple filters, the group's operator will always be the inverse of the first filter's operator. For example, if the filters are using AND, the filters within each group will use OR.
#
Filter references
When filtering by referenced objects, you’ll be prompted to select existing content entries. Opening the select dropdown will trigger a modal from which you can choose the appropriate entry.
After choosing the appropriate document(s) and clicking Select, the selected documents will appear in the filter control.
#
Visible models
Visual Editor shows
page
and
data
models in the content tab, determined by the
type
property set on the model.
Getting models to appear in the pages section often requires using the
modelExtensions
configuration property to set the
type
property for page models.
#
Content source exceptions
Some content sources have specific behavior on how models are inferred by Visual Editor. Refer to
content source integrations
for more information.
Last updated: October 11, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_custom-fields.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/custom-fields/
Scraped_At: 2025-06-02T19:59:46.161124

Contact
Forums
Contact support
Custom fields provide the ability to extend the default set of field types and controls available in the page and content editors.
For example, suppose you want to add a field to the page editor that allows the user to select an emoji. Instead of creating an enum field and presenting emojis in a dropdown menu or thumbnail images, you can create a custom field type that renders the emojis directly.
#
Types of custom fields
There are two types of custom fields:
Inline Fields
:
Controls that are rendered directly in the form.
Modal Fields
:
The form presents an "Open" button, from which a modal window opens with the custom control.
#
Inline fields
Inline fields are rendered directly in the form. They are useful for simple controls that do not require a lot of space or that resemble standard form controls.
#
Modal fields
Modal fields appear as an
Open
button within the form.
Clicking this button opens a modal in which the form control is rendered. Visual Editor automatically includes the label and functionality for closing the modal, although this can be customized.
These types of controls are useful for more complex controls that require more space or that would typically be used within a dialog window.
#
How custom fields work
Custom fields are built either as an HTML file or the JavaScript bundle and presented in Visual Editor through an iframe. They can bring their own styling and use
JavaScript to hook into the editor and data flow.
#
Field types vs control types
Custom fields can be defined against any Visual Editor field type by specifying the control type and a path to the HTML file.
The custom field should then set the value of the field to match the expected format of the field type.
// stackbit.config.ts
import
{
ObjectModel
}
from
"@stackbit/types"
;
export
const
HeroSection
:
ObjectModel
=
{
name
:
"HeroSection"
,
type
:
"object"
,
fields
:
[
{
type
:
"string"
,
name
:
"title"
,
label
:
"Heading"
}
,
{
type
:
"string"
,
name
:
"emoji"
,
controlType
:
"custom-inline-html"
,
controlFilePath
:
".stackbit/fields/emoji.html"
}
]
}
;
In the example above, the
emoji
field is defined as a
string
field type, but the
controlType
is set to
custom-inline-html
. This field is presented as an iframe using the contents of
.stackbit/fields/emoji.html
(relative to the project root).
See the configuration reference for usage of
controlType
and
controlFilePath
.
#
Hook into the editor
When Visual Editor first loads, it looks for custom fields and injects a
control.js
script into the HTML file. This controls when the script defined in the HTML file (noted below) fires.
The HTML file should include a script that hooks into the editor's data flow. When the field first appears, Visual Editor looks to call a global
stackbit.onUpdate()
function with
an object of useful properties
.
On the initial call, the
init
property is set to
true
, which can be used as a signal to attach event listeners to elements within the custom field.
Using the emoji example, each emoji could be presented as a button, and would update the field's value when the button is clicked.
<
script
>
window
.
stackbit
=
window
.
stackbit
||
{
}
;
window
.
stackbit
.
onUpdate
=
options
=>
{
if
(
options
.
init
)
{
const
buttons
=
document
.
querySelectorAll
(
"button"
)
;
buttons
.
forEach
(
button
=>
button
.
addEventListener
(
"click"
,
event
=>
{
// Update the field's value ...
}
)
)
;
}
}
;
</
script
>
Tip
It is safest to manually initialize the
window.stackbit
object, as it may not be available when the script is executed.
See below for a more complete example.
#
Use JavaScript bundle
When
controlType
is set to either
custom-inline-script
or
custom-modal-script
, the visual editor expects that value of
controlFilePath
is a link to the JavaScript bundle.
The visual editor will cache the code of the control, making it render faster. Also,
React
and
ReactDOM
is exposed within the iframe, which
decreases and optimizes the bundle size of the custom control.
Read more about
controlFilePath
.
#
Best practices
This section provides some common practices for working with custom fields, before moving on to an example.
#
HTML file location
The HTML file can be placed anywhere in the project. Because Visual Editor plays no role in production, we recommend that this be placed in a directory that isn’t published to the web and that doesn’t interfere with your application.
In the examples shared in this doc, we’re using a
.stackbit
directory in the project root. This is typically where we recommend putting Visual Editor-specific files.
#
Add styles
In most cases, a custom field is going to want to bring its own style for an enhanced editing experience. The best way to do this is either to write styles directly in the HTML file or to link to an external CSS file. See the next section for an example.
#
Use external assets
The HTML file can import CSS and JavaScript files from anywhere in the project repository. However, it's often easiest to place it in the same directory as the HTML file.
<!
DOCTYPE
html
>
<
html
lang
=
"
en
"
>
<
head
>
<!-- ... -->
<
link
rel
=
"
stylesheet
"
href
=
"
emoji.css
"
/>
</
head
>
<
body
>
<!-- ... -->
<
script
src
=
"
emoji.js
"
>
</
script
>
</
body
>
</
html
>
#
Avoid public directories
Because sites typically don’t use Visual Editor in production, we recommend that you avoid placing custom field files in directories that are published to the web.
While you could remove these files during the build, it’s best to avoid the risk of accidentally publishing them since there’s no benefit to doing so, and may be risky if the files contain sensitive information.
#
Emoji field example
This example shows how to create a custom emoji field on a hero component. The field enables editors to select from a set of five emojis. The stored values is a string of descriptive text representing the emoji. (This value would then be used to map to the emoji on the front end.)
Note
All of these files would be contained in a
.stackbit/fields
directory.
Loading error: Refresh the page to access this code sample
<!
DOCTYPE
html
>
<
html
lang
=
"
en
"
>
<
head
>
<
meta
charset
=
"
UTF-8
"
/>
<
meta
name
=
"
viewport
"
content
=
"
width=device-width, initial-scale=1.0
"
/>
<
title
>
Emoji Field
</
title
>
<
link
rel
=
"
stylesheet
"
href
=
"
emoji.css
"
/>
</
head
>
<
body
>
<
div
class
=
"
grid
"
>
<
button
data-value
=
"
grinning
"
>
😃
</
button
>
<
button
data-value
=
"
slightly_smiling_face
"
>
🙂
</
button
>
<
button
data-value
=
"
neutral_face
"
>
😐
</
button
>
<
button
data-value
=
"
slightly_frowning_face
"
>
🙁
</
button
>
<
button
data-value
=
"
frowning_face
"
>
☹️
</
button
>
</
div
>
<
script
src
=
"
emoji.js
"
>
</
script
>
</
body
>
</
html
>
body
{
max-width
:
100%
;
}
button
{
font-size
:
2rem
;
padding
:
0.5rem
;
background
:
none
;
cursor
:
pointer
;
border
:
1px solid #cfcfcf
;
border-radius
:
0.25rem
;
line-height
:
1
;
transition
:
background 0.3s ease
;
}
button.active
{
border-color
:
teal
;
}
button:hover
{
background
:
#efefef
;
}
.grid
{
display
:
flex
;
gap
:
1rem
;
}
// Safely initialize the stackbit object
window
.
stackbit
=
window
.
stackbit
||
{
}
;
window
.
stackbit
.
onUpdate
=
options
=>
{
// Helper function to get the current value of the field. This is most useful
// when a document has nested content fields.
function
getCurrentValue
(
)
{
try
{
return
options
.
fieldPath
.
reduce
(
(
acc
,
curr
)
=>
{
const
newValue
=
acc
[
curr
]
;
if
(
"items"
in
newValue
)
return
newValue
.
items
;
if
(
"fields"
in
newValue
)
return
newValue
.
fields
;
return
newValue
;
}
,
options
.
document
.
fields
)
.
value
;
}
catch
(
err
)
{
return
;
}
}
// Use the init option to attach event listeners to elements within the custom
// field.
if
(
options
.
init
)
{
const
currentValue
=
getCurrentValue
(
)
;
// Highlight the currently selected emoji
if
(
currentValue
)
{
document
.
querySelector
(
`
button[data-value="
${
currentValue
}
"]
`
)
.
classList
.
add
(
"active"
)
;
}
// Set the desired size of the control.
options
.
setDesiredControlSize
(
{
width
:
350
,
height
:
60
}
)
;
// Attach click event listeners to each button
document
.
querySelectorAll
(
"button"
)
.
forEach
(
button
=>
button
.
addEventListener
(
"click"
,
event
=>
{
const
value
=
event
.
target
.
dataset
.
value
;
// Update the document in the content source with the selected value
options
.
updateDocument
(
{
operations
:
[
{
opType
:
"set"
,
fieldPath
:
options
.
fieldPath
,
modelField
:
options
.
modelField
,
field
:
{
type
:
options
.
fieldModel
?.
type
??
"string"
,
value
}
}
]
}
)
// Highlight the selected emoji after content has been updated
.
then
(
(
)
=>
{
document
.
querySelectorAll
(
"button"
)
.
forEach
(
button
=>
button
.
classList
.
remove
(
"active"
)
)
;
document
.
querySelector
(
`
button[data-value="
${
value
}
"]
`
)
.
classList
.
add
(
"active"
)
;
}
)
.
catch
(
err
=>
{
console
.
error
(
"Could not update emoji field"
,
err
)
;
}
)
;
}
)
)
;
}
}
;
#
Emoji field React example
This example shows how to create the same emoji component, but using React.
This control can be used when setting
controlType
to either
custom-inline-script
or
custom-modal-script
.
Loading error: Refresh the page to access this code sample
module
.
exports
=
{
entry
:
'./index.tsx'
,
output
:
{
path
:
path
.
resolve
(
__dirname
,
'dist'
)
,
filename
:
'index.js'
}
,
// decrease bundle size by using React as external dependency
externals
:
{
react
:
'React'
,
'react-dom'
:
'ReactDOM'
}
,
externalsType
:
'global'
}
;
body
{
max-width
:
100%
;
}
button
{
font-size
:
2rem
;
padding
:
0.5rem
;
background
:
none
;
cursor
:
pointer
;
border
:
1px solid #cfcfcf
;
border-radius
:
0.25rem
;
line-height
:
1
;
transition
:
background 0.3s ease
;
}
button.active
{
border-color
:
teal
;
}
button:hover
{
background
:
#efefef
;
}
.grid
{
display
:
flex
;
gap
:
1rem
;
}
import
*
as
React
from
"react"
;
import
*
as
ReactDOM
from
"react-dom/client"
;
const
Emojis
=
[
{
name
:
"grinning"
,
emoji
:
"😃"
}
,
{
name
:
"slightly_smiling_face"
,
emoji
:
"🙂"
}
,
{
name
:
"neutral_face"
,
emoji
:
"😐"
}
,
{
name
:
"slightly_frowning_face"
,
emoji
:
"🙁"
}
,
{
name
:
"frowning_face"
,
emoji
:
"☹️"
}
]
;
function
Component
(
)
{
const
[
value
,
setValue
]
=
React
.
useState
(
""
)
;
React
.
useEffect
(
(
)
=>
{
// Safely initialize the stackbit object
if
(
!
window
.
stackbit
)
{
window
.
stackbit
=
{
}
;
}
const
handler
=
(
options
)
=>
{
setValue
(
options
.
documentField
?.
value
??
""
)
;
if
(
options
.
init
)
{
// Set the desired size of the control.
options
.
setDesiredControlSize
(
{
width
:
350
,
height
:
60
}
)
;
}
}
;
if
(
window
.
stackbit
.
options
)
{
window
.
stackbit
.
options
.
setDesiredControlSize
(
{
width
:
100
,
height
:
600
}
)
;
handler
(
window
.
stackbit
.
options
)
;
}
window
.
stackbit
.
onUpdate
=
handler
;
return
(
)
=>
{
delete
window
.
stackbit
!
.
onUpdate
;
}
;
}
,
[
]
)
;
return
(
<
div
class
=
"grid"
>
{
Emojis
.
map
(
(
{
emoji
,
name
}
)
=>
(
<
button
          key
=
{
name
}
className
=
{
value
===
name
?
"active"
:
""
}
onClick
=
{
(
)
=>
{
const
options
=
window
.
stackbit
.
options
;
if
(
!
options
)
{
return
;
}
options
.
updateDocument
(
{
operations
:
[
{
opType
:
"set"
,
fieldPath
:
options
.
fieldPath
,
modelField
:
options
.
modelField
,
field
:
{
type
:
options
.
fieldModel
?.
type
??
"string"
,
value
}
}
]
}
)
.
catch
(
(
err
)
=>
{
console
.
error
(
"Could not update emoji field"
,
err
)
;
}
)
;
}
}
>
{
emoji
}
<
/
button
>
)
)
}
<
/
div
>
)
;
}
const
root
=
document
.
getElementById
(
"root"
)
??
document
.
body
;
ReactDOM
.
createRoot
(
root
)
.
render
(
<
Component
/
>
)
;
Last updated: July 15, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_field-controls.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/field-controls/
Scraped_At: 2025-06-02T19:59:47.946720

Contact
Forums
Contact support
Control how form fields are displayed for content editors.
Visual Editor infers field editor controls as best as possible. Fields can then be further customized through model extensions.
#
Automatic control inference
Every content source supports some limited set of
field types
for their editing interface.
Visual Editor offers a superset of every officially-supported content source. There is a default control type that can be inferred based on the defined schema within the source.
Mappings from content source fields to Visual Editor controls are unique to each content source and derived from the content source module.
#
Customize control types
Field controls can be customized by extending models through the
modelExtensions
property, or controlled directly if using Git content source.
For example, a field in a content source that is a string, chosen from a limited set of options. Visual Editor will likely render this as an
enum
field with a
dropdown
control type.
#
Example: thumbnail options
Here's a simplified example that results in the field controls shown at the top of this document. A
grid
model has an
arrangement
field being extended to use thumbnail images rather than a dropdown.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
modelExtensions
:
[
{
name
:
"grid"
,
fields
:
[
{
name
:
"arrangement"
,
controlType
:
"thumbnails"
,
options
:
[
{
label
:
"Two column grid"
,
value
:
"two-col-grid"
,
thumbnail
:
"https://assets.stackbit.com/components/images/default/two-col-grid.png"
}
,
{
label
:
"Three column grid"
,
value
:
"three-col-grid"
,
thumbnail
:
"https://assets.stackbit.com/components/images/default/three-col-grid.png"
}
// ...
]
}
]
}
]
}
)
;
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_field-groups.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/field-groups/
Scraped_At: 2025-06-02T19:59:49.586382

Contact
Forums
Contact support
Tidy up form fields into tabbed groups.
Groups are a great way to clean up the editing interface, especially when a model has a large number of fields.
#
Default field group
Every field is part of the
Content
field group by default, and the tabs are only shown if there is an additional group defined.
Fields that are to remain in the Content group do not need to be extended.
You only have to configure those which you wish to move into a custom group.
#
Customize field groups
Field groups get adding by extending a model with the
fieldGroups
property, and then specifying the
group
for the appropriate field.
#
Use icons
There is a select set of icons available to use for each tab in the group, if you choose. This list is available
in our reference docs
.
#
Example: add styles group
Here's an example that adds a
styles
field group to a
hero
model, and then places a
bgColor
field within that group.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
modelExtensions
:
[
{
name
:
"hero"
,
fieldGroups
:
[
{
name
:
"styles"
,
label
:
"Styles"
,
icon
:
"palette"
}
]
,
fields
:
[
{
name
:
"bgColor"
,
group
:
"styles"
}
]
}
]
}
)
;
The result would show Content and Styles tabs, similar to the image at the top of this document.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_inline-editor.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/inline-editor/
Scraped_At: 2025-06-02T19:59:51.768821

Contact
Forums
Contact support
Inline editing removes the need for content editors to understand the structure of the content by enabling them to click directly on elements in the preview to make changes.
This guide introduces how inline editing works through HTML element annotations, along with common patterns for working these annotations. See
the reference guide
for further usage instruction.
#
How inline editing works
Inline editing is made possible through
annotating
components. This involves adding one or more data attributes to help Visual Editor map content in the preview to the proper location in the proper content source, using the site's content schema.
Loading error: Refresh the page to access this code sample
export
const
ComposablePage
=
(
props
)
=>
{
return
(
<
div
data-sb-object-id
=
{
props
.
id
}
>
<
h1
data-sb-field-path
=
"
title
"
>
{
props
.
title
}
</
h1
>
</
div
>
)
}
<
div
data-sb-object-id
=
"
1
"
>
<
h1
data-sb-field-path
=
"
title
"
>
My Page Title
</
h1
>
</
div
>
#
Target generated HTML
It's important to note that Visual Editor works with the HTML code
generated
by your framework. It does not read the component code directly.
This means that you have to take care to understand how the HTML tree is built as a result of composing a page with framework-based components. More on this in
common patterns
below.
#
Annotation types
There are two properties that make up an annotation:
Object ID:
The uniquely-identifying value representing a document in a content source, typically defined using the
data-sb-object-id
attribute.
Field Path:
A field name or path representing the identifying value of the field in the content source where the content should be stored, typically defined using the
data-sb-field-path
attribute.
These properties work in tandem to help Visual Editor determine how to store content changes by first locating the proper document in the proper source, and then finding the field within that document’s model.
See the reference for specific usage details
#
Use the DOM tree
Annotations follow the structure of the DOM tree, setting the annotation scope for all descendants.
In the example above, the
<h1>
value was inferred to below to the document with ID
1
because the parent
<div>
set its scope.
In the example below, the
heading
field path is scoped to the document of ID matching the resolution of
props.id
, while
body
appears to have no scoped document and will prompt an error in the console.
// MyComponent.jsx
export
const
MyComponent
=
props
=>
{
return
(
<
>
<
div
data-sb-object-id
=
{
props
.
id
}
>
{
/* Scoped to `props.id` */
}
<
h2
data-sb-field-path
=
"
heading
"
>
{
props
.
heading
}
</
h2
>
</
div
>
{
/* Causes an error because there appears to be no scope for this field path. */
}
<
div
data-sb-field-path
=
"
body
"
dangerouslySetInnerHTML
=
{
{
__html
:
props
.
body
}
}
/>
</
>
)
;
}
;
Note
The
body
path "appears to have no scope" because Visual Editor reads the resulting HTML generated by your framework and not the component code itself.
If a ancestral component generated HTML with a
data-sb-object-id
attribute, then the
body
field path would be scoped to that object.
#
Work with object IDs
Object ID annotations are how Visual Editor identifies the document to edit for the current element, along with akk descendants of that element in the DOM tree.
#
Object ID exceptions
Most content sources make a document's uniquely-identifying value obvious. Content source modules use this value to represent the document ID whenever possible.
Exceptions to this are listed in the appropriate
content source integration guide
.
#
Rescope with Object IDs
Because we can take advantage of the DOM tree while annotating, this means you can rescope objects within other objects.
Suppose you had a post document that referenced an author document, and you wanted to be able to edit the author's name inline. You can rescope the document by adding a new object ID annotation while within the context of another document.
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
h1
data-sb-field-path
=
"
title
"
>
{
props
.
post
.
title
}
</
h1
>
<
div
data-sb-object-id
=
{
props
.
post
.
author
.
id
}
>
<
span
data-sb-field-path
=
"
name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
</
article
>
)
;
}
Note that
title
is within the content of the post, while
name
has been rescoped within the context of the author document.
#
Work with field paths
Field path annotations are how Visual Editor knows how to map content within elements on the screen to fields in the content source.
#
Map to model fields
Many websites contain components that do not have one-to-one parity to a data model. The properties for that component may not match the fields in the content schema, but may be transformed before being sent to the component as props.
However,
field names specified with
data-sb-field-path
must match
field names
in the schema
, and not another variables or property name used to render the value.
For example, assume you have a document in the content source with a structure like this:
{
"id"
:
"1"
,
"type"
:
"Post"
,
"title"
:
"Blog Post Title"
,
"body"
:
"<p>Hello World</p>"
}
And suppose you were using a component called
<Markdown />
that expected you to send the markdown string as a property called
content
. If you hard-coded the field path, this would not work as expected.
Loading error: Refresh the page to access this code sample
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
h1
data-sb-field-path
=
"
title
"
>
{
props
.
post
.
title
}
</
h1
>
<
Markdown
content
=
{
props
.
body
}
/>
</
article
>
)
;
}
export
function
Markdown
(
props
)
{
// Will not be editable unless the field name is `body` in the models
// making use of this component.
return
(
<
div
data-sb-field-path
=
"
body
"
dangerouslySetInnerHTML
=
{
{
__html
:
props
.
body
}
}
/>
)
;
}
This doesn't work unless the field name for the property in the model is
body
. In this case, you might want to expose the annotation as a prop.
// components/Markdown.tsx
export
function
Markdown
(
props
)
{
return
(
<
div
data-sb-field-path
=
{
props
.
annotation
||
"body"
}
dangerouslySetInnerHTML
=
{
{
__html
:
props
.
body
}
}
/>
)
;
}
#
Absolute vs relative field paths
In most cases with most content sources, an annotation consists of an ID and field name.
Some content sources allow for nesting content within a single document. (Git CMS is the typical example.) In this case,
objects
of some model may be nested within a
document
of another model. Consider this content structure:
{
"id"
:
"1"
,
"type"
:
"Post"
,
"author"
:
{
"name"
:
"Stephen King"
}
}
In this case,
author
is an embedded object, represented by a model, with a field called
name
. The author object has no ID value, and can only be edited through the post object.
When annotating components, you can use dot notation to drill down into nested components. And when a field path begins with a dot (
.
), it is assumed to be chained to its most recent ancestor. Otherwise, it is assumed to be an absolute path.
The two examples below would make
author.name
editable inline.
Loading error: Refresh the page to access this code sample
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
div
data-sb-field-path
=
"
author
"
>
<
span
data-sb-field-path
=
"
.name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
</
article
>
)
;
}
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
span
data-sb-field-path
=
"
author.name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
article
>
)
;
}
Note that this also works for arrays, where the index can follow a dot. Here's an example where a post had a list of authors:
Loading error: Refresh the page to access this code sample
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
div
data-sb-field-path
=
"
authors
"
>
{
props
.
post
.
authors
.
map
(
(
author
,
index
)
=>
(
<
span
data-sb-field-path
=
{
`
.
${
index
}
.name
`
}
>
{
props
.
post
.
author
.
name
}
</
span
>
)
)
}
</
div
>
</
article
>
)
;
}
<
article
data-sb-object-id
=
"
1
"
>
<
div
data-sb-field-path
=
"
authors
"
>
<
span
data-sb-field-path
=
"
.0.name
"
>
Stephen King
</
span
>
<
span
data-sb-field-path
=
"
.1.name
"
>
Dr. Seuss
</
span
>
</
div
>
</
article
>
#
Combine ID with field paths
In situations where you don't want to add an element just to specify an ID, you can include the ID value in a field path annotation by separating it from the path with a colon (
:
). Here's the example above, written in a single line.
export
function
Post
(
props
)
{
return
(
<
div
>
<
span
data-sb-field-path
=
{
`
${
props
.
post
.
id
}
:author.name
`
}
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
)
;
}
#
XPaths for advanced patterns
In situations that require advanced controls over field paths, you can append an
xpath
to the field path following a hash (
#
). Here's an example that makes the title editable, even though there are multiple other children.
export
function
Post
(
props
)
{
return
(
<
div
data-sb-field-path
=
"
title#text()[0]
"
>
{
props
.
title
}
<
span
>
...
</
span
>
</
div
>
)
;
}
See more cases for xpath values in
advanced patterns
below.
#
Common patterns
The following sections provide some instructions on the most frequently-used patterns when annotating components for inline editing.
#
Annotate nested objects
Use dot notation to build a chained path to the proper field. Field paths that start with a dot are automatically chained to their closest ancestor. These two examples achieve the same result.
Loading error: Refresh the page to access this code sample
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
div
data-sb-field-path
=
"
author
"
>
<
span
data-sb-field-path
=
"
.name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
</
article
>
)
;
}
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
span
data-sb-field-path
=
"
author.name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
article
>
)
;
}
#
Annotate list fields
List fields should use the index as a node in the field path.
Loading error: Refresh the page to access this code sample
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
div
data-sb-field-path
=
"
authors
"
>
{
props
.
post
.
authors
.
map
(
(
author
,
index
)
=>
(
<
span
data-sb-field-path
=
{
`
.
${
index
}
.name
`
}
>
{
props
.
post
.
author
.
name
}
</
span
>
)
)
}
</
div
>
</
article
>
)
;
}
<
article
data-sb-object-id
=
"
1
"
>
<
div
data-sb-field-path
=
"
authors
"
>
<
span
data-sb-field-path
=
"
.0.name
"
>
Stephen King
</
span
>
<
span
data-sb-field-path
=
"
.1.name
"
>
Dr. Seuss
</
span
>
</
div
>
</
article
>
#
Unable to use a parent element
When unable to use a parent element, the object ID value can be prefixed to the field path, separated by a colon (
:
).
export
function
Post
(
props
)
{
return
(
<
div
>
<
span
data-sb-field-path
=
{
`
${
props
.
post
.
id
}
:author.name
`
}
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
)
;
}
#
Nest fields within another object's scope
The context can be rescoped for an individual element by providing the ID with an absolute field path (as shown in the section above) or for all further descendants by annotating a new object ID.
Here's an example that rescopes all descendants of a div by specifying a new object ID.
export
default
function
Post
(
props
)
{
return
(
<
article
data-sb-object-id
=
{
props
.
post
.
id
}
>
<
h1
data-sb-field-path
=
"
title
"
>
{
props
.
post
.
title
}
</
h1
>
<
div
data-sb-object-id
=
{
props
.
post
.
author
.
id
}
>
<
span
data-sb-field-path
=
"
name
"
>
{
props
.
post
.
author
.
name
}
</
span
>
</
div
>
</
article
>
)
;
}
#
Advanced patterns
The practices shown above are enough to handle the majority of cases on most sites. The following cases occur with less frequency, but are essential for maintaining the flexibility to build the DOM how it best serves your project.
#
Multiple fields as the same child
It's often convenient to use multiple properties within a single element, such as combining an author's first and last names.
export
function
MyComponent
(
props
)
{
return
(
<
div
className
=
"
author
"
data-sb-field-path
=
"
first_name last_name
"
>
{
author
.
first_name
}
{
author
.
last_name
}
</
div
>
)
;
}
It's much easier to work with structured content when each property get its own element. Use an inline element like
<span>
and annotate each individually.
export
function
MyComponent
(
props
)
{
return
(
<
div
className
=
"
author
"
>
<
span
data-sb-field-path
=
"
first_name
"
>
{
author
.
first_name
}
</
span
>
<
span
data-sb-field-path
=
"
last_name
"
>
{
author
.
last_name
}
</
span
>
</
div
>
)
;
}
#
Elements with multiple children
When an element renders a field value as its direct text node child, but also includes other elements as children, use the xpath to specify the exact position of the rendered field value within the element.
export
function
MyComponent
(
props
)
{
return
(
<
div
data-sb-field-path
=
"
title#text()[0]
"
>
{
props
.
title
}
<
span
>
...
</
span
>
</
div
>
)
;
}
#
Elements that render multiple fields
In some cases, an element can render two fields from the same object. You can specify both fields separated by a space, applying the proper xpath as necessary.
export
function
MyComponent
(
props
)
{
return
(
<
div
data-sb-field-path
=
"
title#text()[0] subtitle#text()[2]
"
>
{
props
.
title
}
<
span
>
...
</
span
>
{
props
.
subtitle
}
</
div
>
)
;
}
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_page-editor.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/page-editor/
Scraped_At: 2025-06-02T19:59:53.487717

Contact
Forums
Contact support
The page editor provides the ability to edit fields based on the context of actions taken within the sitemaps navigator and preview.
#
Enable the page editor
The page editor is enabled when Visual Editor knows that a document is associated with a particular URL path in the website. In other words, the sitemap must be populated, with documents attached to the proper URL paths.
#
Automatic document resolution
Visual Editor automatically builds the sitemap by combining the
urlPath
properties of all documents of type
page
, attaching each document to each URL path.
These properties get set on model definitions, which often requires using
modelExtensions
for API-based content sources.
// stackbit.config.ts
import
{
defineStackbitConfig
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
contentSources
:
[
// ...
]
,
modelExtensions
:
[
{
name
:
"page"
,
type
:
"page"
,
urlPath
:
"/{slug}"
}
]
}
)
;
#
Enable page editing manually
For cases where the there isn't a direct one-to-one mapping between document objects and URL paths, pages can be enabled by setting the
document
property when manually building the
siteMap
.
// stackbit.config.ts
import
{
defineStackbitConfig
,
getLocalizedFieldForLocale
,
SiteMapEntry
}
from
"@stackbit/types"
;
export
default
defineStackbitConfig
(
{
stackbitVersion
:
"~0.6.0"
,
siteMap
:
(
{
documents
,
models
}
)
=>
{
const
pageModels
=
models
.
filter
(
m
=>
m
.
type
===
"page"
)
.
map
(
m
=>
m
.
name
)
;
return
documents
.
filter
(
d
=>
pageModels
.
includes
(
d
.
modelName
)
)
.
map
(
document
=>
{
// ...
return
{
document
// ...
}
;
}
)
.
filter
(
Boolean
)
as
SiteMapEntry
[
]
;
}
}
)
;
#
Highlight active elements
Visual Editor highlights elements in the preview that are actively focused in the page editor. Enabling this requires
annotating pages and components
.
Last updated: June 5, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_sidebar-buttons.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/sidebar-buttons/
Scraped_At: 2025-06-02T19:59:55.102345

Contact
Forums
Contact support
The sidebar buttons include triggers for Visual Editor’s primary editing capabilities but can also be extended to provide custom controls.
#
Standard buttons
Aside from the logo (which navigates back to the dashboard), the sidebar has a few standard buttons that cannot be altered:
Page Editor:
Toggles the panel to edit the current page. (See
the page editor guide
for details.)
Content Editor
: Toggles the more traditional content editing mode. (See
the content editor guide
for details.)
Components:
Toggles the component presets page which shows a list of all available components. (See
the content presets guide
for details.)
#
Custom buttons
Custom buttons can be added to the sidebar buttons that perform the following actions:
Direct access to edit content objects
Navigate to a specific site page
Open an external URL
These behaviors are enabled by specifying the
type
of button in the
sidebarButtons
configuration property
.
#
Content editing shortcuts
When viewing a page within the preview, typically most of the editable content is available within the context of the current page. And the page editor will adjust itself for the context of the current page.
However, there may be objects that should always be available, as they would affect the content or styling of any page. This might include layout-based content for the header and footer, or other global settings like default SEO values or base-level global styles.
In most cases, these shortcuts are used for either
single instance
page models or data objects (which are also single instance models). In these cases,
type
should be set to
model
, and the appropriate
modelName
should be specified.
// stackbit.config.js
export
default
{
sidebarButtons
:
[
{
label
:
"Site management"
,
type
:
"model"
,
icon
:
"tools"
,
modelName
:
"SiteConfig"
}
]
}
;
#
Identify documents
Alternatively, you can use the ID. This is particularly helpful when targeting a single document within a model containing multiple documents.
// stackbit.config.js
export
default
{
sidebarButtons
:
[
{
label
:
"Specific document"
,
type
:
"document"
,
icon
:
"user-management"
,
documentId
:
"content/data/config.json"
}
]
}
;
Identifying the document is unique to the content source. Each content source module must normalize the
id
property of a document when transforming it for use in Visual Editor. Unless otherwise noted
in the content source guides
, this is likely the same value used to uniquely identify the object within the content source.
#
Multiple content sources
When using more than one content source, you must specify
srcType
and
srcProjectId
, alongside the other properties.
// stackbit.config.js
export
default
{
sidebarButtons
:
[
{
label
:
"Document in specific content source"
,
type
:
"document"
,
icon
:
"user-management"
,
documentId
:
"hGa71n3gba8"
,
srcType
:
"contentful"
,
srcProjectId
:
process
.
env
.
CONTENTFUL_SPACE_ID
}
]
}
;
These values are provided by the content source as
getContentSourceType
and
getProjectId
.
#
Navigate to page
When in an editing context, teams often bring in meta information or other hidden content to help make managing their site easier. For example, there may be an analytics dashboard on a page that is only visible in development mode.
In this case, providing a relative path to that page is enough for a button to navigate directly to it.
// stackbit.config.js
export
default
{
sidebarButtons
:
[
{
label
:
"Internal page"
,
type
:
"link"
,
icon
:
"analytics"
,
url
:
"/internal-page"
}
]
}
;
#
Open external URL
Opening external URLs work similarly. If Visual Editor finds a domain or full URL, it will open an external URL, rather than trying to navigate within the site.
// stackbit.config.js
export
default
{
sidebarButtons
:
[
{
label
:
"External link"
,
type
:
"link"
,
icon
:
"external-link"
,
url
:
"my-live-site.com"
}
]
}
;
#
Choose icons
Icons can be chosen from a list of available icons. These are listed in
the
sidebarButtons
reference
.
#
Troubleshoot custom buttons
In case a button does not work as expected, check the following:
The
type
is set to
model
,
document
, or
link
.
If using
type: "model"
, the
modelName
value must be set to exactly the model's name in the CMS. It is common for CMS's to have both a display name and a fixed identifier for models. The latter is what you need, and it is typically case-sensitive.
If using
type: "document"
, ensure the
documentId
is in exactly the same format as you're using for inline editing annotations.
For internal links (
type: "link"
), the
url
must be set to a relative URL.
Last updated: November 8, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- visual-editor_visual-editing_status-labels.txt --------
Start of file
URL: https://docs.netlify.com/visual-editor/visual-editing/status-labels/
Scraped_At: 2025-06-02T19:59:56.806918

Contact
Forums
Contact support
To understand the status of content in the visual editor and how it relates to content from the content source, you can rely on the visual editor’s document status labels.
Document statuses are shown in the following locations in the visual editor:
Beside the title in the
page editor
Content editor
lists and detail views
Next to the type name when
editing inline
List of changed items in the
publishing
dialog
A
document
refers to a content entry that is in the visual editor with the additional methods and properties that the visual editor provides. A
content entry
is a generic term for a record in the content source.
#
Supported document statuses
The visual editor supports three primary statuses for content that are visible in the visual editor:
New:
The current version of this document has been created but not yet published and has never been published before.
Changed:
The current version of this document was previously published but has changes that are not yet published.
Published:
The current version of this document is live in production.
#
Archived or unpublished content
If your content source supports an
Archived
or
Unpublished
status for a content entry, then the visual editor will remove this content from the visual editor for you.
To find content with a status of
Archived
or
Unpublished
, check your content source. Note that content that is
Unpublished
is typically a page or component that has been removed from the live site but not deleted.
We recommend checking documentation for your content source to help you understand statuses that your content source uses.
#
Status labels
Labels are shown for the
new
and
changed
states in most cases to indicate that it includes content not yet published. Documents without a label are assumed to be published, with exceptions noted below.
#
Publishing dialog
In the publishing dialog, only
new
labels are shown. Documents without labels are assumed to be
changed
, as published documents will never appear.
#
Filter by status
In the content tab, documents can be filtered by their status.
Last updated: August 29, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- welcome_add-new-project.txt --------
Start of file
URL: https://docs.netlify.com/welcome/add-new-project/
Scraped_At: 2025-06-02T19:59:57.394415

Get started with Netlify
Deploy to Netlify
Follow our tutorial
Demo repo
Demo site
###End of file##

-------- welcome_command-palette.txt --------
Start of file
URL: https://docs.netlify.com/welcome/command-palette/
Scraped_At: 2025-06-02T19:59:58.322846

Contact
Forums
Contact support
The Command Palette is a convenience tool that gives you quick navigation through the Netlify UI and access to various commands.
Here are some examples of actions with the Command Palette:
Jump to any site on any of your teams
Navigate directly to a deeply-nested feature or setting
Search the
docs
,
blog
, and
support forums
from within the Netlify UI
Toggle between light and dark themes
Set custom keyboard shortcuts to quickly jump between sections of the Netlify UI
#
Get started
While using the Netlify UI, you can access the Command Palette at any time in two ways:
Simultaneously press
command
+
K
on macOS, or
ctrl
+
K
on Windows and Linux.
In the navigation, select the search input.
Either method will enable the Command Palette in the center of your browser window.
To close the Command Palette, complete an action, press your keyboard shortcut again, or press
esc
.
#
Use the Command Palette
After opening the Command Palette, start entering text to filter the list of available commands, then select a command from the list.
Tip
You can search for a site by typing its name right away. You don’t need to select the
Search sites...
command first.
#
Command scope
Some commands become available based on the context of where you are in the Netlify UI. For example, searching for Functions or Forms is only available once you navigate to a site in the Netlify UI. Similarly, commands to open a deploy’s Git repository or pull/merge request in a new tab are only available if you’ve navigated to a deploy for a site connected to a Git repository for continuous deployment.
If you want to edit a site-specific setting — such as changing environment variables — navigate to the site first by entering the site name and selecting it from the filtered list. You can then search for environment variables and jump directly to the site’s list of variables.
#
Custom keyboard shortcuts
To achieve repetitive tasks faster, set up
custom keyboard shortcuts
(available to trackpad and mouse users only).
For example, if you find yourself frequently navigating to your team’s build usage & insights page, you can assign the keyboard shortcut
B
to that page to get there faster:
Open the Command Palette, find “Builds usage & insights”, and hover over the right side of the entry.
Select
Add shortcut
and then type the desired keyboard shortcut.
Next time you type
B
, you will navigate to the
Builds
>
Usage & insights
page directly.
Last updated: November 29, 2024
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- welcome_get-help_ask-netlify.txt --------
Start of file
URL: https://docs.netlify.com/welcome/get-help/ask-netlify/
Scraped_At: 2025-06-02T19:59:58.955340

Contact
Forums
Contact support
Ask Netlify
is a generative AI chatbot that can help you find the answers you need to be successful using Netlify. Our chatbot assistant leverages the OpenAI API to provide natural language answers based on our product documentation, Support Forums, blog, CLI documentation, and API documentation in one place.
Sometimes you need to ask a human
If you’re having trouble logging in, need a site or DNS transfer, or are encountering fraud,
contact the support team
instead.
AI-generated content disclaimer
This experimental feature uses artificial intelligence (AI) to provide you with efficient access to information about Netlify. However, it may not always understand the full context of your query or produce a reliable, accurate answer. When in doubt, please refer to our
documentation
or other
help resources
.
#
Access and use the feature
To access the generative AI chatbot:
Select
Ask Netlify
or its owl icon at the top of any Netlify Docs page.
Alternatively, set up the
Netlify App for Slack
and enter
@Netlify
in any public or private Slack channel where the Netlify App is added.
In order to prevent spam and abuse, we require you to have a Netlify account and log in to use this feature on our docs site. If you would rather not log in, you can continue to browse or search our docs without having to do so.
From the
Ask Netlify
docs page, you can ask questions about how to get started, troubleshoot an issue, or find more information about how to use a specific feature.
For example:
“How do I protect my site behind a password?”
“How can I rollback my site to a previous version?”
“What’s the difference between Functions and Edge Functions?”
“How do I install the Netlify CLI?”
You can submit a follow-up query after your initial prompt to gather additional information.
#
How it works
We use all of the content from this
docs site
, our
CLI reference
,
tutorials
, other recent content from our blog, and selected posts from our
Support Forums
. We then make requests to the OpenAI API with this context so the answers are limited to Netlify topics.
#
User information
In order to manage spam requests and to understand the most frequently asked questions, we log your Netlify user ID and the questions you submit with the Ask Netlify feature. Gathering this data helps us improve our docs and our product overall.
Your user ID is not shared with OpenAI or any third-party as part of this feature. Your questions are sent to the OpenAI API along with additional context from our docs to generate the most relevant response.
#
Privacy
Use of Ask Netlify is subject to Netlify’s
privacy policy
.
Don’t submit sensitive data
Sensitive personal data should not be submitted to Ask Netlify. This includes text or other data containing or revealing government-issued identification numbers; financial information such as credit or debit card numbers, any related security codes or passwords, and bank account numbers; personal information such as racial or ethnic origin, political opinions, religious or philosophical beliefs, trade-union membership, information concerning health or sex life; information related to an individual’s physical or mental health; and information related to the provision or payment of health care.
#
Provide feedback
We welcome your feedback or additional questions about this feature. You can share your thoughts in the form at the end of this page or by posting to our
Support Forums
.
Last updated: October 2, 2024
←
Help resources and tips
Did you find this doc useful?
Your feedback helps us improve our docs.
Do not fill in this field
What else would you like to tell us about this doc?
Send
###End of file##

-------- welcome_get-help_resources-and-tips.txt --------
Start of file
URL: https://docs.netlify.com/welcome/get-help/resources-and-tips/
Scraped_At: 2025-06-02T20:00:00.218031

Get started with Netlify
Deploy to Netlify
Deploy a demo project on Netlify to make it available on the web. Get to know some key features including Deploy Previews, rollbacks, Netlify Functions, environment variables, redirects, and Netlify Forms.
Follow our tutorial
Demo repo
Demo site
###End of file##

